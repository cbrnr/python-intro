[
  {
    "objectID": "09/09.html",
    "href": "09/09.html",
    "title": "9 – Numerische Daten",
    "section": "",
    "text": "Python wurde ursprünglich als einfach zu erlernende Programmiersprache entwickelt. Aufgrund seiner Lesbarkeit und der großen Anzahl wissenschaftlicher Zusatzpakete hat sich Python weit verbreitet, vor allem im Bereich der Datenverarbeitung und Datenanalyse. Für numerische Aufgaben sind insbesondere folgende Pakete essentiell:\n\nNumPy (Arbeiten mit numerischen Daten)\nSciPy (wissenschaftliche Algorithmen)\nMatplotlib (Erstellung von Grafiken)\nPandas (Arbeiten mit Tabellen)\n\nDarüber hinaus gibt es viele weitere Pakete für spezifischere Anwendungen wie z.B. Scikit-learn (Machine Learning), statsmodels (Statistik), scikit-image (Bildverarbeitung) und SymPy (symbolisches Rechnen). Diese Pakete setzen alle NumPy als Grundlage voraus, welches wir in dieser Einheit näher kennenlernen werden."
  },
  {
    "objectID": "09/09.html#allgemeines",
    "href": "09/09.html#allgemeines",
    "title": "9 – Numerische Daten",
    "section": "",
    "text": "Python wurde ursprünglich als einfach zu erlernende Programmiersprache entwickelt. Aufgrund seiner Lesbarkeit und der großen Anzahl wissenschaftlicher Zusatzpakete hat sich Python weit verbreitet, vor allem im Bereich der Datenverarbeitung und Datenanalyse. Für numerische Aufgaben sind insbesondere folgende Pakete essentiell:\n\nNumPy (Arbeiten mit numerischen Daten)\nSciPy (wissenschaftliche Algorithmen)\nMatplotlib (Erstellung von Grafiken)\nPandas (Arbeiten mit Tabellen)\n\nDarüber hinaus gibt es viele weitere Pakete für spezifischere Anwendungen wie z.B. Scikit-learn (Machine Learning), statsmodels (Statistik), scikit-image (Bildverarbeitung) und SymPy (symbolisches Rechnen). Diese Pakete setzen alle NumPy als Grundlage voraus, welches wir in dieser Einheit näher kennenlernen werden."
  },
  {
    "objectID": "09/09.html#numpy",
    "href": "09/09.html#numpy",
    "title": "9 – Numerische Daten",
    "section": "NumPy",
    "text": "NumPy\nNumPy stellt einen hocheffizienten Datentyp für numerische Daten zur Verfügung, nämlich ein homogenes multidimensionales (n-dimensionales) Array (auch kurz ND-Array bzw. ndarray oder einfach Array genannt). Listen sind aufgrund ihrer Flexibilität dafür viel zu ineffizient, da sie unterschiedliche Elemente enthalten können. Homogen bedeutet in diesem Zusammenhang, dass alle Elemente eines Arrays denselben Datentyp haben müssen (z.B. lauter float-Werte) – dadurch können Berechnungen wesentlich effizienter und schneller ausgeführt werden. Multidimensional bedeutet, dass ein Array beliebig viele Dimensionen (auch Achsen genannt) besitzen kann. Jedes Element wird daher mit einem Tupel indiziert, welches seine genaue Position innerhalb des Arrays beschreibt.\n\n\n\n\n\n\nTipp\n\n\n\nDas offizielle Tutorial NumPy: the absolute basics for beginners ergänzt bzw. vertieft die Inhalte dieser Unterlagen – die Lektüre ist sehr zu empfehlen!\n\n\nBeginnen wir aber mit einem einfachen Beispiel, Details zu den einzelnen Befehlen folgen dann später. Konventionell importiert man NumPy mit dem Kürzel np:\n\nimport numpy as np\n\nDies bedeutet, dass man das Paket mit np ansprechen kann statt mit numpy – man spart sich also ein paar Zeichen zu tippen. Wir erstellen nun eine Zahlensequenz aus 15 Zahlen:\n\na = np.arange(15)  # 15 Zahlen (von 0 bis 14)\n\n\na\n\narray([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11, 12, 13, 14])\n\n\nDer Typ des Objekts a ist nun keine Liste, sondern tatsächlich ein NumPy-Array, welches als numpy.ndarray bezeichnet wird:\n\ntype(a)\n\nnumpy.ndarray\n\n\nNumPy-Arrays besitzen eine Form (Shape):\n\na.shape  # 15 Elemente in einer Dimension (Achse)\n\n(15,)\n\n\nDiese Form kann man auch verändern:\n\na = a.reshape((3, 5))  # umwandeln in 3 Zeilen und 5 Spalten\n\n\na  # 2 Dimensionen (Achsen) mit Längen 3 bzw. 5\n\narray([[ 0,  1,  2,  3,  4],\n       [ 5,  6,  7,  8,  9],\n       [10, 11, 12, 13, 14]])\n\n\n\na.ndim  # Anzahl an Dimensionen (Achsen)\n\n2\n\n\n\na.shape  # Länge der einzelnen Achsen\n\n(3, 5)\n\n\nUnabhängig von der Form kann man auch die Gesamtanzahl der Elemente im Array bestimmen:\n\na.size  # Anzahl aller Elemente im Array\n\n15\n\n\nNumPy-Arrays sind homogene Datentypen, d.h. alle Elemente im Array müssen denselben Typ haben. Diesen Typ kann man wie folgt bestimmen:\n\na.dtype  # Datentyp aller Elemente im Array\n\ndtype('int64')\n\n\nHier steht int64 für 64-Bit-Ganzzahlen (Integer). Hätten wir stattdessen Dezimalzahlen (Gleitkommazahlen, float), würde hier z.B. float64 stehen.\nBeginnen wir nach diesem einführenden Beispiel nun aber von vorne und sehen wir uns an, wie wir unterschiedlichste NumPy-Arrays erstellen können."
  },
  {
    "objectID": "09/09.html#erstellen-von-arrays",
    "href": "09/09.html#erstellen-von-arrays",
    "title": "9 – Numerische Daten",
    "section": "Erstellen von Arrays",
    "text": "Erstellen von Arrays\n\nAus Listen\nArrays können mit der Funktion np.array aus Listen (oder Tupeln) erstellt werden. Im folgenden Beispiel übergeben wir der Funktion eine Liste als Argument, und daraus wird dann ein NumPy-Array erzeugt:\n\nb = np.array([1.1, 3.14, 7.68, -12.69, -4.55])  # aus einer Liste\nb\n\narray([  1.1 ,   3.14,   7.68, -12.69,  -4.55])\n\n\nEine Liste von Listen wird in ein zweidimensionales Array (also eine Tabelle, die aus Zeilen und Spalten besteht) konvertiert:\n\nc = np.array([[1, 2, 3], [4, 5, 6]])  # aus einer Liste von Listen\nc\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n\nc.shape  # 2 Zeilen, 3 Spalten\n\n(2, 3)\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nEin eindimensionales Array kann man sich wie eine Liste vorstellen, wohingegen ein zweidimensionales Array einer Tabelle entspricht. Für höherdimensionale Arrays gibt es keine speziellen Bezeichnungen.\n\n\n\n\nKonstant befüllte Arrays\nIm Gegensatz zu Listen, welche dynamisch wachsen können (z.B. mit der append-Methode), sollte die Größe von Arrays bereits bei der Erstellung bekannt sein, da das Hinzufügen von Zeilen oder Spalten relativ langsam ist. Hierfür gibt es einige praktische Konstruktionen, welche Arrays mit Platzhalterelementen wie z.B. lauter Nullen erzeugen.\n\nnp.zeros((3, 4))  # Nullen in 3 Zeilen und 4 Spalten\n\narray([[0., 0., 0., 0.],\n       [0., 0., 0., 0.],\n       [0., 0., 0., 0.]])\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nDie Funktion np.zeros wird mit einem Argument für die gewünschte Form (Shape) aufgerufen, nämlich mit dem Tupel (3, 4) im vorigen Beispiel. Deswegen benötigt man hier ein weiteres Klammernpaar, um ein Tupel als erstes Argument zu übergeben. Der Aufruf np.zeros(3, 4) funktioniert nicht, da man hier zwei Argumente übergeben würde. Lesen Sie in der Hilfe nach, was die ersten beiden Parameter der Funktion bedeuten!\n\n\n\n\n\n\n\n\nTipp\n\n\n\nÜbersichtlicher ist es, wenn Sie Keyword-Argumente nutzen, also beispielsweise:\nnp.zeros(shape=(3, 4))\n\n\n\nnp.ones((2, 4))  # Einsen\n\narray([[1., 1., 1., 1.],\n       [1., 1., 1., 1.]])\n\n\nArrays, die mit Zahlen ungleich 0 oder 1 gefüllt werden sollen, kann man mit der Funktion np.full erzeugen:\n\nnp.full((3, 4), 66)  # 3 Zeilen, 4 Spalten, alle Elemente gleich 66\n\narray([[66, 66, 66, 66],\n       [66, 66, 66, 66],\n       [66, 66, 66, 66]])\n\n\n\n\nSequenzen\nAnalog zur Builtin-Funktion range können mit np.arange Arrays mit Zahlenfolgen erstellt werden. Hier sind nicht nur ganze Zahlen möglich, sondern auch Dezimalzahlen. Auch hier zählt der letzte Wert (Stopp-Wert) nicht mehr zum Bereich dazu.\n\nnp.arange(5, 17)\n\narray([ 5,  6,  7,  8,  9, 10, 11, 12, 13, 14, 15, 16])\n\n\n\nnp.arange(0.3, 5.4, 0.6)  # von 0.3 bis 5.4 mit Schrittweite 0.6\n\narray([0.3, 0.9, 1.5, 2.1, 2.7, 3.3, 3.9, 4.5, 5.1])\n\n\n\n\n\n\n\n\nTipp\n\n\n\nAuch hier sind Keyword-Argumente vielleicht übersichtlicher:\nnp.arange(start=0.3, stop=5.4, step=0.6)\n\n\nWenn man die Anzahl der Elemente (anstatt der Schrittweite) vorgeben will, verwendet man am besten die Funktion linspace. Achtung: Hier zählen sowohl Start- als auch Endwert zum Bereich dazu!\n\nnp.linspace(1, 10, 10)  # 10 Elemente von 1 bis 10\n\narray([ 1.,  2.,  3.,  4.,  5.,  6.,  7.,  8.,  9., 10.])\n\n\n\nnp.linspace(1, 10, 10, dtype=int)  # wie oben, nur Integer-Elemente\n\narray([ 1,  2,  3,  4,  5,  6,  7,  8,  9, 10])\n\n\n\nnp.linspace(1, 10, 24)  # 24 Elemente von 1 bis 10\n\narray([ 1.        ,  1.39130435,  1.7826087 ,  2.17391304,  2.56521739,\n        2.95652174,  3.34782609,  3.73913043,  4.13043478,  4.52173913,\n        4.91304348,  5.30434783,  5.69565217,  6.08695652,  6.47826087,\n        6.86956522,  7.26086957,  7.65217391,  8.04347826,  8.43478261,\n        8.82608696,  9.2173913 ,  9.60869565, 10.        ])\n\n\nSollen die Elemente nicht den gleichen (linearen) Abstand haben, sondern logarithmisch unterteilt sein, gibt es analog dazu die Funktion logspace:\n\nnp.logspace(0, 4, 8)  # 8 Werte von 10**0 bis 10**4\n\narray([1.00000000e+00, 3.72759372e+00, 1.38949549e+01, 5.17947468e+01,\n       1.93069773e+02, 7.19685673e+02, 2.68269580e+03, 1.00000000e+04])\n\n\n\n\nZufallszahlen\nOft möchte man auch Zufallszahlen erzeugen. Dazu gibt es in NumPy einen sogenannten Zufallszahlengenerator, welcher Zahlen aus unterschiedlichsten Verteilungen generieren kann. Zunächst importiert man die Funktion default_rng aus dem numpy.random-Modul:\n\nfrom numpy.random import default_rng\n\n\n\n\n\n\n\nTipp\n\n\n\nDie Abkürzung rng steht für Random Number Generator, also Zufallszahlengenerator.\n\n\nDanach erzeugt man damit ein Generator-Objekt. Dieses kann man auch in einen definierten Anfangszustand versetzen, indem man als Seed eine beliebige Zahl angibt:\n\nrng = default_rng(seed=42)\n\nIn diesem Beispiel initialisieren wir den Generator mit 42 (wir könnten aber auch jede beliebige andere Zahl nehmen). Die Initialisierung bewirkt, dass der Generator danach dieselbe Folge an Zufallszahlen ausspuckt (es bedeutet nicht, dass die erste Zufallszahl 42 ist!). Lässt man die Initialisierung mit einer Zahl weg, dann wird der Generator in einen nicht-reproduzierbaren Zustand initialisiert (der Seed wird z.B. aus der aktuellen Uhrzeit, der Mausposition u.ä. gebildet). Das bedeutet, dass bei jeder erneuten Ausführung eines Scripts andere Zufallszahlen gezogen werden, was nicht im Sinne der Reproduzierbarkeit von Ergebnissen ist.\nDurch Methoden des Generators kann man jetzt Zufallszahlen mit der gewünschten Verteilung erzeugen:\n\nrng.standard_normal(10)  # 10 normalverteilte Zufallszahlen\n\narray([ 0.30471708, -1.03998411,  0.7504512 ,  0.94056472, -1.95103519,\n       -1.30217951,  0.1278404 , -0.31624259, -0.01680116, -0.85304393])\n\n\n\nrng.uniform(size=(2, 2))  # gleichverteilte Zufallszahlen\n\narray([[0.37079802, 0.92676499],\n       [0.64386512, 0.82276161]])\n\n\n\nrng.integers(low=-3, high=99, size=(2, 5))  # Ganzzahlen\n\narray([[52, 42, 42, 20,  6],\n       [53, 87,  3, 84, 81]])\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nWenn Sie die obigen Beispiele auf Ihrem Rechner nachvollziehen, sollten Sie dieselben Zufallszahlen bekommen – vorausgesetzt Sie initialisieren den Generator so wie hier mit dem Wert 42."
  },
  {
    "objectID": "09/09.html#rechnen-mit-arrays",
    "href": "09/09.html#rechnen-mit-arrays",
    "title": "9 – Numerische Daten",
    "section": "Rechnen mit Arrays",
    "text": "Rechnen mit Arrays\n\nArithmetische Operationen\nArithmetische Operationen werden grundsätzlich elementweise angewendet. Betrachten wir die beiden Arrays a und b:\n\na = np.arange(100, 700, 100).reshape((2, 3))\nb = np.arange(1, 7).reshape((2, 3))\n\n\na\n\narray([[100, 200, 300],\n       [400, 500, 600]])\n\n\n\nb\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\nDie folgenden Operationen werden elementweise berechnet:\n\na * 2\n\narray([[ 200,  400,  600],\n       [ 800, 1000, 1200]])\n\n\n\na + b\n\narray([[101, 202, 303],\n       [404, 505, 606]])\n\n\n\na * b\n\narray([[ 100,  400,  900],\n       [1600, 2500, 3600]])\n\n\n\nb**2\n\narray([[ 1,  4,  9],\n       [16, 25, 36]])\n\n\n\na &lt; 300\n\narray([[ True,  True, False],\n       [False, False, False]])\n\n\nSind die zwei Arrays nicht gleich groß, wird das kleinere Array falls möglich vergrößert (d.h. Werte werden automatisch dupliziert) – dies nennt man Broadcasting. Das folgende Beispiel zeigt eine Multiplikation von einem Array der Shape (2, 3) mit der Zahl 5, was einer Shape von (1,) entspricht:\n\nb.shape\n\n(2, 3)\n\n\n\nb * 5\n\narray([[ 5, 10, 15],\n       [20, 25, 30]])\n\n\nHier wird also die Zahl 5 automatisch vervielfältigt, sodass die Operation elementweise durchgeführt werden kann. Im Prinzip ist diese Operation äquivalent zu folgender Schreibweise:\n\nb * np.array([[5, 5, 5], [5, 5, 5]])\n\narray([[ 5, 10, 15],\n       [20, 25, 30]])\n\n\nEin weiteres Beispiel für Broadcasting ist, wenn wir ein Array c wie folgt erstellen:\n\nc = np.array([1, 2, 3])\n\nWir können nun das Array c direkt zum Array b addieren, weil die Dimensionen kompatibel sind: b hat 2 Zeilen und 3 Spalten und c hat 3 Elemente. Durch Broadcasting wird die Operation nun spaltenweise angewendet:\n\nb\n\narray([[1, 2, 3],\n       [4, 5, 6]])\n\n\n\nc\n\narray([1, 2, 3])\n\n\n\nb + c\n\narray([[2, 4, 6],\n       [5, 7, 9]])\n\n\n\n\nMethoden\nViele Funktionen wie z.B. sum, mean, min oder max sind als Methoden von ndarray-Objekten verfügbar. Standardmäßig verarbeiten sie dabei alle Elemente so, als ob diese in einer Dimension wären. Alternativ zu den Methoden gibt es auch Funktionen mit den gleichen Namen.\n\na.mean()  # Methode\n\nnp.float64(350.0)\n\n\n\nnp.mean(a)  # Funktion\n\nnp.float64(350.0)\n\n\n\nb.sum()\n\nnp.int64(21)\n\n\n\nb.max()\n\nnp.int64(6)\n\n\n\na.min()\n\nnp.int64(100)\n\n\nMan kann diese Funktionen/Methoden aber auch auf einzelne Dimensionen (auch “Achsen” genannt) anwenden, z.B. auf Zeilen oder Spalten. Dabei entspricht die Dimension 0 den Zeilen und die Dimension 1 den Spalten.\n\n\n\n\n\n\nTipp\n\n\n\nEigentlich entsprechen die letzten beiden Dimensionen den Zeilen und Spalten (bei einem zweidimensionalen Array sind das die Dimensionen 0 für die Zeilen und 1 für die Spalten). Ein dreidimensionales Array mit den Dimensionen (3, 4, 5) besteht also aus 3 Blöcke zu je 4 Zeilen und 5 Spalten.\n\n\n\na.mean(axis=0)  # Mittelwert entlang der Zeilen, d.h. Spaltenmittelwerte\n\narray([250., 350., 450.])\n\n\n\na.mean(axis=1)  # Mittelwert entlang der Spalten, d.h. Zeilenmittelwerte\n\narray([200., 500.])\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDas axis-Argument gibt an, welche Dimensionen verschwinden. Bei a.mean(axis=0) verschwinden also die Zeilen (es wird der Mittelwert über die Zeilen gerechnet), und übrig bleiben nur mehr die Spaltenmittelwerte."
  },
  {
    "objectID": "09/09.html#indizieren-und-slicen",
    "href": "09/09.html#indizieren-und-slicen",
    "title": "9 – Numerische Daten",
    "section": "Indizieren und Slicen",
    "text": "Indizieren und Slicen\nAnalog zu anderen Sequenzdatentypen (z.B. String, Liste oder Tupel) können einzelne Elemente aus Arrays durch Indizieren bzw. Slicen herausgegriffen werden. Eindimensionale Arrays werden im Prinzip genau wie Listen indiziert.\n\na = np.arange(10)**3\na\n\narray([  0,   1,   8,  27,  64, 125, 216, 343, 512, 729])\n\n\n\na[0]  # erstes Element (Indizierung beginnt bei 0)\n\nnp.int64(0)\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nEin einzelnes Element eines NumPy-Arrays ist kein Array mehr, sondern ein Skalar (also eine einzelne Zahl). Der NumPy-Datentyp wird aber beibehalten und entspricht nicht den normalen Python-Datentypen wie int oder float (sondern z.B. numpy.int64 oder numpy.float64). Wenn man so einen Wert in einer Berechnung verwendet, wird er automatisch in den entsprechenden Python-Datentyp konvertiert. Man kann den Wert aber auch explizit mit item() in einen eingebauten Python-Datentyp umwandeln (dies ist aber wie gesagt normalerweise nicht notwendig):\n\na[0].item()  # erstes Element als int\n\n0\n\n\n\na.item(0)  # oder noch einfacher\n\n0\n\n\n\n\n\na[-2]  # vorletztes Element\n\nnp.int64(512)\n\n\n\na[2:5]  # drei Elemente, beginnend mit Position 2\n\narray([ 8, 27, 64])\n\n\n\na[::2]  # jedes zweite Element\n\narray([  0,   8,  64, 216, 512])\n\n\nMehrdimensionale Arrays haben einen Index pro Achse:\n\nb = rng.integers(low=0, high=100, size=(5, 4))\n\n\nb\n\narray([[47, 51, 75, 95],\n       [ 3, 14, 82, 94],\n       [24, 31, 86, 42],\n       [27, 82, 25, 40],\n       [64, 54,  8,  2]])\n\n\n\nb.shape\n\n(5, 4)\n\n\n\nb[2, 3]  # 3. Zeile, 4. Spalte\n\nnp.int64(42)\n\n\n\nb[:, -1]  # alle Zeilen, letzte Spalte\n\narray([95, 94, 42, 40,  2])\n\n\n\nb[0, :]  # erste Zeile\n\narray([47, 51, 75, 95])\n\n\n\nb[1:3, 2:]\n\narray([[82, 94],\n       [86, 42]])\n\n\nMit Listen kann man mehrere (auch gleiche) spezifische Positionen aus einem Array indizieren. Der Einfachkeit halber sei dies an einem 1D-Array veranschaulicht:\n\na = np.arange(12)**2\na\n\narray([  0,   1,   4,   9,  16,  25,  36,  49,  64,  81, 100, 121])\n\n\n\nidx = [2, 7, 10, 10]  # wir wollen das 2., 7., 10. und 10. Element\nidx\n\n[2, 7, 10, 10]\n\n\n\na[idx]\n\narray([  4,  49, 100, 100])\n\n\nDen Namen idx für die Liste benötigt man nicht, man kann diese direkt innerhalb der eckigen Klammern angeben (das erste eckige Klammernpaar ist die Indizierung, und das zweite eckige Klammernpaar kennzeichnet die Liste):\n\na[[2, 7, 10, 10]]\n\narray([  4,  49, 100, 100])\n\n\nMit Bool’schen Indexarrays kann man Arrays ebenfalls indizieren (maskieren):\n\na % 2 == 0  # wird elementweise verglichen\n\narray([ True, False,  True, False,  True, False,  True, False,  True,\n       False,  True, False])\n\n\n\na[a % 2 == 0]\n\narray([  0,   4,  16,  36,  64, 100])\n\n\nEs werden hier also nur jene Elemente herausgegriffen, für die das Indexarray True ist."
  },
  {
    "objectID": "09/09.html#form-shape",
    "href": "09/09.html#form-shape",
    "title": "9 – Numerische Daten",
    "section": "Form (Shape)",
    "text": "Form (Shape)\nDie Form eines Arrays lässt sich auf folgende Arten einsehen bzw. ändern:\n\nc = rng.integers(low=-100, high=100, size=(3, 4))\nc\n\narray([[ 73,  50,  67,   7],\n       [ 63, -35, -10,  57],\n       [-76, -40, -76, -10]])\n\n\n\nc.shape  # gibt die aktuelle Form aus\n\n(3, 4)\n\n\n\nc.shape = 2, 6  # ändert die Form in place\nc\n\narray([[ 73,  50,  67,   7,  63, -35],\n       [-10,  57, -76, -40, -76, -10]])\n\n\n\nc.resize((4, 3))  # ändert die Form in place\nc\n\narray([[ 73,  50,  67],\n       [  7,  63, -35],\n       [-10,  57, -76],\n       [-40, -76, -10]])\n\n\n\nc.reshape((1, -1))  # reshape gibt ein neues Array zurück\n\narray([[ 73,  50,  67,   7,  63, -35, -10,  57, -76, -40, -76, -10]])\n\n\n\nc  # das ursprüngliche Array wird nicht verändert\n\narray([[ 73,  50,  67],\n       [  7,  63, -35],\n       [-10,  57, -76],\n       [-40, -76, -10]])\n\n\n\nc = c.reshape((1, -1))  # daher sollte man einen Namen zuweisen\nc\n\narray([[ 73,  50,  67,   7,  63, -35, -10,  57, -76, -40, -76, -10]])\n\n\n\n\n\n\n\n\nTipp\n\n\n\nMan muss bei reshape nicht alle Dimensionen angeben – eine kann man auf -1 setzen, was bedeutet, dass NumPy die korrekte Anzahl automatisch bestimmt. Dies ist möglich, da die Anzahl aller Elemente konstant bleiben muss.\n\n\nDer Unterschied zwischen resize und reshape ist also, das resize das Array direkt modifiziert und reshape ein neues (geändertes) Array zurückgibt."
  },
  {
    "objectID": "09/09.html#kombinieren-von-arrays",
    "href": "09/09.html#kombinieren-von-arrays",
    "title": "9 – Numerische Daten",
    "section": "Kombinieren von Arrays",
    "text": "Kombinieren von Arrays\nMit den Funktionen hstack und vstack können Arrays horizontal bzw. vertikal miteinander kombiniert werden.\n\na = rng.integers(low=-100, high=100, size=(2, 3))\nb = rng.integers(low=-100, high=100, size=(2, 3))\n\n\na\n\narray([[ 95, -74, -24],\n       [-20,  80, -60]])\n\n\n\nb\n\narray([[  0, -48, -97],\n       [ 50, -88, -44]])\n\n\n\nnp.hstack((a, b))\n\narray([[ 95, -74, -24,   0, -48, -97],\n       [-20,  80, -60,  50, -88, -44]])\n\n\n\nnp.vstack((a, b))\n\narray([[ 95, -74, -24],\n       [-20,  80, -60],\n       [  0, -48, -97],\n       [ 50, -88, -44]])\n\n\nDie Funktion column_stack erzeugt auch aus eindimensionalen Arrays ein zweidimensionales Array, indem die Arrays als Spalten zusammengefügt werden:\n\nnp.column_stack((a, b))\n\narray([[ 95, -74, -24,   0, -48, -97],\n       [-20,  80, -60,  50, -88, -44]])\n\n\nIn diesem Fall ist das Ergebnis dasselbe wie bei hstack, da a und b bereits zweidimensional sind. Bei eindimensionalen Arrays gibt es aber einen Unterschied:\n\nc = rng.integers(low=-100, high=100, size=5)\nc\n\narray([ -1,  -3, -77,  96,  49])\n\n\n\nd = rng.integers(low=-100, high=100, size=5)\nd\n\narray([ 92, -82,  44, -42,   8])\n\n\n\nc.shape\n\n(5,)\n\n\n\nd.shape\n\n(5,)\n\n\n\nnp.hstack((c, d))\n\narray([ -1,  -3, -77,  96,  49,  92, -82,  44, -42,   8])\n\n\n\nnp.column_stack((c, d))\n\narray([[ -1,  92],\n       [ -3, -82],\n       [-77,  44],\n       [ 96, -42],\n       [ 49,   8]])\n\n\n\nnp.vstack((c, d))\n\narray([[ -1,  -3, -77,  96,  49],\n       [ 92, -82,  44, -42,   8]])"
  },
  {
    "objectID": "09/09.html#übungen",
    "href": "09/09.html#übungen",
    "title": "9 – Numerische Daten",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nErstellen Sie ein eindimensionales Array mit den Zahlen von 0 (inklusive) bis 10 (exklusive) in Schritten von 0.1. Weisen Sie diesem Array den Namen t zu. Wie viele Elemente hat das Array? Wie lautet die Form (Shape) des Arrays?\n\n\nÜbung 2\nErstellen Sie aus dem Array t aus Übung 1 ein zweidimensionales Array s, welches die gleichen Elemente beinhaltet, jedoch aus 20 Zeilen (und der entsprechenden Anzahl an Spalten) besteht.\n\n\nÜbung 3\nErstellen Sie ein zweidimensionales Array u der Form (100, 8), welches aus zufälligen Ganzzahlen im Bereich [−1000, 1000) besteht (d.h. −1000 ist dabei, 1000 nicht). Setzen Sie vorher den Seed des Generators auf 18. Berechnen Sie dann folgende Größen von u:\n\nSumme aller Elemente\nMittelwert aller Elemente\nZeilenmittelwerte\nSpaltenmittelwerte\nMaxima und Minima jeder Spalte\nMaxima und Minima jeder Zeile\nMaximum der Zeilenmittelwerte\n\n\n\nÜbung 4\nErstellen Sie ein dreidimensionales Array x der Form (3, 10, 5), welches die Zahlen von 1 bis 150 enthält. Wie lauten die drei Mittelwerte, wenn Sie über die letzten beiden Dimensionen mitteln?\n\n\n\n\n\n\nHinweis\n\n\n\nDas Array x kann man sich als 3 Tabellen à 10 Zeilen und 5 Spalten vorstellen. Der Mittelwert aller Elemente von x[0, :, :] ist der erste gesuchte Mittelwert, jener von x[1, :, :] der zweite, und der Mittelwert von x[2, :, :] ist der dritte gesuchte Wert. Sie können so die drei Mittelwerte berechnen, oder kürzer wenn Sie das axis-Argument von np.mean auf ein Tupel setzen, welches die Achsen beschreibt, über die Sie mitteln möchten (also die Achsen 1 und 2, da Python bei 0 zu zählen beginnt).\n\n\n\n\nÜbung 5\nErstellen Sie ein (8, 8)-Array namens chess mit einem Schachbrettmuster (verwenden Sie dafür die Werte 0 und 1). Es gibt viele mögliche Lösungen, gerne können Sie auch mehrere Varianten anführen. Sehen Sie sich z.B. die Hilfe zur Funktion np.tile an, oder erzeugen Sie zuerst ein Array aus lauter Nullen und fügen Sie dann an den entsprechenden Stellen Einsen ein (z.B. durch entsprechendes Indizieren oder mit for-Schleifen)."
  },
  {
    "objectID": "02/02-solutions.html",
    "href": "02/02-solutions.html",
    "title": "2 – Lösungen",
    "section": "",
    "text": "Eine Liste aller installierten Pakete erhält man, wenn man folgenden Befehl in einem Terminal eingibt:\npip list\nIn einer frischen Python-Installation sind nur wenige Pakete installiert. Die Ausgabe könnte folgendermaßen aussehen:\nPackage Version\n------- -------\npip     25.2"
  },
  {
    "objectID": "02/02-solutions.html#übung-1",
    "href": "02/02-solutions.html#übung-1",
    "title": "2 – Lösungen",
    "section": "",
    "text": "Eine Liste aller installierten Pakete erhält man, wenn man folgenden Befehl in einem Terminal eingibt:\npip list\nIn einer frischen Python-Installation sind nur wenige Pakete installiert. Die Ausgabe könnte folgendermaßen aussehen:\nPackage Version\n------- -------\npip     25.2"
  },
  {
    "objectID": "02/02-solutions.html#übung-2",
    "href": "02/02-solutions.html#übung-2",
    "title": "2 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\nZunächst überprüft man, ob es Updates für installierte Pakete gibt:\npip list --outdated\nWenn hier keine Ausgabe erscheint, sind alle Pakete auf dem neuesten Stand. Bei mir ist das der Fall, aber falls Pakete aktualisiert werden können, kann man jedes Paket einzeln mit folgendem Befehl aktualisieren (&lt;package&gt; ist durch den tatsächlichen Paketnamen zu ersetzen):\npip install --upgrade &lt;package&gt;\nWir überprüfen nun, ob das Paket ipython installiert ist:\npip list\nHier taucht es nicht in der Liste auf, also installiert man es mit folgendem Befehl:\npip install ipython\nAnalog dazu macht man das auch für das Paket numpy:\npip install numpy\nWenn man ein Paket wieder entfernen möchte, kann man es mit folgendem Befehl deinstallieren:\npip uninstall ipython\n\n\n\n\n\n\nHinweis\n\n\n\nWenn man ein Paket installiert, werden gegebenenfalls automatisch weitere Pakete installiert, die von dem Paket benötigt werden (sogenannte Abhängigkeiten). Beispielsweise benötigt das Paket ipython einige weitere Pakete, darunter backcall, decorator, jedi und so weiter. Diese Abhängigkeiten werden automatisch mit pip install ipython installiert.\nAllerdings werden Abhängigkeiten bei der Deinstallation eines Pakets (z.B. pip uninstall ipython) nicht automatisch entfernt, da sie möglicherweise noch von anderen Paketen benötigt werden. Man muss sie daher manuell entfernen oder einfach installiert lassen (da sie normalerweise nicht stören)."
  },
  {
    "objectID": "02/02-solutions.html#übung-3",
    "href": "02/02-solutions.html#übung-3",
    "title": "2 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\nDas Skript sollte folgendermaßen aussehen:\n# Clemens Brunner\n\nprint(\"Hello World!\")"
  },
  {
    "objectID": "02/02-solutions.html#übung-4",
    "href": "02/02-solutions.html#übung-4",
    "title": "2 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\nhelp(print)\nhelp(sum)"
  },
  {
    "objectID": "12/12.html",
    "href": "12/12.html",
    "title": "12 – PsychoPy (2)",
    "section": "",
    "text": "In dieser Einheit werden wir uns mit dem Python-Code beschäftigen, welcher jedem PsychoPy-Experiment zugrunde liegt. Selbst wenn ein Experiment mit der grafischen Oberfläche Builder erstellt wurde, wird dieses vor dem Ausführen zuerst in ein Python-Script konvertiert. Erst dieses Script wird dann tatsächlich von Python ausgeführt. Selbstverständlich kann man aber auch direkt ein Python-Script erstellen, um PsychoPy zu verwenden – dies führt in den meisten Fällen zu wesentlich kompakterem Code. Als einfachen Code-Editor für PsychoPy-Scripts verwendet man am besten PsychoPy Coder."
  },
  {
    "objectID": "12/12.html#psychopy-coder",
    "href": "12/12.html#psychopy-coder",
    "title": "12 – PsychoPy (2)",
    "section": "",
    "text": "In dieser Einheit werden wir uns mit dem Python-Code beschäftigen, welcher jedem PsychoPy-Experiment zugrunde liegt. Selbst wenn ein Experiment mit der grafischen Oberfläche Builder erstellt wurde, wird dieses vor dem Ausführen zuerst in ein Python-Script konvertiert. Erst dieses Script wird dann tatsächlich von Python ausgeführt. Selbstverständlich kann man aber auch direkt ein Python-Script erstellen, um PsychoPy zu verwenden – dies führt in den meisten Fällen zu wesentlich kompakterem Code. Als einfachen Code-Editor für PsychoPy-Scripts verwendet man am besten PsychoPy Coder."
  },
  {
    "objectID": "12/12.html#der-code-des-stroop-experiments",
    "href": "12/12.html#der-code-des-stroop-experiments",
    "title": "12 – PsychoPy (2)",
    "section": "Der Code des Stroop-Experiments",
    "text": "Der Code des Stroop-Experiments\nWenn man in PsychoPy Builder ein Experiment grafisch erstellt hat, kann man sich den zugehörigen Code mit Tools – Compile (bzw. durch Klicken auf das Icon “Compile to Python script”) erzeugen lassen. PsychoPy Coder wird dann automatisch mit dem generierten Script geöffnet.\n\n\n\n\n\n\nTipp\n\n\n\nProbieren wir das mit unserem Stroop-Experiment aus der letzten Einheit aus. Wir vereinfachen dieses Experiment aber, indem wir die Routine “Feedback” entfernen (Rechtsklick auf die Routine und “remove” auswählen). Auch das entsprechende Tab können wir schließen und aus dem Experiment entfernen.\nMit einem Klick auf das Icon “Compile to Python script” wird das Experiment dann in ein Python-Script konvertiert. Dieses wird auch gleich mit PsychoPy Coder geöffnet.\nDas erstellte Script ist für ein so einfaches Experiment mit fast 500 Zeilen relativ lang. Es enthält viel Code, der für das Experiment eigentlich gar nicht notwendig ist, wie z.B. viele import-Statements die im weiteren Script nicht verwendet werden. Wir werden uns dieses Script nicht genauer ansehen, sondern versuchen herauszufinden, wie einfachere Komponenten direkt mit Code geschrieben werden können."
  },
  {
    "objectID": "12/12.html#minimales-experiment",
    "href": "12/12.html#minimales-experiment",
    "title": "12 – PsychoPy (2)",
    "section": "Minimales Experiment",
    "text": "Minimales Experiment\nEin minimales PsychoPy-Experiment besteht aus fünf Zeilen Code. Es erzeugt ein leeres Fenster, welches für zwei Sekunden sichtbar ist.\nfrom psychopy import core, visual\n\nwin = visual.Window(size=[800, 400])\ncore.wait(2)\nwin.close()\ncore.quit()\nObwohl dieses Experiment nichts tut, kann man die grundlegende Struktur erkennen:\nZu Beginn importiert man alle nötigen Module aus dem psychopy-Paket. Die PsychoPy-Dokumentation enthält eine detaillierte Beschreibung aller vorhandenen Module, wir benötigen hier aber nur die Module core (Basisfunktionen) und visual (visuelle Stimuli).\nDanach erstellen wir das Programmfenster, in dem das Experiment läuft. Dazu rufen wir visual.Window auf, welches uns ein Programmfenster der angegebenen Größe erzeugt und zurückgibt (wir nennen dieses Fenster win).\nAb jetzt könnte man alle Stimuli erzeugen, die im Verlauf des Experimentes benötigt werden. Wir werden dies in einem weiteren Beispiel sehen, dieses Experiment enthält aber keine Stimuli. Es wird mit core.wait(2) lediglich zwei Sekunden gewartet. Danach ist das Experiment zu Ende, und die beiden letzten Zeilen schließen das Programmfenster und beenden das Experiment.\n\n\n\n\n\n\nHinweis\n\n\n\nDas Script kann durch Klicken auf das Icon “Run experiment” ausgeführt werden."
  },
  {
    "objectID": "12/12.html#darstellen-von-stimuli-am-bildschirm",
    "href": "12/12.html#darstellen-von-stimuli-am-bildschirm",
    "title": "12 – PsychoPy (2)",
    "section": "Darstellen von Stimuli am Bildschirm",
    "text": "Darstellen von Stimuli am Bildschirm\nIn einem richtigen Experiment verwendet man natürlich diverse Stimuli. Im Folgenden werden wir einige visuelle Stimuli näher betrachten. PsychoPy kann mit den im Modul visual enthaltenen Funktionen eine große Anzahl an unterschiedlichsten visuellen Stimuli erzeugen, wie beispielsweise Text, Formen (Kreise, Rechtecke, Linien), Bilddateien, Muster, usw.\nDie Darstellung von visuellen Stimuli am Bildschirm funktioniert wie folgt:\n\nZunächst wird das Fenster win erzeugt. Darin können später alle Stimuli gezeichnet werden.\nAnschließend kann ein Stimulus-Objekt stim erzeugt werden, welches dem Fenster zugeordnet wird. Beim Erzeugen des Stimulus kann man das Aussehen wie z.B. die Farbe, die Position, die Orientierung, etc. festlegen. Alle Eigenschaften eines Stimulus können aber auch nachträglich im Verlauf des Experimentes geändert werden.\nSchließlich wird der Stimulus stim mit der Methode stim.draw() gezeichnet. Das Zeichnen erfolgt aber zunächst unsichtbar im sogenannten Backbuffer – man kann sich diesen Buffer wie die Rückseite des Bildschirms vorstellen. Alles was gezeichnet wird, landet zuerst einmal im Backbuffer und ist somit noch nicht sichtbar.\nWenn alle gewünschten Stimuli im Backbuffer gezeichnet sind, kann der gesamte Inhalt des Backbuffers mit win.flip() sichtbar gemacht werden. Dies bedeutet, dass der Inhalt des unsichtbaren Backbuffers in den sichtbaren Frontbuffer übertragen wird – der Backbuffer wird dadurch wieder geleert. Diese Operation ist mit der Bildwiederholfrequenz synchronisiert, d.h. bei einem Bildschirm mit 60 Hz wird das Bild 60 Mal pro Sekunde neu gezeichnet. Ein Aufruf von win.flip() wird dann bei der nächsten Bildschirm-Aktualisierung durchgeführt.\n\nDer Vorteil dieser Aufteilung in Backbuffer und Frontbuffer ist, dass alle Stimuli im Backbuffer exakt gleichzeitig sichtbar werden, und zwar genau dann, wenn man win.flip() aufruft. Würden die Stimuli direkt nach dem Zeichnen sichtbar werden, könnte es vorkommen, dass die verschiedenen Komponenten in einem Bild zu leicht unterschiedlichen Zeiten gezeichnet werden.\nUnser minimales Experiment können wir nun also mit einem Text-Stimulus wie folgt erweitern:\nfrom psychopy import core, visual\n\nwin = visual.Window(size=[800, 400])\ntext = visual.TextStim(win, \"Text\\n\\n2 Sekunden sichtbar.\")\ntext.draw()  # in den Backbuffer zeichnen (noch unsichtbar)\nwin.flip()  # sichtbar machen\ncore.wait(2)\nwin.close()\ncore.quit()"
  },
  {
    "objectID": "12/12.html#warten-auf-einen-tastendruck",
    "href": "12/12.html#warten-auf-einen-tastendruck",
    "title": "12 – PsychoPy (2)",
    "section": "Warten auf einen Tastendruck",
    "text": "Warten auf einen Tastendruck\nWir können nun schon fast einen Instruktionsbildschirm anzeigen – es fehlt nur mehr die Möglichkeit, die Instruktionen so lange anzuzeigen, bis die Versuchsperson eine bestimmte Taste (z.B. die Leertaste) drückt. Das PsychoPy-Modul event beinhaltet diverse Funktionen, um Benutzereingaben (wie z.B. von der Tastatur) abzufragen. Mit der Funktion event.waitKeys() kann man so lange warten, bis eine Taste gedrückt wird. Insbesondere kann man mit dem keyList-Argument die erlaubten Tasten als Liste angeben. Unser Beispiel kann damit wie folgt erweitert werden:\nfrom psychopy import core, visual, event\n\nwin = visual.Window(fullscr=True)\ns = \"\"\"Text Rotation\n\nPress 'left' to rotate the text to the left.\nPress 'right' to rotate the text to the right.\n\nPress Space to start!\n\"\"\"\ntext = visual.TextStim(win=win, text=s, color=\"white\", height=0.05)\ntext.draw()\nwin.flip()\nevent.waitKeys(keyList=[\"space\"])\nwin.close()\ncore.quit()\nDurch die Angabe von keyList=[\"space\"] wird also so lange gewartet, bis die Leertaste gedrückt wird. Erst dann wird das Script in der nächsten Zeile fortgesetzt.\n\n\n\n\n\n\nHinweis\n\n\n\nDie Verwendung von event.waitKeys (und event.getKeys) ist eigentlich nicht mehr empfohlen, da diese Funktionen nicht mehr gewartet werden und z.B. unter Linux auch gar nicht mehr funktionieren. Stattdessen sollte man auf hardware.keyboard.Keyboard zurückgreifen, welches wir aber hier nicht weiter behandeln, da diese Methode leider etwas komplexer ist. Zumindest im Moment sollte aber alles noch unter Windows funktionieren."
  },
  {
    "objectID": "12/12.html#verwenden-einer-schleife",
    "href": "12/12.html#verwenden-einer-schleife",
    "title": "12 – PsychoPy (2)",
    "section": "Verwenden einer Schleife",
    "text": "Verwenden einer Schleife\nWir versuchen jetzt, das im vorigen Beispiel beschriebene Experiment umzusetzen. Nach dem Instruktionsbildschirm soll ein Text (nämlich PsychoPy) am Bildschirm angezeigt werden. Wenn man die linke Pfeiltaste drückt, soll der Text nach links rotieren. Drückt man die linke Taste wiederholt, wird die Rotation schneller. Drückt man die rechte Pfeiltaste, verlangsamt die Rotation nach links und man kann den Text dann nach rechts rotieren lassen. Wenn die Leertaste gedrückt wird, soll das Experiment beendet werden.\nfrom psychopy import core, visual, event\n\nwin = visual.Window(fullscr=False)\ns = \"\"\"Text Rotation\n\nPress 'left' to rotate the text to the left.\nPress 'right' to rotate the text to the right.\n\nPress Space to start!\n\"\"\"\ntext = visual.TextStim(win=win, text=s, color=\"white\", height=0.05)\ntext.draw()\nwin.flip()\nevent.waitKeys(keyList=[\"space\"])\n\ntext.setText(\"PsychoPy\")\ntext.setHeight(0.15)\n\nrotation = 0\nspeed = 0\n\nwhile True:\n    keys = event.getKeys(keyList=[\"space\", \"left\", \"right\"])\n    if keys:  # eine Taste wurde gedrückt\n        if keys[0] == \"space\":  # exit\n            break\n        elif keys[0] == \"left\":\n            speed -= 1\n        else:\n            speed += 1\n    rotation += speed\n    text.setOri(rotation)\n    text.draw()\n    win.flip()\n\nwin.close()\ncore.quit()\nEin neuer Bestandteil in diesem Experiment ist die Tatsache, dass wir unseren existierenden Text-Stimulus text wiederverwenden. Beim Initialisieren zeigen wir zunächst die Instruktionen damit an, danach setzen wir aber den Text mit text.setText(\"PsychoPy\") sowie die Größe mit text.setHeight(0.15) auf andere Werte. Diese Operation ist oft schneller als das Erzeugen eines neuen Text-Stimulus und sollte deswegen in den meisten Fällen bevorzugt werden.\nDanach folgt eine Endlosschleife while True. Man erkennt aber schon, dass diese Schleife mit break auch verlassen werden kann, und zwar wenn die Leertaste gedrückt wird.\nDie erste Anweisung innerhalb der Schleife gibt eine Liste der gedrückten Tasten zurück. Allerdings werden durch das keyList-Argument nur die angegebenen Tasten berücksichtigt (alle anderen Tasten werden ignoriert). Wenn keine Taste gedrückt wurde, ist keys eine leere Liste. Mit if keys: überprüft man daher, ob die Liste keys Einträge enthält oder nicht (wenn die Liste Einträge enthält, wurde eine Taste gedrückt und der ist Ausdruck True; wenn die Liste leer ist, wurde keine Taste gedrückt und der Ausdruck ist False).\nWenn die gedrückte Taste (diese entspricht dem ersten Element in der Liste, also keys[0]) die linke Pfeiltaste ist, wird die Rotationsgeschwindigkeit speed (anfänglich auf 0 gesetzt) um den Wert 1 verringert. Wenn die gedrückte Taste die rechte Pfeiltaste ist, wird speed um den Wert 1 erhöht. Die Rotation rotation des Textes wird nun durch Addition des aktuellen Wertes von rotation und der Rotationsgeschwindigkeit speed bestimmt. Danach wird der Text mit text.setOri(rotation) auf den Winkel rotation gedreht. Jetzt kann der Text-Stimulus gezeichnet werden, und anschließend wird der Inhalt des Buffers mit win.flip() angezeigt. Sobald die Leertaste gedrückt wird, wird die Schleife verlassen, und die letzten beiden Zeilen des Scripts werden ausgeführt.\n\n\n\n\n\n\nTipp\n\n\n\nDie Schreibweise x += 1 erhöht den Wert von x um 1. Man könnte auch x = x + 1 schreiben.\n\n\nDurch den Befehl win.flip() werden die aktuellen Stimuli mit der Bildwiederholfrequenz gezeichnet. In den meisten Fällen ist dies 60 Hz, d.h. die while-Schleife wird 60 mal pro Sekunde durchlaufen."
  },
  {
    "objectID": "12/12.html#animierte-stimuli",
    "href": "12/12.html#animierte-stimuli",
    "title": "12 – PsychoPy (2)",
    "section": "Animierte Stimuli",
    "text": "Animierte Stimuli\nIm vorigen Beispiel haben wir gesehen, wie wir die Orientierung eines Text-Stimulus mit text.setOri(rotation) in einer Schleife kontinuierlich verändern können. Dasselbe Prinzip können wir auf beliebige visuelle Stimuli übertragen, um diese zu animieren.\nDas folgende Beispiel zeigt, wie man einen Kreis bewegt und gleichzeitig dessen Farbe ändert (siehe dazu die PsychoPy-Hilfe über Farben).\nfrom psychopy import core, visual, event\n\nwin = visual.Window(size=[800, 800])\n\npos = [0, 0]  # initial x, y position\nspeed = [0.03, -0.02]  # initial x, y speed\ncolors = [\"red\", \"yellow\", \"green\"]\ncolor = 0\ncircle = visual.Circle(win, radius=0.1, fillColor=colors[0], lineColor=None)\n\nwhile True:\n    keys = event.getKeys(keyList=[\"escape\"])\n    if keys:\n        break\n    pos[0] += speed[0]\n    pos[1] += speed[1]\n    if pos[0] &lt; -1 or pos[0] &gt; 1:  # is the x position on the screen border?\n        speed[0] = -speed[0]  # flip x speed direction\n        color = (color + 1) % 3  # set next color\n    if pos[1] &lt; -1 or pos[1] &gt; 1:  # is the y position on the screen border?\n        speed[1] = -speed[1]  # flip y speed direction\n        color = (color + 1) % 3  # set next color\n    circle.setPos(pos)\n    circle.setFillColor(colors[color])\n    circle.draw()\n    win.flip()\n\nwin.close()\ncore.quit()"
  },
  {
    "objectID": "12/12.html#timer",
    "href": "12/12.html#timer",
    "title": "12 – PsychoPy (2)",
    "section": "Timer",
    "text": "Timer\nIn den meisten Experimenten ist es wichtig, Stimuli zu definierten Zeitpunkten anzuzeigen. Wir haben bereits eine Möglichkeit kennengelernt, wie man in PsychoPy eine bestimmte Zeit warten kann: core.wait(2) wartet z.B. exakt zwei Sekunden, bevor die nächste Codezeile ausgeführt wird. Dies hat allerdings den großen Nachteil, dass während der Wartezeit nichts passieren kann, da das gesamte Experiment für diese Zeitdauer blockiert ist.\nIm Gegensatz dazu blockieren sogenannte Timer den Programmablauf nicht. Generell gibt es in PsychoPy zwei verschiedene Arten an Timern:\n\ncore.Clock beinhaltet die seit der Erstellung des Timers vergangene Zeit (in Sekunden), zählt also hinauf.\ncore.CountdownTimer beinhaltet die seit der Erstellung des Timers noch übrige Zeit (in Sekunden), zählt also hinunter.\n\nErsteren Timer erstellt man mit clock = core.Clock(). Mit dieser Zuweisung beginnt der Timer bei Sekunde 0 zu ticken. Mit clock.getTime() kann man dann die seit der Erstellung vergangenen Sekunden bekommen.\nBei der Erstellung eines Countdown-Timers kann man bei der Erstellung die Startzeit (in Sekunden) angeben, von der man herunterzählen möchte, also z.B. timer = core.CountdownTimer(10) zählt von Sekunde 10 herunter. Zu beachten ist, dass die Zeit hier auch negativ werden kann (im Beispiel also wenn mehr als 10 Sekunden vergangen sind). Die aktuell noch übrige Zeit kann auch hier mit timer.getTime() abgefragt werden.\nMan kann in einem Script beliebig viele Timer erstellen. Man kann Timer außerdem jederzeit auf beliebige Werte zurücksetzen. Die beiden vorher erstellten Timer clock und timer kann man mit clock.reset() bzw. timer.reset() auf ihre ursprünglichen Zeiten zurücksetzen. Dies bewirkt, dass clock auf 0 und timer auf 10 gesetzt werden.\nDas folgende Beispiel zeigt, wie man Timer einsetzen kann. Man erkennt, dass die while-Schleifen so lange ausgeführt werden, bis die Werte der Timer Null erreichen. Das bedeutet, dass die Schleife genau so lange dauert, wie bei der Erstellung des Timers (bzw. beim Zurücksetzen) angegeben wird.\nfrom psychopy import core, visual\n\nwin = visual.Window(size=[800, 800])\n\ntext1 = visual.TextStim(win, text=\"\", color=\"blue\")\ntext2 = visual.TextStim(win, text=\"\", color=\"red\")\n\ntimer1 = core.CountdownTimer(3)\ntimer2 = core.CountdownTimer(5)\n\ntimer1.reset()\nwhile timer1.getTime() &gt; 0:\n    text1.setText(\"{:.2f}\".format(timer1.getTime()))\n    text1.draw()\n    win.flip()\ntimer2.reset()\nwhile timer2.getTime() &gt; 0:\n    text2.setText(\"{:.2f}\".format(timer2.getTime()))\n    text2.draw()\n    win.flip()\n\nwin.close()\ncore.quit()"
  },
  {
    "objectID": "12/12.html#stroop-als-script",
    "href": "12/12.html#stroop-als-script",
    "title": "12 – PsychoPy (2)",
    "section": "Stroop als Script",
    "text": "Stroop als Script\nDies führt uns zum Schluss wieder zum Stroop-Experiment, welches wir nun in nur 43 Zeilen selbst schreiben können. Es fehlt zwar die Abspeicherung der Daten wie z.B. Reaktionszeiten, dies würde aber nur wenige zusätzliche Zeilen in Anspruch nehmen. Im Vergleich mit den über 450 Zeilen des automatisch generierten Codes ist die selbst erstellte Variante aber wesentlich übersichtlicher (und dadurch vermutlich auch einfacher zu verstehen).\nfrom psychopy import core, visual, event, data\n\n\nwin = visual.Window(fullscr=True)  # Vollbildmodus\n\ns = \"\"\"Simple Stroop\n\nName the color of the word on the screen.\nDo not read the word!\n\nIf the word is red, press 'r'.\nIf the word is blue, press 'b'.\nIf the word is green, press 'g'.\n\nPress Space when you are ready.\n\"\"\"\ntext = visual.TextStim(win=win, text=s, color=\"white\", height=0.05)\ntext.draw()\nwin.flip()\nevent.waitKeys(keyList=[\"space\"])\n\nconditions = data.importConditions(\"conditions.xlsx\")\ntrials = data.TrialHandler(trialList=conditions, nReps=5)\ntimer = core.CountdownTimer()\ntext.setHeight(0.1)\n\nfor trial in trials:\n    timer.reset(2)\n    text.setText(trial[\"word\"])\n    text.setColor(trial[\"color\"])\n    while timer.getTime() &gt; 0:\n        if timer.getTime() &gt; 1:\n            text.draw()\n        keys = event.getKeys(keyList=[\"r\", \"g\", \"b\", \"escape\"])\n        win.flip()\n        if keys:\n            rt = 2 - timer.getTime()\n            if keys[0] == \"escape\":\n                core.quit()\n            break\n\nwin.close()\ncore.quit()\nNeu an diesem Script ist die Möglichkeit, mit data.TrialHandler automatisch Trials aus der Datei conditions.xlsx zu erzeugen. Über das Ergebnis dieses Befehls kann dann iteriert werden (was den einzelnen Trials entspricht)."
  },
  {
    "objectID": "12/12.html#weitere-literatur",
    "href": "12/12.html#weitere-literatur",
    "title": "12 – PsychoPy (2)",
    "section": "Weitere Literatur",
    "text": "Weitere Literatur\nPsychoPy Coder beinhaltet im Menüpunkt Demos viele Beispiel-Scripts, welche als Vorlage für eigene Experimente bzw. Lernmaterialien verwendet werden können. Die PsychoPy-Website bietet ein kurzes Tutorial über PsychoPy Coder, in welchem mittels Code ein einfaches Experiment erstellt wird."
  },
  {
    "objectID": "12/12.html#übungen",
    "href": "12/12.html#übungen",
    "title": "12 – PsychoPy (2)",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nErzeugen Sie mit PsychoPy folgendes Experiment direkt als Script (d.h. verwenden Sie PsychoPy Coder):\nIm Experiment sollen drei verschiedene visuelle Stimuli (z.B. Kreis, Polygon, Text, Bild) gleichzeitig animiert werden. Innerhalb einer Schleife, welche so lange laufen soll, bis die Escape-Taste gedrückt wird, soll von jedem der drei Stimuli zumindest eine Eigenschaft (wie z.B. Position, Größe, Farbe, Orientierung) kontinuierlich verändert werden. Alle drei Stimuli sollen gleichzeitig innerhalb der Schleife verändert werden."
  },
  {
    "objectID": "04/04.html",
    "href": "04/04.html",
    "title": "4 – Funktionen",
    "section": "",
    "text": "Funktionen kann man sich wie “Mini-Programme” bzw. “Mini-Scripts” vorstellen. Sie gruppieren mehrere Anweisungen zu einem zusammengehörigen Block. Eine Funktion in Python ist durchaus mit einer mathematischen Funktion vergleichbar, wie zum Beispiel der Quadratfunktion \\(f(x) = x^2\\). Diese mathematische Funktion \\(f\\) berechnet aus einem gegebenen Wert \\(x\\) einen neuen Wert \\(x^2\\). Diese Funktion kann man dann mit konkreten Werten für \\(x\\) verwenden, um die entsprechenden Ergebnisse zu erhalten, z.B. \\(f(3) = 9\\) oder \\(f(5) = 25\\).\nAuch in Python hat eine Funktion eine klar definierte Aufgabe. Hier dienen Funktionen unter anderem dazu, Programmcode zu strukturieren (was die Lesbarkeit erhöht) und wiederverwendbar zu machen (wiederverwendbar bedeutet, dass man eine Funktion beliebig oft verwenden kann). Funktionen machen Programme in der Regel auch kürzer, weil wiederholt auszuführender Code in Funktionen ausgelagert werden kann. Sollten einmal Änderungen notwendig sein, muss man diese nur an einer Stelle innerhalb der Funktion vornehmen. Funktionen lassen sich außerdem auch in anderen Programmen wiederverwenden.\n\n\n\n\n\n\nHinweis\n\n\n\nEinige Funktionen wie print und type haben wir bereits in den vorigen Einheiten kennengelernt und verwendet."
  },
  {
    "objectID": "04/04.html#allgemeines",
    "href": "04/04.html#allgemeines",
    "title": "4 – Funktionen",
    "section": "",
    "text": "Funktionen kann man sich wie “Mini-Programme” bzw. “Mini-Scripts” vorstellen. Sie gruppieren mehrere Anweisungen zu einem zusammengehörigen Block. Eine Funktion in Python ist durchaus mit einer mathematischen Funktion vergleichbar, wie zum Beispiel der Quadratfunktion \\(f(x) = x^2\\). Diese mathematische Funktion \\(f\\) berechnet aus einem gegebenen Wert \\(x\\) einen neuen Wert \\(x^2\\). Diese Funktion kann man dann mit konkreten Werten für \\(x\\) verwenden, um die entsprechenden Ergebnisse zu erhalten, z.B. \\(f(3) = 9\\) oder \\(f(5) = 25\\).\nAuch in Python hat eine Funktion eine klar definierte Aufgabe. Hier dienen Funktionen unter anderem dazu, Programmcode zu strukturieren (was die Lesbarkeit erhöht) und wiederverwendbar zu machen (wiederverwendbar bedeutet, dass man eine Funktion beliebig oft verwenden kann). Funktionen machen Programme in der Regel auch kürzer, weil wiederholt auszuführender Code in Funktionen ausgelagert werden kann. Sollten einmal Änderungen notwendig sein, muss man diese nur an einer Stelle innerhalb der Funktion vornehmen. Funktionen lassen sich außerdem auch in anderen Programmen wiederverwenden.\n\n\n\n\n\n\nHinweis\n\n\n\nEinige Funktionen wie print und type haben wir bereits in den vorigen Einheiten kennengelernt und verwendet."
  },
  {
    "objectID": "04/04.html#funktionen-aufrufen",
    "href": "04/04.html#funktionen-aufrufen",
    "title": "4 – Funktionen",
    "section": "Funktionen aufrufen",
    "text": "Funktionen aufrufen\nEine Funktion aufrufen bedeutet, dass der in ihr enthaltene Code (also das “Mini-Programm”) ausgeführt wird – die Funktion verrichtet also ihre Arbeit.\nIn Python ruft man eine Funktion mit ihrem Namen gefolgt von einem Paar runder Klammern auf. Innerhalb der Klammern werden die Argumente für die Funktion übergeben (falls notwendig). Mit Argumenten übergibt man der Funktion Werte, welche diese für die Ausführung benötigt. Beispielsweise benötigt die Funktion type ein Argument, denn sonst kann sie ihre Aufgabe nicht erfüllen – nämlich den Typ des übergebenen Arguments zu bestimmen. Gleichermaßen braucht auch die Funktion math.sqrt aus dem math-Modul ein Argument, damit diese die Wurzel der übergebenen Zahl berechnen kann.\nHier sind drei Beispiele für Aufrufe von bereits bekannten Funktionen mit jeweils einem Argument:\n\nprint(\"Hello\")\n\nHello\n\n\n\ntype(\"Hello\")\n\nstr\n\n\n\nimport math\nmath.sqrt(16)\n\n4.0\n\n\nEs gibt aber auch Funktionen, die man ohne Argument aufrufen kann (der folgende Funktionsaufruf bewirkt eine Ausgabe einer Leerzeile am Bildschirm):\n\nprint()\n\n\n\n\nWie viele Argumente eine Funktion tatsächlich benötigt, hängt ganz alleine von der jeweiligen Funktion ab (dies ist in ihrer Dokumentation nachzulesen).\n\n\n\n\n\n\nWichtig\n\n\n\nLässt man die Klammern weg, wird die Funktion nicht aufgerufen – es wird dann lediglich der Wert des Namens (also das Funktionsobjekt) angezeigt, wenn man Python im interaktiven Modus verwendet.\n\nprint\n\n&lt;function print(*args, sep=' ', end='\\n', file=None, flush=False)&gt;\n\n\nDabei handelt es sich um einen Namen, welcher auf ein Funktionsobjekt verweist:\n\ntype(print)\n\nbuiltin_function_or_method\n\n\nDas Konzept von Namen in Python haben wir bereits in der letzten Einheit kennengelernt. Es ist unerheblich, auf welches Objekt ein Name verweist, dies kann eine Ganzzahl, eine Funktion, oder jedes beliebige andere Objekt sein. So können wir z.B. auch den Namen f erstellen, welcher auf die Funktion print verweist:\n\nf = print\n\nNun hat die Funktion zwei Namen, nämlich print und f:\n\nf(\"Hello via f\")\n\nHello via f"
  },
  {
    "objectID": "04/04.html#funktionen-definieren",
    "href": "04/04.html#funktionen-definieren",
    "title": "4 – Funktionen",
    "section": "Funktionen definieren",
    "text": "Funktionen definieren\nWir sind glücklicherweise nicht auf bereits existierende Funktionen beschränkt, sondern können selbst unsere eigenen Funktionen schreiben. In Python wird eine Funktion wie folgt definiert (die Zeilen in spitzen Klammern sind Platzhalter und müssen durch konkrete Befehle ersetzt werden):\ndef function_name(parameter1, parameter2, ...):\n    &lt;do something&gt;\n    &lt;...&gt;\n    &lt;optionally return something&gt;\nEine Funktionsdefinition beginnt immer mit dem Schlüsselwort def. Danach folgt der (frei wählbare) Funktionsname (aber auch hier muss man sich an die Regeln für gültige Namen halten). Die PEP8-Konvention empfiehlt außerdem, dass Funktionsnamen keine Großbuchstaben enthalten sollten. Falls der Name aus mehreren Wörtern bestehen soll, sollten Unterstrichen zur Trennung verwendet werden, z.B.:\ndef test_function\nNach dem Funktionsnamen folgt ein Paar runder Klammern. Innerhalb dieser können von der Funktion benötigte Parameter aufgelistet werden (mehrere Parameter werden durch Kommas voneinander getrennt). Parameter sind Platzhalter, welche beim Ausführen der Funktion mit spezifischen Werten ersetzt werden. Diese spezifischen Werte (auch Argumente genannt) werden beim Aufruf übergeben. Es gibt aber auch Funktionen, die keine Parameter haben – die beiden runden Klammern müssen aber trotzdem immer vorhanden sein:\ndef test_function()  # ohne Parameter\nFalls eine Funktion zwei Parameter haben soll, würde man dies wie folgt anschreiben:\ndef test_function(n, v)  # zwei Parameter namens n und v\nUnabhängig von der Anzahl der Parameter schließt ein Doppelpunkt den sogenannten Funktionskopf ab:\ndef test_function(n, v):\nNun folgt der Code, welcher von der Funktion ausgeführt wird, wenn diese aufgerufen wird – dieser Code muss um eine Ebene eingerückt werden (also normalerweise vier Leerzeichen). Man spricht hier vom sogenannten Funktionskörper. Im Funktionskörper kann man insbesondere alle Parameter wie normale Namen verwenden – diese sind nur innerhalb der Funktion vorhanden und erhalten dann die konkreten Werte der Argumente, welche beim Funktionsaufruf übergeben wurden.\n\n\n\n\n\n\nWichtig\n\n\n\nEine Funktion kann Parameter haben, welche bei der Definition aufgelistet werden müssen. Wenn man die Funktion aufruft, muss man für alle Parameter konkrete Werte übergeben – diese konkreten Werte nennt man Argumente.\n\n\nDas folgende Beispiel definiert eine Funktion namens test_function, welche aus zwei Zeilen Code im Funktionskörper besteht:\n\ndef test_function():\n    s = \"Hello world!\"\n    print(s)\n\nMan beachte, dass die Funktion hier lediglich definiert wurde, d.h. sie wurde noch nicht ausgeführt. Sie ist aber dem Python-Interpreter ab jetzt bekannt (d.h. es existiert ein Name test_function, welcher auf ein Funktionsobjekt verweist):\n\ntest_function\n\n&lt;function __main__.test_function()&gt;\n\n\n\ntype(test_function)\n\nfunction\n\n\nAufgerufen kann unsere Funktion nun wie folgt werden (die runden Klammern sind essentiell):\n\ntest_function()\n\nHello world!\n\n\nWir können eine bereits definierte Funktion beliebig oft aufrufen.\n\ntest_function()\n\nHello world!\n\n\nIm Fall einer Funktion mit Parametern würden die Definition und der Aufruf z.B. so aussehen (wir haben den verwendeten if-Befehl noch nicht besprochen, es ist aber nicht wichtig, dass Sie verstehen, was diese Funktion genau macht):\n\ndef test_function_2(n, v):  # Definition, zwei Parameter\n    if v:\n        print(n)\n\n\ntest_function_2(\"Hello world!\", True)  # Aufruf mit zwei konkreten Argumenten\n\nHello world!\n\n\n\ntest_function_2(\"Hi!\", False)  # weiterer Aufruf mit anderen Argumenten\n\nÜbergibt man beim Aufruf dieser Funktion nicht genau die erwartete Anzahl an Argumenten, bekommt man einen Fehler:\n\ntest_function_2()  # zwei Argumente erwartet, aber keine übergeben!\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[17], line 1\n----&gt; 1 test_function_2()  # zwei Argumente erwartet, aber keine übergeben!\n\nTypeError: test_function_2() missing 2 required positional arguments: 'n' and 'v'\n\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nAlle in der Funktionsdefinition definierten Parameter müssen beim Aufrufen der Funktion mit konkreten Argumenten befüllt werden!\n\n\n\n\n\n\n\n\nTipp\n\n\n\nEs ist üblich, gleich in der ersten Zeile des Funktionskörpers eine kurze Beschreibung der Funktion in einem sogenannten Docstring anzugeben (dieser kann sich auch über mehr als eine Zeile erstrecken). Ein Docstring wird von jeweils drei Anführungszeichen \"\"\" umschlossen. Das Vorhandensein eines Docstrings ändert nichts an der Funktionsweise, dient aber der Dokumentation und gehört zum guten Coding-Stil dazu, wie folgendes Beispiel demonstriert:\n\ndef test_function():\n    \"\"\"Print hello world.\"\"\"\n    s = \"Hello world!\"\n    print(s)\n\nEin solcher Docstring ist übrigens kein Kommentar! Verwenden Sie für Kommentare also weiterhin das #-Zeichen!"
  },
  {
    "objectID": "04/04.html#rückgabewerte",
    "href": "04/04.html#rückgabewerte",
    "title": "4 – Funktionen",
    "section": "Rückgabewerte",
    "text": "Rückgabewerte\nFunktionen können Werte (Ergebnisse) zurückgeben. In beiden soeben definierten Funktionen test_function und test_function_2 wird allerdings kein Wert explizit zurückgegeben (d.h. die Funktionen führen nur Code aus und geben implizit None zurück, der spezielle Wert für “nichts” in Python). Diese beiden Funktionen können also nicht auf einen Wert reduziert werden, wenn man sie aufruft – sie sind also keine Ausdrücke.\nWenn eine Funktion explizit einen Wert (ein Ergebnis) zurückgeben soll, verwendet man dazu das Schlüsselwort return, gefolgt vom gewünschten Rückgabewert:\n\ndef add_one(number):\n    \"\"\"Increment a given number by one.\"\"\"\n    return number + 1\n\nBeim Aufrufen der Funktion wird ihr Code im Funktionskörper ausgeführt, bis die Zeile mit return erreicht wird. Diese bewirkt, dass die Funktion sofort verlassen und der angegebene Wert number + 1 zurückgegeben wird (hier wird für number natürlich der als Argument übergebene konkrete Wert verwendet). Sollten also nach dem return-Befehl noch weitere Zeilen Code im Funktionskörper folgen, werden diese nicht mehr ausgeführt.\n\nadd_one(5)\n\n6\n\n\nEin Funktionsaufruf wird also immer auf seinen Rückgabewert reduziert. Ein Aufruf einer Funktion, die einen Wert zurückgibt, ist also ein Ausdruck. Nun könnte man diesem auch einen Namen geben:\n\nx = add_one(9)\n\n\nx\n\n10\n\n\nMan kann den Wert einer Funktion (also den Rückgabewert) auch explizit mit Hilfe der print-Funktion am Bildschirm ausgeben:\n\nprint(add_one(122))\n\n123\n\n\n\n\n\n\n\n\nTipp\n\n\n\nMan kann überall dort, wo man einen Wert angeben kann, auch einen Ausdruck (eine beliebige Kombination aus Werten und Operatoren) einsetzen – eben auch einen Funktionsaufruf, der einen Wert zurückgibt. Dies wird als Komposition bezeichnet. Die Werte werden der Reihe nach (von innen nach außen) verarbeitet und eingesetzt, bis zum Schluss ein einziger Wert übrig bleibt:\n\nadd_one(add_one(add_one(1)))\n\n4"
  },
  {
    "objectID": "04/04.html#argumente",
    "href": "04/04.html#argumente",
    "title": "4 – Funktionen",
    "section": "Argumente",
    "text": "Argumente\n\nStandard-Argumente\nEine Funktion kann keine Parameter haben oder eine bestimmte Anzahl an Parametern erwarten. Wenn eine bestimmte Anzahl an Parametern im Funktionskopf definiert wird, können einzelnen Parametern Standardwerte (sogenannte Standard- oder auch Default-Argumente) zugewiesen werden. Dies bedeutet, dass die Funktion auch mit weniger Argumenten als erwartet aufgerufen werden kann, wenn für die fehlenden Argumente Standardwerte existieren.\n\ndef add(number, increment=1):  # das Standard-Argument für increment ist 1\n    return number + increment\n\nDiese Funktion kann jetzt mit zwei Argumenten oder nur mit dem ersten Argument aufgerufen werden:\n\nadd(7, 1)\n\n8\n\n\n\nadd(7)  # hier wird das Standard-Argument 1 für increment verwendet\n\n8\n\n\n\nadd(7, 3)\n\n10\n\n\n\n\nSchlüsselwort-Argumente\nFunktionen können auch so aufgerufen werden, dass die Namen der Parameter gemeinsam mit den Argumenten in der Form kwarg=value explizit hingeschrieben werden. Man spricht dann von Schlüsselwort-Argumenten (englisch “Keyword Arguments”) (nicht zu verwechseln mit den Python-Schlüsselwörtern). D.h. die obige Funktion add kann auch so aufgerufen werden:\n\nadd(number=5)\n\n6\n\n\n\nadd(number=5, increment=2)\n\n7\n\n\n\nadd(increment=2, number=5)\n\n7\n\n\nDies dient einerseits der besseren Lesbarkeit, da unmittelbar klar ist, welche Parameter welche konkreten Argumente erhalten. Andererseits kann man so die Argumente auch in beliebiger Reihenfolge übergeben.\nWenn der Argumentname nicht angegeben wird, wird die Position des Arguments bei der Zuweisung herangezogen. Man spricht in diesem Fall von positionalen Argumenten. Man kann positionale und Schlüsselwort-Argumente beim Funktionsaufruf auch mischen, aber alle positionalen Argumente müssen vor dem ersten Schlüsselwort-Argument kommen.\n\nadd(5, increment=2)\n\n7\n\n\nZur Veranschaulichung dient folgende Funktionsdefinition:\n\ndef test(name, number, exponent=5, skip=7, text=\"Hello\"):\n    print(text, name, end=\" \")\n    return number**exponent - skip\n\nDie folgenden drei Funktionsaufrufe verwenden nur positionale Argumente:\n\ntest(\"Python\", 2)\n\nHello Python \n\n\n25\n\n\n\ntest(\"Python\", 3)\n\nHello Python \n\n\n236\n\n\n\ntest(\"Test\", 3, 4)\n\nHello Test \n\n\n74\n\n\nSchlüsselwort-Argumente sind sehr praktisch, wenn man für viele Parameter deren Standard-Argumente verwenden möchte, aber z.B. für einen einzigen Parameter einen anderen Wert setzen will. Dann muss man nämlich nicht alle Argumente der Reihe nach übergeben, sondern nur jene, für die man andere Werte als die Standardwerte haben möchte:\n\ntest(\"Test\", 2, skip=2)\n\nHello Test \n\n\n30\n\n\nOhne Schlüsselwort-Argumente würde derselbe Aufruf nämlich wie folgt aussehen:\n\ntest(\"Test\", 2, 5, 2)\n\nHello Test \n\n\n30\n\n\nMan muss also in diesem Beispiel ein zusätzliches Argument 5 (für den Parameter exponent) übergeben, wenn man positionale Argumente verwendet, obwohl man ja ohnehin den Standardwert dieses Arguments verwendet.\n\n\n\n\n\n\nHinweis\n\n\n\nIn Python gibt es auch Funktionen, die eine beliebige/variable Anzahl an Parametern besitzen. Dies bedeutet, dass bei der Funktionsdefinition festgelegt wird, dass eine beliebige Anzahl an Argumenten übergeben werden kann. Die print-Funktion ist ein Beispiel für eine solche Funktion: diese kann man mit keinem, einem, zwei, oder beliebig vielen Argumenten aufrufen:\n\nprint()\nprint(\"Hello\")\nprint(\"Hello\", \"Python\")\nprint(\"Hello\", \"Python\", 1, 2, 3, 4)\n\n\nHello\nHello Python\nHello Python 1 2 3 4\n\n\nWir werden solche Funktionen nicht im Detail besprechen (vor allem nicht, wie man diese selbst definieren kann), aber wir werden solche Funktionen mitunter verwenden (aufrufen)."
  },
  {
    "objectID": "04/04.html#gültigkeitsbereiche",
    "href": "04/04.html#gültigkeitsbereiche",
    "title": "4 – Funktionen",
    "section": "Gültigkeitsbereiche",
    "text": "Gültigkeitsbereiche\nAlles, was innerhalb einer Funktion (im Funktionskörper) definiert wird, ist nur innerhalb dieser Funktion sichtbar und zugreifbar. Man spricht von einem lokalen Gültigkeitsbereich (englisch “Scope”), welcher sich auf die Funktion und eventuelle weitere in ihr vorhandene untergeordnete Bereiche erstreckt. Gültigkeitsbereiche entsprechen in Python im Prinzip den Einrückungen.\nIm folgenden Beispiel wird innerhalb der Funktion test der Name s = 15 definiert. Dieser kann innerhalb der Funktion verwendet werden.\n\ndef test():\n    s = 15  # s ist nur lokal in der Funktion definiert\n    print(s)\n\ntest()\n\n15\n\n\nAußerhalb dieser Funktion existiert dieses s aber nicht:\n\nprint(s)  # außerhalb der Funktion existiert s nicht\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[41], line 1\n----&gt; 1 print(s)  # außerhalb der Funktion existiert s nicht\n\nNameError: name 's' is not defined\n\n\n\nUmgekehrt kann man aber sehr wohl auf Namen, die außerhalb (bzw. oberhalb) eines Gültigkeitsbereichs definiert wurden, zugreifen:\n\ns = 15  # \"globales\" s\n\ndef test():\n    print(s)  # s aus dem globalen Scope ist zugänglich\n\ntest()\nprint(s)  # s existiert global\n\n15\n15\n\n\nWenn man innerhalb einer Funktion einen neuen Namen erstellt, welcher auch außerhalb existiert, dann ist nur der neue lokale Name zugänglich und der Name von außerhalb wird innerhalb der Funktion versteckt (englisch “shadowed”). Im folgenden Beispiel verweisen die beiden Namen s auf unterschiedliche Objekte:\n\ns = 15  # globales s\n\ndef test():\n    s = 12  # lokales s ändert globales s nicht, versteckt es aber in der Funktion\n    print(s)\n\ntest()\nprint(s)\n\n12\n15\n\n\nBesonders seltsam mutet folgendes Beispiel an, welches eine Fehlermeldung verursacht:\n\ns = 15  # globales s\n\ndef test():\n    print(s)  # lokales s existiert noch nicht - daher Fehler!\n    s = 12  # lokales s\n    print(s)\n\ntest()\nprint(s)\n\n\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\nCell In[44], line 8\n      5     s = 12  # lokales s\n      6     print(s)\n----&gt; 8 test()\n      9 print(s)\n\nCell In[44], line 4, in test()\n      3 def test():\n----&gt; 4     print(s)  # lokales s existiert noch nicht - daher Fehler!\n      5     s = 12  # lokales s\n      6     print(s)\n\nUnboundLocalError: cannot access local variable 's' where it is not associated with a value\n\n\n\nDie Zeile print(s) in der Funktion verursacht einen Fehler, weil Python aufgrund der folgenden Zeile bereits weiß, dass s ein lokaler Name sein wird. Daher kann print(s) auch nicht funktionieren, weil s in der ersten Zeile noch nicht existiert! Hier mischt Python also nicht zwischen globalen und lokalen Namen.\nMöchte man aber tatsächlich den global definierten Namen verwenden, kann man dies mit dem Schlüsselwort global tun:\n\ns = 15  # globales s\n\ndef test():\n    global s  # Ermöglicht Zugriff auf das globale s\n    print(s)\n    s = 12  # ändert globales s\n    print(s)\n\ntest()\nprint(s)\n\n15\n12\n12\n\n\nPrinzipiell sollte man die Deklaration global aber vermeiden und globale/lokale Scopes sauber voneinander trennen. Will man auf ein Objekt aus einem äußeren Scope zugreifen, definiert man am besten einen Parameter, damit man das gewünschte Objekt als Argument an die Funktion übergeben kann:\n\ns = 15  # globales s\n\ndef test(s):  # Parameter s\n    print(s)  # lokales s (übergebenes Argument)\n    s = 12\n    print(s)\n\nprint(s)\ntest(s)\nprint(s)\n\n15\n15\n12\n15\n\n\nWill man eine lokale Variable in einem äußeren Scope weiter nutzen, gibt man den entsprechenden Wert am besten mit return zurück:\n\ns = 15  # globales s\n\ndef test(s):\n    print(s)  # lokales s (Argument)\n    s = 12\n    print(s)\n    return s\n\nprint(s)\ns = test(s)  # globales s bekommt Rückgabewert der Funktion (lokales s)\nprint(s)\n\n15\n15\n12\n12\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDas hier beschriebene Verhalten gilt auch für Parameter. Diese verhalten sich wie lokal innerhalb der Funktion definierte Namen und erhalten automatisch die Werte, die mit den entsprechenden Argumenten beim Aufruf übergeben wurden. In den letzten beiden Beispielen hatten die Funktionen jeweils einen Parameter namens s. Zufälligerweise wurden die Funktionen auch mit einem Argument namens s aufgerufen – dabei handelt es sich aber um zwei unterschiedliche Namen bzw. Objekte. Man könnte die Funktion genauso gut auch direkt mit einem Wert oder mit einem beliebigen anderen Namen aufrufen:\n\nx = 15\ntest(x)  # Parameter s erhält den Wert x = 15\n\n15\n12\n\n\n12\n\n\nDies sieht man insbesondere dann, wenn man Schlüsselwort-Argumente verwendet:\n\ntest(s=x)\n\n15\n12\n\n\n12"
  },
  {
    "objectID": "04/04.html#übungen",
    "href": "04/04.html#übungen",
    "title": "4 – Funktionen",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nSuchen Sie sich aus der Liste der eingebauten Funktionen (siehe vorige Einheit) drei beliebige Funktionen aus.\n\nRufen Sie den Hilfetext zu jeder Funktion auf und lesen Sie diesen durch, um herauszufinden was die Funktion tut.\nRufen Sie die drei Funktionen mit geeigneten Argumenten auf.\nGeben Sie für jede Funktion an, ob diese einen Wert zurückgibt oder nicht. Falls ein Wert zurückgegeben wird, geben Sie diesen Wert sowie dessen Typ an!\n\n\n\nÜbung 2\nSchreiben Sie eine Funktion mult, welche zwei Zahlen multipliziert und deren Produkt zurückgibt. Die beiden Zahlen sollen als Argumente übergeben werden können. Rufen Sie Ihre Funktion mit ein paar Wertepaaren auf und stellen Sie sicher, dass Ihre Funktion wie gewünscht funktioniert. Die Funktion soll das Ergebnis als Wert zurückgeben, d.h. verwenden Sie innerhalb der Funktion nicht print, sondern return!\n\n\nÜbung 3\nSchreiben Sie eine Funktion to_fahrenheit, welche einen Parameter celsius hat und diese Celsius-Temperatur in Fahrenheit umwandelt und zurückgibt. Zum Testen rufen Sie Ihre Funktion mit den Celsius-Temperaturen 0, 20, 38 und 100 auf.\nSchreiben Sie außerdem eine Funktion to_celsius (mit entsprechendem Parameter fahrenheit) und wandeln Sie die vier Fahrenheit-Temperaturen, die Sie vorher beim Aufruf der Funktion to_fahrenheit erhalten haben, wieder in Celsius-Temperaturen um!\n\n\nÜbung 4\nNennen Sie Gründe, warum man Funktionen verwendet. Erklären Sie auch kurz den Unterschied zwischen Funktionsdefinition und Funktionsaufruf! Was ist der Unterschied zwischen Parametern und Argumenten?\n\n\nÜbung 5\nSchreiben Sie eine Funktion namens nonsense, welche drei Parameter namens a, b und c hat. Die beiden Argumente b und c sollen optional sein und die Standardwerte 10 bzw. 13 besitzen. Die Funktion soll a**2 - b * 2 + c**2 berechnen und zurückgeben (wir setzen voraus, dass man für a, b und c immer Zahlenwerte übergibt). Rufen Sie die Funktion dann mit folgenden Argumenten auf:\n\nOhne Argumente\nMit drei positionalen Argumenten\nMit zwei positionalen Argumenten\nMit einem Keyword-Argument\nMit zwei Keyword-Argumenten\nMit zwei positionalen Argumenten und einem Keyword-Argument\nMit einem positionalem und einem Keyword-Argument\n\nWie sehen diese Funktionsaufrufe aus? Wie lauten die Rückgabewerte? Geben Sie für jeden Aufruf die Werte aller drei Argumente an!\n\n\n\n\n\n\nHinweis\n\n\n\nNur der erste Funktionsaufruf (ohne Argumente) verursacht einen Fehler, alle weiteren Aufrufe sind möglich!"
  },
  {
    "objectID": "06/06.html",
    "href": "06/06.html",
    "title": "6 – Strings",
    "section": "",
    "text": "Datentypen in Python können grob in folgende Kategorien unterteilt werden:\n\nLogischer Datentyp (bool)\nNumerische Datentypen (int, float)\nSequenzen (können aus mehreren Elementen bestehen) (str, list, tuple)\nMappings (Wertepaare) (dict)\n\nMit der Funktion type kann man den Typ eines beliebigen Objektes bestimmen. Der logische und die numerischen Datentypen sind im Prinzip relativ einfach aufgebaut, und wir haben bereits gesehen, wie wir diese Typen verwenden können. In den folgenden beiden Einheiten werden etwas komplexere Typen vorgestellt, welche in Python sehr häufig verwendet werden: die Sequenzdatentypen str, list und tuple sowie der Mapping-Datentyp dict.\nBevor wir diese Typen im Detail besprechen, sehen wir uns aber eine grundlegende Eigenschaft von Datentypen in Python an."
  },
  {
    "objectID": "06/06.html#wiederholung",
    "href": "06/06.html#wiederholung",
    "title": "6 – Strings",
    "section": "",
    "text": "Datentypen in Python können grob in folgende Kategorien unterteilt werden:\n\nLogischer Datentyp (bool)\nNumerische Datentypen (int, float)\nSequenzen (können aus mehreren Elementen bestehen) (str, list, tuple)\nMappings (Wertepaare) (dict)\n\nMit der Funktion type kann man den Typ eines beliebigen Objektes bestimmen. Der logische und die numerischen Datentypen sind im Prinzip relativ einfach aufgebaut, und wir haben bereits gesehen, wie wir diese Typen verwenden können. In den folgenden beiden Einheiten werden etwas komplexere Typen vorgestellt, welche in Python sehr häufig verwendet werden: die Sequenzdatentypen str, list und tuple sowie der Mapping-Datentyp dict.\nBevor wir diese Typen im Detail besprechen, sehen wir uns aber eine grundlegende Eigenschaft von Datentypen in Python an."
  },
  {
    "objectID": "06/06.html#mutable-und-immutable",
    "href": "06/06.html#mutable-und-immutable",
    "title": "6 – Strings",
    "section": "Mutable und immutable",
    "text": "Mutable und immutable\nIn Python unterscheidet man zwei Arten an Typen:\n\nMutable (veränderbar)\nImmutable (nicht veränderbar)\n\nObjekte eines mutable Typs können auch nach deren Erstellung verändert werden. Im Gegensatz dazu können Objekte eines immutable Typs nach deren Erstellung nicht mehr verändert werden.\nIn dieser Lehrveranstaltung werden wir nur die folgenden zwei veränderbaren Typen genauer betrachten:\n\nListe list\nDictionary dict\n\nFür uns relevante nicht veränderbare Typen sind:\n\nGanzzahl int, Kommazahl float\nString str, Tuple tuple\n\n\nImmutable Typen\nBefassen wir uns zunächst mit den nicht veränderbaren (immutable) Typen. Als Beispiel betrachten wir das Objekt 2 vom Typ int. Dieses Objekt ist nicht veränderbar. Im folgenden Beispiel wird das Objekt 2, welches den Namen a hat, tatsächlich auch nicht verändert. Wenn man nämlich a = 3 setzt, ändert man lediglich den Namen a – dieser verweist dann auf das Objekt 3 (ein anderes Objekt, denken Sie an die Analogie mit dem Namensschildchen).\nDies kann man auch mit Hilfe der id-Funktion verifizieren; man erkennt, dass die IDs (also die Objekte) tatsächlich unterschiedlich sind.\n\na = 2\n\n\nid(a)\n\n140325151877520\n\n\n\na = 3  # Name a verweist jetzt auf das Objekt 3\n\n\nid(a)  # andere ID als vorher\n\n140325151877552\n\n\nAuch Strings sind immutable. Wenn man versucht, einen einmal angelegten String zu verändern (z.B. ein Zeichen zu ändern), bekommt man eine Fehlermeldung:\n\ns = \"Python\"\n\n\ns[1]  # das 2. Zeichen des Strings (Python beginnt mit 0 zu zählen)\n\n'y'\n\n\n\ns[1] = \"x\"  # kann nicht verändert werden, da Strings immutable sind\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[7], line 1\n----&gt; 1 s[1] = \"x\"  # kann nicht verändert werden, da Strings immutable sind\n\nTypeError: 'str' object does not support item assignment\n\n\n\nAnalog zu Strings sind auch Tuples immutable. Ein Tuple ist eine Sammlung (Sequenz) von verschiedenen Objekten, ähnlich wie eine Liste:\n\nt = 1, 2, 18.33, \"Python\", 44\n\n\nt[0]  # Element 0 des Tuples\n\n1\n\n\n\nt[3]  # Element 3 des Tuples\n\n'Python'\n\n\n\nt[0] = \"X\"  # kann nicht verändert werden, da Tuples immutable sind\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[11], line 1\n----&gt; 1 t[0] = \"X\"  # kann nicht verändert werden, da Tuples immutable sind\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\n\nMutable Typen\nIm Gegensatz zu den oben erwähnten Beispielen kann man Objekte eines mutable Typs sehr wohl nach der Erstellung verändern. Eine Liste ist genau wie ein Tuple eine Sammlung von verschiedenen Objekten. Man kann eine Liste aber auch nachträglich ändern:\n\nk = [1, 2, 18.33, \"Python\", 44]  # Liste\n\n\nk\n\n[1, 2, 18.33, 'Python', 44]\n\n\n\nk[0]  # erstes Element\n\n1\n\n\n\nk[3]\n\n'Python'\n\n\n\nk[0] = \"X\"  # Änderung möglich!\n\n\nk\n\n['X', 2, 18.33, 'Python', 44]\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nEine Liste wird, im Gegensatz zu einem Tuple, erstellt, indem man die Elemente mit eckigen Klammern [ bzw. ] umschließt.\n\n\nAuch Dictionaries sind mutable:\n\nd = {\"a\": 12, \"b\": 3.14, 5: \"Python\", \"c\": \"yes\"}\n\n\nd\n\n{'a': 12, 'b': 3.14, 5: 'Python', 'c': 'yes'}\n\n\n\nd[\"a\"]\n\n12\n\n\n\nd[\"a\"] = \"CHANGED\"  # Änderung möglich\n\n\nd\n\n{'a': 'CHANGED', 'b': 3.14, 5: 'Python', 'c': 'yes'}\n\n\nMehr Details zu den Datentypen list, tuple und dict folgen in der nächsten Einheit. Wir widmen uns jetzt dem nicht veränderbaren Datentyp String."
  },
  {
    "objectID": "06/06.html#strings",
    "href": "06/06.html#strings",
    "title": "6 – Strings",
    "section": "Strings",
    "text": "Strings\n\nStrings erstellen\nDer Datentyp str ist ein Sequenzdatentyp und stellt Zeichenketten (Strings) dar. Ein String besteht daher aus einer Sequenz an Zeichen (Buchstaben, Zahlen, Sonderzeichen). Strings werden von einfachen oder doppelten Anführungszeichen umschlossen (aber der Inhalt eines Strings selbst besteht nur aus den Zeichen zwischen diesen Anführungszeichen).\n\ns1 = \"String\"\ns1\n\n'String'\n\n\n\ns2 = 'Dies ist ebenfalls ein String.'\ns2\n\n'Dies ist ebenfalls ein String.'\n\n\n\ns3 = 'Auch \"das\" ist ein String'\ns3\n\n'Auch \"das\" ist ein String'\n\n\n\ns4 = \"And that's a string too!\"\ns4\n\n\"And that's a string too!\"\n\n\nLange Strings, die sich auch über mehrere Zeilen erstrecken können, kann man mit drei Anführungszeichen umschließen (Zeilenumbrüche sind dabei möglich und Teil des Strings).\n\ns5 = \"\"\"Dies ist ein sehr langer Text.\nMan kann einfach\nin die nächste Zeile gehen.\n\"\"\"\n\n\nprint(s5)  # der Inhalt des Strings wird formatiert ausgegeben\n\nDies ist ein sehr langer Text.\nMan kann einfach\nin die nächste Zeile gehen.\n\n\n\n\ns5  # tatsächlicher Wert des Strings, \\n steht für Zeilenumbruch\n\n'Dies ist ein sehr langer Text.\\nMan kann einfach\\nin die nächste Zeile gehen.\\n'\n\n\nStrings mit drei Anführungszeichen haben wir schon als Docstrings zur kurzen Beschreibung von Funktionen kennengelernt.\n\n\n\n\n\n\nTipp\n\n\n\nMöchte man einen String erzeugen, der sowohl \" als auch ' enthält, kann man weder das eine noch das andere Zeichen direkt verwenden. Man muss daher das Anführungszeichen, welches für die Definition des Strings verwendet wurde und auch im String vorkommen soll, mit einem vorangestellten \\ schreiben (man spricht hier von einer Escape-Sequenz):\n\nx = \"Dieser String \\\"enthält\\\" doppelte und 'einfache' Anführungszeichen.\"\ny = 'Dieser String \"enthält\" doppelte und \\'einfache\\' Anführungszeichen.'\n\nDie beiden Strings x und y sind identisch:\n\nx == y\n\nTrue\n\n\nDie print-Funktion stellt Escape-Sequenzen aber “richtig” formatiert dar:\n\nprint(x)\n\nDieser String \"enthält\" doppelte und 'einfache' Anführungszeichen.\n\n\nAuch nicht druckbare Zeichen kann man mit Escape-Sequenzen darstellen, wie z.B. einen Zeilenumbruch \\n oder einen Tabulator \\t. Ein Backslash \\ muss ebenfalls als Escape-Sequenz \\\\ geschrieben werden.\n\n\n\n\nStrings indizieren\nBei Sequenzdatentypen kann man auf einzelne Elemente durch Indizieren zugreifen. Den Index (also die Position des gewünschten Zeichens) gibt man dabei nach dem Objekt in eckigen Klammern an.\n\n\n\n\n\n\nWichtig\n\n\n\nPython beginnt mit 0 zu zählen, d.h. das erste Element hat den Index 0. Den Index kann man daher als Unterschied/Abstand zum ersten Element interpretieren.\n\n\n\ns = \"String\"\ns\n\n'String'\n\n\n\ns[0]  # erstes Zeichen\n\n'S'\n\n\n\ns[1]  # zweites Zeichen\n\n't'\n\n\nMit negativen Indizes kann man Elemente von hinten nach vorne ansprechen, d.h. −1 ist das letzte Element, −2 das vorletzte, usw.\n\ns[-1]  # letztes Zeichen\n\n'g'\n\n\n\ns[-2]  # vorletztes Zeichen\n\n'n'\n\n\n\n\nStrings slicen\nMan kann auch mehrere Elemente auf einmal herausgreifen. Dazu schreibt man in die eckigen Klammern den Startindex, einen Doppelpunkt, und den Endindex.\n\n\n\n\n\n\nWichtig\n\n\n\nDer Endindex zählt nicht mehr zum Bereich dazu!\n\n\nWenn man auf diese Art (also unter Verwendung des Doppelpunkts) mehrere Elemente herausgreift, spricht man von einem Slice.\n\n\n\n\n\n\nHinweis\n\n\n\nGibt man den ersten Index nicht an, wird vom ersten Element (inklusive) gezählt. Gibt man den Endindex nicht an, wird bis zum letzten Element (inklusive) gezählt.\n\n\n\ns\n\n'String'\n\n\n\ns[0:4]  # 4 Elemente, Index 0, 1, 2, 3, gleichwertig mit s1[:4]\n\n'Stri'\n\n\n\ns[4:6]  # 2 Elemente, Index 4, 5\n\n'ng'\n\n\n\ns[:3]  # 3 Elemente, Index 0, 1, 2\n\n'Str'\n\n\n\ns[2:]  # Index 2 bis zum letzten Element\n\n'ring'\n\n\n\ns[2:-1]  # Index 2 bis zum letzten Element (exklusive)\n\n'rin'\n\n\n\ns[1:-3]  # Index 1 bis zum drittletzten Element (exklusive)\n\n'tr'\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDie Tatsache, dass der Startindex immer inklusive ist und der Endindex immer exklusive ist, hat den Vorteil, dass man sich durch die Differenz der beiden Indizes sofort die Anzahl der Elemente im Slice ausrechnen kann. Beispielsweise erkennt man so, dass x[73:81] genau \\(81 - 73 = 8\\) Elemente enthält.\n\n\nAngrenzende Slices kann man intuitiv erstellen, z.B.:\n\ns[:2]  # die ersten 2 Zeichen\n\n'St'\n\n\n\ns[2:]  # die restlichen Zeichen\n\n'ring'\n\n\nMan kann optional nach dem Endindex noch einen weiteren Doppelpunkt gefolgt von der Schrittweite angeben (standardmäßig ist diese Schrittweite 1). So kann man z.B. jedes zweite Element herausgreifen:\n\ns[::2]\n\n'Srn'\n\n\nWenn man die Reihenfolge der Elemente umdrehen möchte, gibt man als Schrittweite −1 an.\n\ns[4:1:-1]\n\n'nir'\n\n\n\ns[-1:-4:-1]\n\n'gni'\n\n\n\ns[::-1]  # ganzen String umdrehen\n\n'gnirtS'\n\n\nMan kann sich die Indizes als Grenzen zwischen den Elementen vorstellen:\n\n\n\nArbeiten mit Strings\nDie Funktion len gibt die Länge (d.h. die Anzahl der Elemente) einer Sequenz zurück.\n\ns\n\n'String'\n\n\n\nlen(s)\n\n6\n\n\n\nlen(\"Das ist ein relativ langer String\")\n\n33\n\n\nEin String der Länge 0 ist ebenfalls ein regulärer String – er besitzt nur kein Element.\n\ns = \"\"\n\n\ns\n\n''\n\n\n\nlen(s)\n\n0\n\n\n\ntype(s)\n\nstr\n\n\nNachdem Strings immutable sind, kann man sie nachträglich nicht mehr verändern. Man muss stattdessen immer einen neuen String mit den gewünschten Änderungen erstellen:\n\ns = \"Haus\"\n\n\ns[0]\n\n'H'\n\n\n\ns[0] = \"M\"  # funktioniert nicht!\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[60], line 1\n----&gt; 1 s[0] = \"M\"  # funktioniert nicht!\n\nTypeError: 'str' object does not support item assignment\n\n\n\n\n\"M\" + s[1:]  # neuen String erzeugen\n\n'Maus'\n\n\nDas obige Beispiel zeigt, dass man Strings mit dem +-Operator zusammenfügen kann:\n\nx = \"a\" + \"b\" + \"c\"\nx\n\n'abc'\n\n\nDementsprechend kann man einen String mit dem *-Operator vervielfältigen:\n\n\"Hallo\" * 4\n\n'HalloHalloHalloHallo'\n\n\n\n\nString-Methoden\nFür Strings gibt es in Python sehr viele praktische spezielle Funktionen. Diese werden direkt auf ein String-Objekt wie folgt angewandt:\n\nx.upper()\n\n'ABC'\n\n\nZuerst gibt man das String-Objekt an (im Beispiel x), gefolgt von einem Punkt, gefolgt vom Namen der Funktion (im Beispiel upper), die man aufrufen möchte. Eine solche Funktion nennt man auch Methode, da sie direkt auf ein zuvor spezifiziertes Objekt angewendet wird. Im Beispiel oben wird ein neuer String erzeugt, welcher aus den Zeichen des Strings x in Großbuchstaben besteht. Diese Schreibweise hat den Vorteil, dass sofort klar wird, dass die Methode zum Objekt gehört; im Prinzip entspricht der Aufruf aber einem klassischen Funktionsaufruf str.upper(x).\n\n\"abcdefg\".upper()  # Großbuchstaben\n\n'ABCDEFG'\n\n\n\n\"dsKJsdJKJKK\".lower()  # Kleinbuchstaben\n\n'dskjsdjkjkk'\n\n\nEine wichtige Tatsache ist, dass alle String-Methoden einen neuen String zurückgeben. Da Strings immutable sind, können diese von den Methoden ja nicht mehr verändert werden! Dies bedeutet, dass man dem Rückgabewert einen Namen zuweisen muss, wenn man diesen weiterverwenden möchte, also z.B.:\n\nx\n\n'abc'\n\n\n\nx = x.upper()  # Namensschildchen x hängt am neuen String (in Großbuchstaben)\n\n\nx\n\n'ABC'\n\n\n\n\n\n\n\n\nTipp\n\n\n\nIm interaktiven Interpreter kann man einfach herausfinden, welche Methoden man auf ein Objekt anwenden kann. Dazu tippt man den Namen eines Objektes ein, gefolgt von einem Punkt, und dann drückt man die Tabulator-Taste. Es werden dann alle passenden Methoden aufgelistet. Zu jeder Methode kann man sich dann natürlich die interaktive Hilfe anzeigen lassen.\nBeispieleingabe:\nx = \"Test String\"\nx.&lt;TAB&gt;\nAlternativ kann man die Funktion dir verwenden, um alle möglichen Methoden eines Objektes aufzulisten, also z.B.\ndir(x)\n\n\nIm Folgenden werden einige praktische String-Methoden aufgelistet.\nDie Methode strip entfernt Leerzeichen am Anfang und am Ende eines Strings.\n\n\"      Satz mit vielen unnötigen Leerzeichen         \".strip()\n\n'Satz mit vielen unnötigen Leerzeichen'\n\n\nMit split kann man einen String in eine Liste von Strings aufteilen (splitten). Als Argument gibt man das Zeichen an, an dem man splitten will (standardmäßig wird dafür Whitespace, also Leerzeichen und Tabulatoren, verwendet).\n\n\"Viele Sätze. Getrennt mit Punkten. Warum?\".split(\".\")\n\n['Viele Sätze', ' Getrennt mit Punkten', ' Warum?']\n\n\n\n\"Viele Sätze. Getrennt mit Punkten. Warum?\".split()\n\n['Viele', 'Sätze.', 'Getrennt', 'mit', 'Punkten.', 'Warum?']\n\n\nDas “Gegenteil” von split ist join, welches Strings in einer Liste zu einem einzelnen String verbindet. Als Verbindungszeichen wird der angegebene String verwendet.\n\n\";\".join([\"das\", \"ist\", \"ein\", \"Test\"])\n\n'das;ist;ein;Test'\n\n\nWir werden Listen im Detail in der nächsten Einheit kennenlernen. Vorweg aber so viel: die Möglichkeit, Strings in einer Liste mit join zu einem einzigen String zu verbinden ist wesentlich effizienter, als die einzelnen Strings mit + zu verbinden.\nDie Methode count zählt, wie oft das als Argument angegebene Zeichen im String vorkommt:\n\ns = \"Das ist ein kurzer Satz. Nur zum Testen.\"\ns.count(\"i\")\n\n2\n\n\n\ns.count(\"e\")\n\n4\n\n\nDie Methode find gibt den Index im String zurück, an dem das gesuchte Zeichen erstmalig auftritt:\n\ns.find(\"s\")\n\n2\n\n\nOptional kann man auch einen Startindex angeben:\n\ns.find(\"s\", 3)\n\n5\n\n\nMit dem in-Operator kann man abfragen, ob ein bestimmtes Zeichen in einem String enthalten ist:\n\n\"y\" in s\n\nFalse\n\n\n\n\"i\" in s\n\nTrue\n\n\n\n\nStrings iterieren\nEin String ist iterierbar, d.h. man kann mit einer for-Schleife über die einzelnen Elemente iterieren:\n\ns = \"Computer\"\n\nfor c in s:\n    print(c)\n\nC\no\nm\np\nu\nt\ne\nr\n\n\nMöglich wäre auch folgende for-Schleife, wie sie in vielen anderen Programmiersprachen üblich ist:\n\ns = \"Computer\"\n\nfor i in range(len(s)):  # sollte man in Python nicht machen!\n    print(s[i])\n\nC\no\nm\np\nu\nt\ne\nr\n\n\nDies ist aber schlechter lesbar als die direkte Variante, daher sollte man immer direkt über einen String iterieren!\nAlternativ könnte man auch eine while-Schleife verwenden:\n\ns = \"Computer\"\ni = 0\n\nwhile i &lt; len(s):\n    print(s[i])\n    i += 1\n\nC\no\nm\np\nu\nt\ne\nr\n\n\nIm folgenden Beispiel wollen wir herausfinden, an welcher Stelle sich das Zeichen “p” im String “Computer” befindet. Dazu könnten (und sollten) wir die bereits verfügbare String-Methode find verwenden:\n\ns = \"Computer\"\nc = \"p\"  # gesuchtes Zeichen\ns.find(c)\n\n3\n\n\nWir können aber genau dieselbe Funktionalität selbst mit einer Schleife über den String implementieren (aus didaktischen Gründen). Wir gehen so jedes einzelne Zeichen durch. Falls das aktuelle Zeichen s[i] an der Position i gleich dem gesuchten Zeichen c ist, brechen wir die Schleife ab und der Name i enthält die Position des gesuchten Zeichens.\n\ni = 0\nwhile i &lt; len(s):\n    if s[i] == c:\n        break\n    i += 1\n\ni\n\n3"
  },
  {
    "objectID": "06/06.html#übungen",
    "href": "06/06.html#übungen",
    "title": "6 – Strings",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nSchreiben Sie eine Funktion reverse, welche einen String in umgekehrter Reihenfolge zurückgibt.\n\n\nÜbung 2\nGegeben sei folgender String:\ns = \"educational neuroscience\"\nGibt es eine Methode, die aus einem gegebenen String einen neuen String erzeugt, bei dem alle Wörter (nicht Buchstaben!) mit einem Großbuchstaben beginnen? Wenn ja, verwenden Sie diese Methode für s aus diesem Beispiel!\n\n\nÜbung 3\nGegeben sei folgender String:\ns = \"Edukational Neuroscience\"\nDas Zeichen k an der Position 3 soll durch ein c ersetzt werden. Wie können Sie aus s einen neuen String erzeugen, in welcher diese Ersetzung vorgenommen wurde?\n\n\n\n\n\n\nHinweis\n\n\n\nVerwenden Sie Slices, um auf die Teile von s vor dem k bzw. nach dem k zuzugreifen.\n\n\n\n\nÜbung 4\nPalindrome sind Wörter oder Sätze, welche von vorn und hinten gelesen dasselbe ergeben, z.B. Anna, Lagerregal und Reittier. Palindrome können sogar aus mehreren Wörtern bzw. ganzen Sätzen bestehen, wie z.B. “Dr. Awkward” oder “Was it a cat I saw?” (allerdings nur wenn man Groß-/Kleinschreibung sowie Leerzeichen und Satzzeichen ignoriert).\nSchreiben Sie eine Funktion is_palindrome, welche einen String entgegennimmt und True zurückgibt, falls es sich bei dem String um ein Palindrom handelt. Wenn nicht, soll False zurückgegeben werden.\n\n\n\n\n\n\nHinweis\n\n\n\nWandeln Sie den String zuerst in Kleinbuchstaben um, denn sonst wird Anna nicht als Palindrom erkannt, da ein A nicht gleich einem a ist. Ihre Funktion muss außerdem nicht mit Sätzen funktionieren, sondern nur mit einzelnen Wörtern! Falls sie auch mit Sätzen funktionieren soll, müssen Sie alle Leerzeichen ignorieren.\n\n\n\n\nÜbung 5\nDie String-Methode find verwendet man, um in einem String einen anderen String bzw. ein Zeichen zu suchen. Im folgenden Beispiel wird der String \"t\" in s gesucht:\ns = \"Educational Neuroscience\"\ns.find(\"t\")\nDie Position der ersten Fundstelle wird zurückgegeben, in diesem Beispiel also 5. Wird der gesuchte String gar nicht gefunden, wird −1 zurückgegeben.\nSchreiben Sie eine Funktion find(s, sub), welche diese Funktionalität repliziert (ohne aber die Methode find oder andere String-Methoden zu benutzen). Sie können davon ausgehen, dass sub immer nur ein einzelnes Zeichen ist! Ihre Funktion sollte also dasselbe Ergebnis liefern wie im obigen Beispiel s.find(\"t\"); der Aufruf Ihrer Funktion sieht für dieses Beispiel so aus:\nfind(s, \"t\")\n\n\n\n\n\n\nHinweis\n\n\n\nVerwenden Sie am besten eine while-Schleife, um über die einzelnen Buchstaben von s zu iterieren. In der Funktion ist eine Variable hilfreich, welche die aktuelle Position in s mitzählt (beginnend bei 0). Auch die Funktion len, welche die Länge eines Strings zurückgibt, könnte hilfreich sein. Beachten Sie auch, dass return die Funktion sofort verlässt und kein weiterer Code in der Funktion ausgeführt wird, und dass return an einer beliebigen Stelle in der Funktion und auch mehr als ein Mal vorhanden sein kann.\n\n\n\n\nÜbung 6\nSchreiben Sie eine Funktion count(word, letter), welche die Anzahl der Zeichen letter im String word zurückgibt. Verwenden Sie für Ihre Lösung keine fertigen String-Methoden!\nBeispielsweise sollte der Aufruf count(\"Werkstatttreppe\", \"t\") den Wert 4 zurückgeben, analog zur fertigen String-Methode \"Werkstatttreppe\".count(\"t\").\n\n\n\n\n\n\nHinweis\n\n\n\nVerwenden Sie eine ähnliche Struktur wie in Übung 5, eventuell ist hier eine for-Schleife geeigneter. Zählen Sie in einer Variablen mit, wie oft das gesuchte Zeichen aufgetreten ist und geben Sie diesen Wert dann zum Schluss zurück.\n\n\n\n\nÜbung 7\nErstellen Sie einen String namens path mit dem folgenden Inhalt:\nC:\\Program Files\\Python\\Python3.12\\python.exe\nGeben Sie path dann mit Hilfe der print-Funktion am Bildschirm aus."
  },
  {
    "objectID": "05/05.html",
    "href": "05/05.html",
    "title": "5 – Bedingungen und Schleifen",
    "section": "",
    "text": "Komplexe Programme laufen nicht linear ab (also Zeile für Zeile vom Anfang eines Scripts bis zum Ende), sondern beinhalten Verzweigungen und Schleifen. Diese sogenannten Kontrollstrukturen steuern den Programmfluss. Wesentlich dabei sind Vergleiche, die bestimmen, ob bestimmte Codezeilen ausgeführt werden oder nicht bzw. wie oft diese wiederholt werden.\nSchon bei Funktionen haben wir beobachtet, dass Programmcode nicht linear ausgeführt wird, denn erst beim Aufrufen einer Funktion springt Python zu den entsprechenden Zeilen im Funktionskörper und führt diese aus.\n\n\n\n\n\n\nTipp\n\n\n\nMit Hilfe des sogenannten Debuggers können wir ein Script in “Zeitlupe” ausführen. Im Debug-Modus wartet der Python-Interpreter nach jedem Befehl, bis der nächste manuell gestartet wird. Dadurch können wir den Programmfluss beobachten und den Zustand des Programms bei jedem Schritt inspizieren. Dabei geht man wie folgt vor:\n\nIn der IDLE-Shell wählt man Debug – Debugger. Dadurch wird ein neues Werkzeugfenster geöffnet und der Debugger aktiviert. Stellen Sie sicher, dass das Kontrollkästchen “Source” aktiviert ist, um die aktuelle Codezeile zu sehen.\n\nSetzen Sie dann einen Haltepunkt im Python-Skript, indem Sie mit der rechten Maustaste auf die Zeile klicken, an der Sie die Ausführung stoppen möchten und wählen Sie “Set Breakpoint”. Für dieses Beispiel setzen wir einen Haltepunkt gleich in der ersten Zeile (diese wird dann gelb).\n\nFühren Sie jetzt das Skript mit Run – Run Module aus (oder drücken Sie F5). Das Skript wird dann am ersten Haltepunkt gestoppt (und diese Zeile wird noch nicht ausgeführt).\nUm die Ausführung fortzusetzen, wählen Sie “Step”, um die aktuelle Zeile auszuführen und in der nächsten Zeile anzuhalten. Wenn die aktuelle Zeile einen Funktionsaufruf enthält und Sie nicht in die Funktion springen möchten (zum Beispiel, weil Sie nicht daran interessiert sind, den Code einer eingebauten Funktion zu sehen), klicken Sie stattdessen auf “Over”.\nWenn sich die aktuelle Zeile bereits in einer Funktion befindet und Sie diese Funktion sofort verlassen möchten, klicken Sie auf “Out”.\n\nZum Ausprobieren kann man das folgende kurze Script debuggen:\n\ndef f(x):\n    y = x * 2\n    return y\n\na = f(3)\nprint(\"Done.\")\n\nIn welcher Reihenfolge werden die Code-Zeilen ausgeführt?\nAlternativ kann die Website PythonTutor den Programmfluss ebenfalls Schritt für Schritt darstellen. Dazu kopiert man einfach den gesamten Code in das Eingabefeld und klickt auf “Visualize Execution”. So kann man durch wiederholtes Klicken auf “Next” nachvollziehen, wie Python den Code ausführt."
  },
  {
    "objectID": "05/05.html#kontrollstrukturen",
    "href": "05/05.html#kontrollstrukturen",
    "title": "5 – Bedingungen und Schleifen",
    "section": "",
    "text": "Komplexe Programme laufen nicht linear ab (also Zeile für Zeile vom Anfang eines Scripts bis zum Ende), sondern beinhalten Verzweigungen und Schleifen. Diese sogenannten Kontrollstrukturen steuern den Programmfluss. Wesentlich dabei sind Vergleiche, die bestimmen, ob bestimmte Codezeilen ausgeführt werden oder nicht bzw. wie oft diese wiederholt werden.\nSchon bei Funktionen haben wir beobachtet, dass Programmcode nicht linear ausgeführt wird, denn erst beim Aufrufen einer Funktion springt Python zu den entsprechenden Zeilen im Funktionskörper und führt diese aus.\n\n\n\n\n\n\nTipp\n\n\n\nMit Hilfe des sogenannten Debuggers können wir ein Script in “Zeitlupe” ausführen. Im Debug-Modus wartet der Python-Interpreter nach jedem Befehl, bis der nächste manuell gestartet wird. Dadurch können wir den Programmfluss beobachten und den Zustand des Programms bei jedem Schritt inspizieren. Dabei geht man wie folgt vor:\n\nIn der IDLE-Shell wählt man Debug – Debugger. Dadurch wird ein neues Werkzeugfenster geöffnet und der Debugger aktiviert. Stellen Sie sicher, dass das Kontrollkästchen “Source” aktiviert ist, um die aktuelle Codezeile zu sehen.\n\nSetzen Sie dann einen Haltepunkt im Python-Skript, indem Sie mit der rechten Maustaste auf die Zeile klicken, an der Sie die Ausführung stoppen möchten und wählen Sie “Set Breakpoint”. Für dieses Beispiel setzen wir einen Haltepunkt gleich in der ersten Zeile (diese wird dann gelb).\n\nFühren Sie jetzt das Skript mit Run – Run Module aus (oder drücken Sie F5). Das Skript wird dann am ersten Haltepunkt gestoppt (und diese Zeile wird noch nicht ausgeführt).\nUm die Ausführung fortzusetzen, wählen Sie “Step”, um die aktuelle Zeile auszuführen und in der nächsten Zeile anzuhalten. Wenn die aktuelle Zeile einen Funktionsaufruf enthält und Sie nicht in die Funktion springen möchten (zum Beispiel, weil Sie nicht daran interessiert sind, den Code einer eingebauten Funktion zu sehen), klicken Sie stattdessen auf “Over”.\nWenn sich die aktuelle Zeile bereits in einer Funktion befindet und Sie diese Funktion sofort verlassen möchten, klicken Sie auf “Out”.\n\nZum Ausprobieren kann man das folgende kurze Script debuggen:\n\ndef f(x):\n    y = x * 2\n    return y\n\na = f(3)\nprint(\"Done.\")\n\nIn welcher Reihenfolge werden die Code-Zeilen ausgeführt?\nAlternativ kann die Website PythonTutor den Programmfluss ebenfalls Schritt für Schritt darstellen. Dazu kopiert man einfach den gesamten Code in das Eingabefeld und klickt auf “Visualize Execution”. So kann man durch wiederholtes Klicken auf “Next” nachvollziehen, wie Python den Code ausführt."
  },
  {
    "objectID": "05/05.html#vergleiche",
    "href": "05/05.html#vergleiche",
    "title": "5 – Bedingungen und Schleifen",
    "section": "Vergleiche",
    "text": "Vergleiche\nVergleiche sind logische Ausdrücke – ihr Ergebnis ist entweder wahr (True) oder falsch (False). In Python gibt es dafür den Datentyp bool. Folgende Vergleichsoperationen sind möglich:\n\nGleichheit: ==\nUngleichheit: !=\nKleiner: &lt;\nKleiner gleich: &lt;=\nGrößer: &gt;\nGrößer gleich: &gt;=\n\nMan kann mehrere logische Ausdrücke mit den folgenden Operatoren verknüpfen:\n\nUnd-Verknüpfung: and\nOder-Verknüpfung: or\n\nEin Ausdruck kann mit dem Operator not logisch invertiert werden (d.h. aus True wird False und aus False wird True). Weiters gibt es noch folgende Operatoren:\n\nis: Identität (prüft, ob es sich um ein und dasselbe Objekt handelt, nicht nur um gleiche Werte)\nin: Prüft, ob ein Wert in einer Sequenz enthalten ist\n\nWährend == zwei Werte miteinander vergleicht, überprüft is zwei Objekte auf Gleichheit (also ob es sich um ein und dasselbe Objekt handelt). Ein Objekt hat einen Wert, zwei verschiedene Objekte können auch denselben Wert haben. Die Funktion id liefert eine eindeutige Nummer (ID) für ein Objekt zurück – zwei verschiedene Objekte haben immer eine unterschiedliche ID (ansonsten handelt es sich um ein und dasselbe Objekt).\n\nBeispiele\n\nx = 2  # Zuweisung\n\n\nx == 2  # Vergleich\n\nTrue\n\n\n\nx &gt; 2\n\nFalse\n\n\n\nx &lt; 10 and x &gt; 5\n\nFalse\n\n\nDie vorige and-Verknüpfung von zwei Vergleichen kann in Python kürzer dargestellt werden:\n\n5 &lt; x &lt; 10\n\nFalse\n\n\n\nx &lt; 10 or x &gt; 5  # macht das Sinn?\n\nTrue\n\n\n\ny = 2\n\n\nx == y  # Werte vergleichen\n\nTrue\n\n\n\nx is y  # Objekte vergleichen\n\nTrue\n\n\nWir können mit der Funktion id die IDs der Objekte x und y bestimmen:\n\nid(x)\n\n139722176637328\n\n\n\nid(y)\n\n139722176637328\n\n\nMan erkennt, dass beide Objekte x und y dieselbe ID haben. Dies bedeutet, dass das zugrundeliegende Objekt 2 ein und dasselbe Objekt ist und lediglich zwei Namen x und y hat.\n\nDie tatsächlichen IDs von Objekten sind ein Implementierungsdetail von Python, d.h. es ist nicht relevant, welche Zahl hier zurückgegeben wird. Dennoch kann man diese IDs verwenden, um zwei Objekte auf Gleichheit zu überprüfen, denn nur dann haben beide Objekte dieselbe ID.\n\n\n\n\n\n\nHinweis\n\n\n\nEin weiteres Implementierungsdetail von Python ist, dass es kleine Ganzzahlen genau ein Mal gibt – d.h. wenn man zwei oder mehrere Male kleine Zahlen verwenden möchte (wie im vorigen Beispiel mit x = 2 und y = 2), dann wird immer nur ein Objekt verwendet. Dies dient der Beschleunigung bzw. effizienteren Speichernutzung. Bei großen Zahlen ist das allerdings nicht mehr so:\n\na = 500\na\n\n500\n\n\n\nid(a)\n\n139721818706352\n\n\n\nb = a  # b und a sind Namen für dasselbe Objekt\nb\n\n500\n\n\n\nid(b)\n\n139721818706352\n\n\n\nb = 500  # b ist nun ein unterschiedliches Objekt 500\nb\n\n500\n\n\n\nid(b)\n\n139721818709072\n\n\n\na == b  # Werte gleich?\n\nTrue\n\n\n\na is b  # Objekte gleich?\n\nFalse\n\n\n\n\n\nDas folgende Beispiel veranschaulicht, dass es einen Unterschied zwischen Ganzzahlen (int) und Kommazahlen (float) gibt, obwohl deren Werte (zumindest mathematisch) gleich sein können.\n\nc = 12\nd = 12.0\n\n\nc == d\n\nTrue\n\n\n\nc is d\n\nFalse\n\n\nMan sollte Kommazahlen aber ohnehin nie auf Gleichheit überprüfen, da diese aufgrund der begrenzten Genauigkeit nicht exakt repräsentiert werden können. Das folgende Beispiel illustriert diese Eigenschaft von Zahlen des Typs float:\n\n0.1 + 0.1 + 0.1 == 0.3\n\nFalse\n\n\nMöchte man so einen Vergleich durchführen, ist es sinnvoller zu fragen, ob der Unterschied zwischen den beiden Werten einen bestimmten (kleinen) Betrag (z.B. \\(10^{-15}\\)) nicht überschreitet – dann kann man davon ausgehen, dass die Werte numerisch praktisch identisch sind.\n\n(0.1 + 0.1 + 0.1) - 0.3 &lt; 1e-15\n\nTrue\n\n\nDas math-Modul liefert die Funktion isclose mit, welche genau diese Überprüfung durchführt:\n\nimport math\nmath.isclose(0.1 + 0.1 + 0.1, 0.3)\n\nTrue\n\n\n\n\n\n\n\n\nTipp\n\n\n\nIn Python kann man Dezimalzahlen auch in der sogenannten wissenschaftlichen Notation anschreiben. Hier verwendet man eine Darstellung mit Zehnerpotenzen, die man in Python mit e eingeben kann – e kann man als “mal zehn hoch” lesen.\n\n1e0  # 1 mal 10 hoch 0\n\n1.0\n\n\n\n-4e0  # -4 mal 10 hoch 0\n\n-4.0\n\n\n\n1e1  # 1 mal 10 hoch 1\n\n10.0\n\n\n\n3.5e2  # 3.5 mal 10 hoch 2\n\n350.0\n\n\n\n1e-2  # 1 mal 10 hoch -2\n\n0.01\n\n\n\n1e-15  # 1 mal 10 hoch -15 = 0.000000000000001\n\n1e-15"
  },
  {
    "objectID": "05/05.html#bedingungen",
    "href": "05/05.html#bedingungen",
    "title": "5 – Bedingungen und Schleifen",
    "section": "Bedingungen",
    "text": "Bedingungen\nEine Bedingung wird in Python mit den Schlüsselwörtern if, elif und else realisiert. Dabei wird überprüft, ob ein Ausdruck wahr (True) oder falsch (False) ist. Nur falls dieser Ausdruck True ist, wird der nachfolgende eingerückte Codeblock ausgeführt, sonst nicht. Die grundsätzliche Struktur sieht wie folgt aus:\nif &lt;statement is True&gt;:\n    &lt;do something&gt;\n    ...\nelif &lt;statement is True&gt;:  # optional\n    &lt;do something&gt;\n    ...\nelif &lt;statement is True&gt;:  # optional\n    &lt;do something&gt;\n    ...\nelse:  # optional\n    &lt;do something&gt;\n    ...\nDie Struktur einer Bedingung ist also im Prinzip dieselbe wie die einer Funktion. Zuerst gibt es den Kopf, welcher mit dem Keyword if eingeleitet wird. Danach folgt ein logischer Ausdruck (meist ein Vergleich), und zum Schluss wird die Kopfzeile mit einem : abgeschlossen. Der darauf folgende eingerückte Code wird nur ausgeführt, wenn der logische Ausdruck True ergibt – wenn das nicht der Fall ist, wird der gesamte eingerückte Codeblock übersprungen.\nNur wenn der erste Ausdruck True ist, wird also der eingerückte Code ausgeführt. Danach wird der gesamte restliche if/elif/else-Block verlassen, es wird also kein weiterer Code mehr ausgeführt. Wenn der erste Ausdruck False ist, wird der zugehörige Codeblock nicht ausgeführt und es wird zum nächsten elif-Ausdruck gesprungen (falls vorhanden). Hier wird dann ein weiterer logischer Ausdruck ausgewertet, und falls dieser True ist, wird der dazugehörige eingerückte Codeblock ausgeführt. Falls kein logischer Ausdruck in den elif-Zweigen True ist, wird schließlich der Codeblock im else-Zweig ausgeführt (falls vorhanden).\n\n\n\n\n\n\nWichtig\n\n\n\nIn einer Bedingung wird maximal ein Codeblock ausgeführt, nämlich der erste, dessen logischer Ausdruck True ergibt. Deshalb ist auch die Reihenfolge der einzelnen Zweige von Bedeutung.\n\n\n\nBeispiele\nBeginnen wir mit einem einfachen Beispiel, bei dem nur ein if-Zweig vorhanden ist:\n\na = 2\n\nif a &gt; 0:\n    print(\"a is a positive number\")\n    print(\"this is good to know\")\n\na is a positive number\nthis is good to know\n\n\nErgibt der Vergleich a &gt; 0 also False, wird der eingerückte Code nicht ausgeführt:\n\na = -10\n\nif a &gt; 0:\n    print(\"a is a positive number\")\n    print(\"this is good to know\")\n\nMan kann optional einen else-Zweig verwenden, der immer dann ausgeführt wird, wenn alle vorhergehenden Zweige False waren:\n\na = 0\n\nif a &gt; 0:\n    print(\"a is a positive number\")\n    print(\"this is good to know\")\nelse:\n    print(\"a is either 0 or a negative number\")\n\na is either 0 or a negative number\n\n\nSchließlich kann man noch mit elif beliebig viele weitere Zweige einbauen:\n\na = 0\n\nif a &gt; 0:\n    print(\"a is a positive number\")\n    print(\"this is good to know\")\nelif a &lt; 0:\n    print(\"a is a negative number\")\nelse:\n    print(\"a is 0\")\n\na is 0\n\n\nSobald ein Ausdruck in einem if-Block True ist, wird dieser ausgeführt und der gesamte Block wird verlassen. Es werden also keine weiteren Vergleiche mehr durchgeführt.\n\nx = 2\n\nif x == 2:\n    print(\"x is\", x)\nelif x &gt; 0:\n    print(\"x is greater than 0\")\nelif x &lt; 0:\n    print(\"x is negative\")\nelse:\n    print(\"x is 0\")\n\nx is 2\n\n\nDementsprechend ist die Reihenfolge der einzelnen Zweige von Bedeutung:\n\na = 4\n\nif a &gt; 5:\n    print(\"One\")\nelif a &lt; 10:\n    print(\"Two\")\nelif a == 4:\n    print(\"Three\")\nelse:\n    print(\"Four\")\n\nTwo\n\n\n\na = 4\n\nif a &gt; 5:\n    print(\"One\")\nelif a == 4:\n    print(\"Three\")\nelif a &lt; 10:\n    print(\"Two\")\nelse:\n    print(\"Four\")\n\nThree\n\n\nSelbstverständlich kann man Vergleiche nicht nur mit Zahlen durchführen:\n\ns = \"Python\"\n\nif s == \"Python\":\n    print(\"Way to go!\")\nelif s == \"R\":\n    print(\"Statistics\")\nelse:\n    print(\"Unknown\")\n\nWay to go!\n\n\n\ns = \"R\"\n\nif s == \"Python\":\n    print(\"Way to go!\")\nelif s == \"R\":\n    print(\"Statistics\")\nelse:\n    print(\"Unknown\")\n\nStatistics"
  },
  {
    "objectID": "05/05.html#for-schleifen",
    "href": "05/05.html#for-schleifen",
    "title": "5 – Bedingungen und Schleifen",
    "section": "for-Schleifen",
    "text": "for-Schleifen\nUm Befehle zu wiederholen, gibt es die Möglichkeit, Schleifen zu verwenden. Eine häufig verwendete Schleife ist die sogenannte for-Schleife. Als einfaches Beispiel ersetzen wir folgenden repetitiven Code durch eine Schleife:\n\nprint(\"Hallo\")\nprint(\"Hallo\")\nprint(\"Hallo\")\n\nHallo\nHallo\nHallo\n\n\n\nfor i in range(3):\n    print(\"Hallo\")\n\nHallo\nHallo\nHallo\n\n\nDie sogenannte Schleifenvariable i nimmt hier in den drei Durchläufen drei verschiedene Werte 0, 1 und 2 an – dies sind nämlich genau die Werte, die die Funktion range zurückgibt. Der Name der Schleifenvariable kann beliebig gewählt werden, oft wird für kurze Schleifen einfach i verwendet (man könnte auch _ verwenden, um anzudeuten, dass man an diesem Namen eigentlich nicht weiter interessiert ist). Dieser Name bleibt nach dem Ausführen der Schleife übrigens bestehen, er unterscheidet sich nicht von anderen durch Zuweisung entstandenen Namen.\n\n\n\n\n\n\nHinweis\n\n\n\nÜberlegen Sie, welchen Wert i am Ende des folgenden Beispiels hat:\ni = 800\nfor i in range(3):\n    print(\"Hello\")\nDie richtige Antwort lautet 2, da dies der letzte Wert ist, welcher in der Schleife zugewiesen wird. Der Funktionsaufruf range(3) erzeugt nämlich die drei Werte 0, 1 und 2. Die Zuweisung i = 800 zu Beginn hat hier eigenlich überhaupt keinen Effekt (oder anders formuliert, diese Zuweisung ist sinnlos und könnte daher ohne Auswirkungen entfernt werden).\n\n\nDie Funktion range wird mit range(start, stop, step) aufgerufen (der Hilfetext verrät dazu mehr Details) und erzeugt eine Sequenz, welche aus ganzen Zahlen besteht, die von start (optional) bis stop in der Schrittweite step (optional) läuft. Wenn man sich die einzelnen Elemente in einem range-Objekt ansehen will, muss man dieses zuerst in eine Liste umwandeln:\n\nx = range(10)\nx\n\nrange(0, 10)\n\n\n\nlist(x)\n\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n\nGrundsätzlich beginnt Python mit 0 zu zählen, d.h. auch range beginnt standardmäßig bei 0. Die letzte Zahl ist nicht mehr Teil der Sequenz, da man so einfach die Anzahl der erzeugten Elemente sehen kann (im Beispiel oben sieht man, dass range(10) aus 10 Elementen besteht).\nIn Python iteriert eine for-Schleife über alle Elemente einer Sequenz (d.h. alle Datentypen, die aus mehreren Elementen bestehen und iterierbar sind, wie z.B. Strings oder Listen). Im folgenden Beispiel iteriert die Schleife über einen String, d.h. bei jedem Schleifendurchlauf werden die einzelnen Elemente (Buchstaben) eines Strings der Schleifenvariable s zugewiesen:\n\nfor s in \"String\":\n    print(s)\n\nS\nt\nr\ni\nn\ng\n\n\nDies funktioniert genauso mit Listen, da diese auch zur Gruppe der Sequenzdatentypen gehören und mehrere Elemente beinhalten können:\n\na = [\"Hello\", \"world!\", \"I\", \"love\", \"Python!\"]\n\nfor element in a:\n    print(element)\n\nHello\nworld!\nI\nlove\nPython!\n\n\nDer Befehl break bricht die Schleife ab. Python springt ans Ende der Schleife und macht von hier mit der Ausführung der noch folgenden Befehlszeilen weiter.\n\ni = 0\n\nfor c in \"Suchstring\":\n    if c == \"u\":\n        break  # beende Schleife sofort\n    i += 1  # Abkürzung für i = i + 1\n\nprint(i)\n\n1\n\n\nIm Beispiel oben wird ein bestimmtes Zeichen in einem String gesucht, dessen Position dann in i abzulesen ist.\nDer Befehl continue geht sofort zur nächsten Iteration der Schleife (überspringt also den restlichen Code der Schleife, der noch danach folgt).\n\nfor num in range(2, 10):\n    if num % 2 == 0:  # gerade Zahl?\n        print(\"Found an even number\", num)\n        continue  # überspringe alle restlichen Zeilen innerhalb der Schleife\n    print(\"Found a number\", num)\n\nFound an even number 2\nFound a number 3\nFound an even number 4\nFound a number 5\nFound an even number 6\nFound a number 7\nFound an even number 8\nFound a number 9\n\n\nDetails zu Strings und Listen folgen in den nächsten Einheiten."
  },
  {
    "objectID": "05/05.html#while-schleifen",
    "href": "05/05.html#while-schleifen",
    "title": "5 – Bedingungen und Schleifen",
    "section": "while-Schleifen",
    "text": "while-Schleifen\nIm Gegensatz zu for-Schleifen sind while-Schleifen gut geeignet, wenn nicht im Vorhinein klar ist, wie oft die Schleife durchlaufen werden soll. Im folgenden Beispiel wird eine sogenannte Endlosschleife verwendet (while True ist immer True). Zum Verlassen dieser Endlosschleife wird dann aber auf break zurückgegriffen. Die Funktion input wird verwendet, um Tastatureingaben vom Benutzer abzufragen – die eingegebenen Zeichen werden von dieser Funktion als String zurückgegeben.\nwhile True:\n    line = input(\"&gt; (enter 'q' to quit) \")\n    if line == \"q\":\n        break\nEin weiteres Beispiel einer while-Schleife zeigt das folgende Zahlenratespiel:\nnumber = 23  # diese Zahl soll erraten werden\n\nwhile True:\n    guess = int(input(\"Enter an integer: \"))\n    if guess == number:\n        print(\"Congratulations, you guessed it.\")\n        break\n    elif guess &lt; number:\n        print(\"No, it is a little higher than that.\")\n    else:\n        print(\"No, it is a little lower than that.\")\n\n\n\n\n\n\nTipp\n\n\n\nDie Funktion int wird hier verwendet, um die Benutzereingabe (ein String) in eine Ganzzahl zu konvertieren (z.B. wandelt int(\"7\") den String \"7\" in eine Zahl 7 um)."
  },
  {
    "objectID": "05/05.html#übungen",
    "href": "05/05.html#übungen",
    "title": "5 – Bedingungen und Schleifen",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nSchreiben Sie folgendes Programm:\n\nLesen Sie zuerst mit der Funktion input zwei Zahlen ein (weisen Sie diesen beiden Zahlen die Namen x und y zu). Beachten Sie, dass input Strings zurückliefert und dass Sie diese mit der Funktion int in Ganzzahlen umwandeln können.\nWenn die Summe der beiden Zahlen größer als 50 ist, geben Sie x + y &gt; 50 am Bildschirm aus.\nWenn die Summe der beiden Zahlen kleiner als 50 ist, geben Sie x + y &lt; 50 am Bildschirm aus.\nAnsonsten geben Sie x + y == 50 aus.\n\n\n\n\n\n\n\nTipp\n\n\n\nDie Builtin-Funktion input ermöglicht es, Eingaben von der Tastatur einzulesen. Man kann beliebige Zeichen eingeben und mit der Eingabetaste bestätigen. Das Ergebnis der Eingabe wird dann von der Funktion zurückgegeben (d.h. man kann diesem Wert auch einen Namen zuweisen, z.B. x = input()). Der Typ des Rückgabewerts ist immer str.\n\n\n\n\nÜbung 2\nSchreiben Sie eine Funktion is_odd, welche einen Parameter hat und überprüft, ob das übergebene Argument gerade oder ungerade ist (das können Sie z.B. durch den Rest der Division durch 2 überprüfen). Falls das Argument ungerade ist, soll die Funktion True mittels return zurückgeben, sonst False.\n\n\nÜbung 3\nGegeben ist eine Liste lst = [\"I\", \"love\", \"Python\"]. Schreiben Sie eine for-Schleife, welche die einzelnen Elemente in der Liste mit print Zeile für Zeile am Bildschirm ausgibt.\n\n\nÜbung 4\nGegeben ist wieder eine Liste lst = [\"I\", \"love\", \"Python\"]. Schreiben Sie eine for-Schleife, welche über die einzelnen Elemente in der Liste iteriert. Eine zweite (geschachtelte) for-Schleife soll dann über jeden Buchstaben der einzelnen Strings iterieren und jeden Buchstaben einzeln gefolgt vom Zeichen - ausgeben.\n\n\n\n\n\n\nHinweis\n\n\n\nVerwenden Sie die Funktion print mit dem Argument end=\"-\". Die Ausgabe soll wie folgt aussehen:\nI-l-o-v-e-P-y-t-h-o-n-\n\n\n\n\nÜbung 5\nSchreiben Sie das folgende verschachtelte if–else-Konstrukt als if–elif–else-Block:\nif x &gt; 0:\n    print(\"x is positive\")\nelse:\n    if x &lt; 0:\n        print(\"x is negative\")\n    else:\n        print(\"x is equal to 0\")\nÜberprüfen Sie Ihre Lösung mit den drei Werten x = 5, x = -11 und x = 0 (d.h. bei beiden Varianten soll dasselbe Ergebnis herauskommen).\n\n\nÜbung 6\nSchreiben Sie ein Programm, welches die Eingabe einer ganzen Zahl zwischen 1 und 10 erwartet. Falls die Eingabe nicht im erlaubten Bereich liegt, soll eine Meldung ausgegeben werden (“Invalid input. Please try again.”) und die Eingabe wiederholt werden. Falls die Eingabe im erlaubten Bereich liegt, soll die Schleife beendet werden und die eingegebene Zahl ausgegeben werden (z.B. “You entered: 5”)."
  },
  {
    "objectID": "07/07-solutions.html",
    "href": "07/07-solutions.html",
    "title": "7 – Lösungen",
    "section": "",
    "text": "def histogram(x, char=\"*\"):\n    for n in x:\n        print(char * n)\n\nhistogram([1, 8, 5, 17, 14, 9, 2])\nhistogram([1, 8, 5, 17, 2], char=\"-\")\n\n*\n********\n*****\n*****************\n**************\n*********\n**\n-\n--------\n-----\n-----------------\n--"
  },
  {
    "objectID": "07/07-solutions.html#übung-1",
    "href": "07/07-solutions.html#übung-1",
    "title": "7 – Lösungen",
    "section": "",
    "text": "def histogram(x, char=\"*\"):\n    for n in x:\n        print(char * n)\n\nhistogram([1, 8, 5, 17, 14, 9, 2])\nhistogram([1, 8, 5, 17, 2], char=\"-\")\n\n*\n********\n*****\n*****************\n**************\n*********\n**\n-\n--------\n-----\n-----------------\n--"
  },
  {
    "objectID": "07/07-solutions.html#übung-2",
    "href": "07/07-solutions.html#übung-2",
    "title": "7 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\n\ndef sum_of_squares(x):\n    return sum([n**2 for n in x])"
  },
  {
    "objectID": "07/07-solutions.html#übung-3",
    "href": "07/07-solutions.html#übung-3",
    "title": "7 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\n\nimport math\n\nnumbers = range(1, 26)\nsquares = [x**2 for x in numbers]\nevens = [x for x in numbers if x % 2 == 0]\nodds = [x for x in numbers if x % 2 != 0]\nroots = [math.sqrt(x) for x in numbers]\nlogs = [math.log(x) for x in numbers]"
  },
  {
    "objectID": "07/07-solutions.html#übung-4",
    "href": "07/07-solutions.html#übung-4",
    "title": "7 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\n\nz = [x**2 - y for x in range(7) for y in [3, 1, 5] if x != y]\nz\n\n[-3, -1, -5, -2, -4, 1, 3, -1, 8, 4, 13, 15, 11, 22, 24, 33, 35, 31]\n\n\n\nz = []\nfor x in range(7):\n    for y in [3, 1, 5]:\n        if x != y:\n            z.append(x**2 - y)\n\nz\n\n[-3, -1, -5, -2, -4, 1, 3, -1, 8, 4, 13, 15, 11, 22, 24, 33, 35, 31]"
  },
  {
    "objectID": "07/07-solutions.html#übung-5",
    "href": "07/07-solutions.html#übung-5",
    "title": "7 – Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\n\na = {\"eins\": \"one\", \"zwei\": \"two\", \"drei\": \"three\"}\na[\"zwei\"]\n\n'two'"
  },
  {
    "objectID": "07/07-solutions.html#übung-6",
    "href": "07/07-solutions.html#übung-6",
    "title": "7 – Lösungen",
    "section": "Übung 6",
    "text": "Übung 6\n\na[\"vier\"] = \"four\"\na\n\n{'eins': 'one', 'zwei': 'two', 'drei': 'three', 'vier': 'four'}"
  },
  {
    "objectID": "07/07-solutions.html#übung-7",
    "href": "07/07-solutions.html#übung-7",
    "title": "7 – Lösungen",
    "section": "Übung 7",
    "text": "Übung 7\nOption 1:\n\na[\"zehn\"]  # KeyError\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[8], line 1\n----&gt; 1 a[\"zehn\"]  # KeyError\n\nKeyError: 'zehn'\n\n\n\nOption 2:\n\na.get(\"zehn\", \"undefiniert\")\n\n'undefiniert'\n\n\nOption 3:\n\na.setdefault(\"zehn\", \"undefiniert\")\n\n'undefiniert'\n\n\na.get(\"zehn\", \"undefiniert\") gibt \"undefiniert\" zurück wenn der Eintrag \"zehn\" nicht existiert. Das Dictionary a wird dadurch aber nicht verändert, d.h. der Eintrag a[\"zehn\"] wird nicht hinzugefügt. Die ist aber bei a.setdefault(\"zehn\", \"undefiniert\") der Fall, d.h. nach diesem Aufruf existiert a[\"zehn\"]."
  },
  {
    "objectID": "07/07-solutions.html#übung-8",
    "href": "07/07-solutions.html#übung-8",
    "title": "7 – Lösungen",
    "section": "Übung 8",
    "text": "Übung 8\n\ndef find(s, sub):\n    indexes = []\n    for i, char in enumerate(s):\n        if char == sub:\n            indexes.append(i)\n    return indexes\n\n\nfind(\"Werkstatttreppe\", \"t\")\n\n[5, 7, 8, 9]"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Einführung in Python und PsychoPy",
    "section": "",
    "text": "Die folgenden Unterlagen dienen als Basis für die Lehrveranstaltung Einführung in Python und PsychoPy.\n\nOrganisatorisches\nGrundlagen (Lösungen)\nDie Python-Umgebung (Lösungen)\nNamen, Ausdrücke, Anweisungen (Lösungen)\nFunktionen (Lösungen)\nBedingungen und Schleifen (Lösungen)\nStrings (Lösungen)\nListen und Dictionaries (Lösungen)\nEin- und Ausgabe (Lösungen)\nNumerische Daten (Lösungen)\nGrafiken (Lösungen)\nPsychoPy (1) (Lösungen)\nPsychoPy (2) (Lösungen)\n\n\nÜbungen (Lösungen)"
  },
  {
    "objectID": "a1/a1.html",
    "href": "a1/a1.html",
    "title": "Übungen",
    "section": "",
    "text": "Elektrische Widerstände können in Serie oder parallel geschaltet werden. In einer Serienschaltung addieren sich die Widerstände, während in einer Parallelschaltung der Kehrwert der Gesamtwiderstandes gleich der Summe der Kehrwerte der Einzelwiderstände ist. In Formeln kann dies wie folgt ausgedrückt werden:\n\nSerienschaltung: \\(R_G = R_1 + R_2\\)\nParallelschaltung: \\(R_G = R_1 \\parallel R_2 \\rightarrow \\frac{1}{R_G} = \\frac{1}{R_1} + \\frac{1}{R_2}\\)\n\nSchreiben Sie zwei Funktionen serial und parallel, welche die jeweiligen Gesamtwiderstände zurückgeben. Beide Funktionen sollen jeweils zwei Parameter r1 und r2 haben, welche die beiden zu kombinierenden Widerstände darstellen.\nTesten Sie beide Funktionen mit den Widerständen \\(R_1 = 10\\,\\Omega\\) und \\(R_2 = 20\\,\\Omega\\). Die Gesamtwiderstände sollten \\(30\\,\\Omega\\) (Serienschaltung) und \\(6.67\\,\\Omega\\) (Parallelschaltung) betragen.\nBerechnen Sie außerdem den Gesamtwiderstand von \\((R_1 + R_2) \\parallel R_3\\) mit den Werten \\(R_1 = 10\\,\\Omega\\), \\(R_2 = 20\\,\\Omega\\) und \\(R_3 = 50\\,\\Omega\\) mit einem Ausdruck (unter Verwendung der beiden Funktionen)!"
  },
  {
    "objectID": "a1/a1.html#übung-1",
    "href": "a1/a1.html#übung-1",
    "title": "Übungen",
    "section": "",
    "text": "Elektrische Widerstände können in Serie oder parallel geschaltet werden. In einer Serienschaltung addieren sich die Widerstände, während in einer Parallelschaltung der Kehrwert der Gesamtwiderstandes gleich der Summe der Kehrwerte der Einzelwiderstände ist. In Formeln kann dies wie folgt ausgedrückt werden:\n\nSerienschaltung: \\(R_G = R_1 + R_2\\)\nParallelschaltung: \\(R_G = R_1 \\parallel R_2 \\rightarrow \\frac{1}{R_G} = \\frac{1}{R_1} + \\frac{1}{R_2}\\)\n\nSchreiben Sie zwei Funktionen serial und parallel, welche die jeweiligen Gesamtwiderstände zurückgeben. Beide Funktionen sollen jeweils zwei Parameter r1 und r2 haben, welche die beiden zu kombinierenden Widerstände darstellen.\nTesten Sie beide Funktionen mit den Widerständen \\(R_1 = 10\\,\\Omega\\) und \\(R_2 = 20\\,\\Omega\\). Die Gesamtwiderstände sollten \\(30\\,\\Omega\\) (Serienschaltung) und \\(6.67\\,\\Omega\\) (Parallelschaltung) betragen.\nBerechnen Sie außerdem den Gesamtwiderstand von \\((R_1 + R_2) \\parallel R_3\\) mit den Werten \\(R_1 = 10\\,\\Omega\\), \\(R_2 = 20\\,\\Omega\\) und \\(R_3 = 50\\,\\Omega\\) mit einem Ausdruck (unter Verwendung der beiden Funktionen)!"
  },
  {
    "objectID": "a1/a1.html#übung-2",
    "href": "a1/a1.html#übung-2",
    "title": "Übungen",
    "section": "Übung 2",
    "text": "Übung 2\nSchreiben Sie ein Programm, welches die Benutzer auffordert, eine Zahl zwischen 1 und 12 einzugeben (entsprechend den Monaten). Das Programm soll dann den Namen des Monats ausgeben. Falls die eingegebene Zahl nicht im Bereich 1 bis 12 liegt, soll eine Fehlermeldung ausgegeben werden. Die Eingabe soll so lange wiederholt werden, bis eine gültige Zahl eingegeben wird.\nZur Bestimmung des Monatsnamens definieren Sie eine Funktion month_name, welche die Nummer des Monats als Argument erhält und den Namen des Monats zurückgibt.\n\n\n\n\n\n\nHinweis\n\n\n\nSie können davon ausgehen, dass die Benutzer nur ganze Zahlen eingeben."
  },
  {
    "objectID": "a1/a1.html#übung-3",
    "href": "a1/a1.html#übung-3",
    "title": "Übungen",
    "section": "Übung 3",
    "text": "Übung 3\nSchreiben Sie eine Funktion count_words, welche die Anzahl der Wörter in einem Text zählt. Die Funktion soll zwei Parameter haben: text (der Text, in dem die Wörter gezählt werden sollen) und sep (das Trennzeichen, Standardwert ist ein Leerzeichen). Verwenden Sie dafür die String-Methode split, welche eine Liste von Strings zurückgibt; die Länge dieser Liste kann mit der Funktion len ermittelt werden.\nTesten Sie die Funktion mit folgendem Text:\n\nPython is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming. Python’s elegant syntax and dynamic typing, together with its interpreted nature, make it an ideal language for scripting and rapid application development in many areas.\n\n\n\n\n\n\n\nHinweis\n\n\n\nFür diese Funktion reicht uns eine einfache Definition von Wörtern, die durch Leerzeichen getrennt sind. In der Praxis ist die Definition von Wörtern komplexer, da auch Satzzeichen und andere Zeichen berücksichtigt werden müssten.\n\n\n\n\n\n\n\n\nTipp\n\n\n\nDefiniert man den gegebenen Text als normalen String, entsteht eine sehr lange Zeile. Das ist in Python zwar erlaubt, aber aus stilistischen Gründen sollten Zeilen nicht länger als 88 Zeichen sein. Da Ruff dies derzeit nicht automatisch korrigiert, müssen Zeilenumbrüche manuell eingefügt werden. Wichtig ist dabei, dass Python benachbarte Strings automatisch zu einem einzigen String zusammenfügt:\n\ntext = \"This is\" \" an example.\"\ntext\n\n'This is an example.'\n\n\nDiese Eigenschaft lässt sich nutzen, um lange Strings über mehrere Zeilen zu verteilen. Voraussetzung ist, dass die einzelnen Strings in Klammern stehen:\n\ntext = (\n    \"This is\"\n    \" an example.\"\n)\ntext\n\n'This is an example.'"
  },
  {
    "objectID": "a1/a1.html#übung-4",
    "href": "a1/a1.html#übung-4",
    "title": "Übungen",
    "section": "Übung 4",
    "text": "Übung 4\nSchreiben Sie eine Funktion factorial, welche die Fakultät \\(n!\\) einer positiven Zahl \\(n\\) berechnet. Die Fakultät \\(n!\\) einer Zahl \\(n\\) ist das Produkt aller positiven ganzen Zahlen kleiner oder gleich \\(n\\). Die Fakultät von 0 ist mit 1 definiert. Berechnen Sie abschließend \\(5!\\)."
  },
  {
    "objectID": "a1/a1.html#übung-5",
    "href": "a1/a1.html#übung-5",
    "title": "Übungen",
    "section": "Übung 5",
    "text": "Übung 5\nSchreiben Sie eine Funktion is_divisible, welche überprüft, ob eine Zahl \\(n\\) durch eine andere Zahl \\(m\\) ohne Rest teilbar ist. Die Funktion soll zwei Parameter haben: n (die zu überprüfende Zahl) und m (die Zahl, durch die geteilt werden soll). Die Funktion soll True zurückgeben, wenn die Division ohne Rest möglich ist, andernfalls False.\nTesten Sie die Funktion mit den Zahlenpaaren (10, 2), (10, 3), (10, 5) und (10, 7)."
  },
  {
    "objectID": "a1/a1.html#übung-6",
    "href": "a1/a1.html#übung-6",
    "title": "Übungen",
    "section": "Übung 6",
    "text": "Übung 6\nWas ist das Problem im folgenden Beispiel? Korrigieren Sie den Code so, dass er funktioniert.\nx = 10\n\nif x &gt; 0:\n    print(\"x is positive.\")\nelse:\n    print(\"x is zero.\")\nelif x &lt; 0:\n    print(\"x is negative.\")"
  },
  {
    "objectID": "a1/a1.html#übung-7",
    "href": "a1/a1.html#übung-7",
    "title": "Übungen",
    "section": "Übung 7",
    "text": "Übung 7\nErstellen Sie eine Liste numbers, welche die Wurzeln der Zahlen 0, 10, 20, … , 990, 1000 beinhaltet. Verwenden Sie dazu eine List Comprehension.\nBestimmen Sie dann mit einer geeigneten Python-Funktion die Anzahl und die Summe der Elemente der so entstandenen Liste."
  },
  {
    "objectID": "a1/a1.html#übung-8",
    "href": "a1/a1.html#übung-8",
    "title": "Übungen",
    "section": "Übung 8",
    "text": "Übung 8\nErklären Sie, warum folgender Code nicht funktioniert:\nfor x in range(10)\n    print(x)\nGeben Sie den korrekten Code an!"
  },
  {
    "objectID": "a1/a1.html#übung-9",
    "href": "a1/a1.html#übung-9",
    "title": "Übungen",
    "section": "Übung 9",
    "text": "Übung 9\nBerechnen Sie mit Python das Ergebnis des folgenden mathematischen Ausdruckes und weisen Sie es dem Namen result zu:\n\\[\\frac{17 \\cdot (\\sqrt{5} + \\frac{2}{3})}{27.7 - 3^\\pi} + 42^{\\frac{2}{7}}\\]\nGeben Sie mit Hilfe der print-Funktion das Ergebnis auf zwei Nachkommastellen gerundet aus (es sollte ca. \\(-9.93\\) lauten)."
  },
  {
    "objectID": "a1/a1.html#übung-10",
    "href": "a1/a1.html#übung-10",
    "title": "Übungen",
    "section": "Übung 10",
    "text": "Übung 10\nErklären Sie, warum folgender Code nicht funktioniert:\nalpha = 5\nlambda = 7\nprint(alpha + lambda)\nGeben Sie auch den korrekten Code an!"
  },
  {
    "objectID": "a1/a1.html#übung-11",
    "href": "a1/a1.html#übung-11",
    "title": "Übungen",
    "section": "Übung 11",
    "text": "Übung 11\nDie Standardabweichung \\(s\\) von \\(N\\) Werten \\(x_i\\) kann mit folgender Formel berechnet werden:\n\\[s = \\sqrt{\\frac{1}{N-1} \\sum_{i=1}^{N}(x_i - \\bar{x})^2}\\]\nDabei ist \\(\\bar{x}\\) der arithmetische Mittelwert der Werte:\n\\[\\bar{x} = \\frac{1}{N} \\sum_{i=1}^{N} x_i\\]\nSchreiben Sie eine Funktion namens std, welche eine Liste an Zahlen als Argument entgegennimmt und deren Standardabweichung zurückgibt. Verwenden Sie in Ihrer Lösung nicht das Modul statistics, sondern berechnen Sie die Kenngrößen selbst (z.B. mittels List Comprehensions)!\nTesten Sie Ihre Funktion mit der Liste [10, 12, 23, 23, 16, 23, 21, 16]. Die Standardabweichung sollte ca. 5.237 betragen."
  },
  {
    "objectID": "a1/a1.html#übung-12",
    "href": "a1/a1.html#übung-12",
    "title": "Übungen",
    "section": "Übung 12",
    "text": "Übung 12\nSchreiben Sie eine Funktion get_even, welche eine Liste an Zahlen als Argument entgegennimmt und eine neue Liste, welche nur die geraden Zahlen der ursprünglichen Liste beinhaltet, zurückgibt.\n\n\n\n\n\n\nHinweis\n\n\n\nDer Aufruf get_even([1, 45, -4, -5, 17, 2]) gibt also die Liste [-4, 2] zurück.\n\n\n\nÜbung 13\nSchreiben Sie eine Funktion fizzbuzz, welche eine Zahl als Argument entgegennimmt. Wenn die Zahl sowohl durch 3 als auch durch 5 teilbar ist, soll die Funktion den String Fizzbuzz zurückgeben. Wenn die Zahl nur durch 3 teilbar ist, soll die Funktion Fizz zurückgeben. Wenn die Zahl nur durch 5 teilbar ist, soll die Funktion Buzz zurückgeben. Für alle anderen Zahlen soll die Zahl selbst als String zurückgegeben werden.\nRufen Sie die Funktion dann in einer Schleife mit den Zahlen von 1 bis 15 auf und geben Sie die zurückgegebenen Werte mit print am Bildschirm aus!\nDie ausgegebenen Werte sollten lauten: 1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, Fizzbuzz.\n\n\n\n\n\n\nHinweis\n\n\n\nDer Rest-Operator % kann die Teilbarkeit einer Zahl überprüfen. Eine Zahl ist durch 3 teilbar, wenn der Rest der Division durch 3 Null ergibt. Eine Zahl ist sowohl durch 3 als auch durch 5 teilbar, wenn der Rest der Division durch 15 Null ergibt."
  },
  {
    "objectID": "a1/a1.html#übung-14",
    "href": "a1/a1.html#übung-14",
    "title": "Übungen",
    "section": "Übung 14",
    "text": "Übung 14\nSchreiben Sie eine Funktion add, welche zwei Zahlen addiert und deren Summe zurückgibt. Die Funktion soll also mit zwei Argumenten aufgerufen werden können, wobei aber das zweite Argument optional sein soll. Wenn nur ein Argument übergeben wird, soll die Funktion 1 zu diesem Wert addieren und zurückgeben."
  },
  {
    "objectID": "a1/a1.html#übung-15",
    "href": "a1/a1.html#übung-15",
    "title": "Übungen",
    "section": "Übung 15",
    "text": "Übung 15\nGegeben sei folgender Funktionskopf:\ndef test(x, y=1, z=5):\nErklären Sie, warum folgende drei Aufrufe nicht funktionieren:\n\ntest(y=2, z=2)\ntest(4, y=2, x=2)\ntest()"
  },
  {
    "objectID": "a1/a1.html#übung-16",
    "href": "a1/a1.html#übung-16",
    "title": "Übungen",
    "section": "Übung 16",
    "text": "Übung 16\nSchreiben Sie eine Funktion is_even, welche überprüft, ob das übergebene Argument gerade ist. Falls dies der Fall ist, soll die Funktion True zurückgeben, sonst False. Testen Sie Ihre Funktion, indem Sie sie mit mindestens zwei verschiedenen Argumenten (eine gerade Zahl und eine ungerade Zahl) aufrufen!"
  },
  {
    "objectID": "a1/a1.html#übung-17",
    "href": "a1/a1.html#übung-17",
    "title": "Übungen",
    "section": "Übung 17",
    "text": "Übung 17\nSchreiben Sie eine Funktion sign, welche das Vorzeichen einer Zahl bestimmt. Die Funktion soll in Abhängigkeit der übergebenen Zahl folgende Werte zurückgeben:\n\nIst die Zahl positiv, soll 1 zurückgegeben werden.\nIst die Zahl negativ, soll -1 zurückgegeben werden.\nIst die Zahl gleich Null, soll 0 zurückgegeben werden."
  },
  {
    "objectID": "a1/a1.html#übung-18",
    "href": "a1/a1.html#übung-18",
    "title": "Übungen",
    "section": "Übung 18",
    "text": "Übung 18\nGegeben ist der String x = \"Pythonista\". Schreiben Sie eine for-Schleife, welche über den String iteriert und jedes Zeichen dieses Strings in einer neuen Zeile ausgibt."
  },
  {
    "objectID": "a1/a1.html#übung-19",
    "href": "a1/a1.html#übung-19",
    "title": "Übungen",
    "section": "Übung 19",
    "text": "Übung 19\nGegeben ist die Liste y = [\"This\", \"is\", \"a\", \"sample\", \"list\"]. Erzeugen Sie mit einer List Comprehension aus dieser Liste eine neue Liste z, welche alle Elemente von y in Großbuchstaben beinhaltet."
  },
  {
    "objectID": "a1/a1.html#übung-20",
    "href": "a1/a1.html#übung-20",
    "title": "Übungen",
    "section": "Übung 20",
    "text": "Übung 20\nGegeben ist der String s = \"Donaudampfschifffahrtsgesellschaft\". Verwenden Sie geeignete Funktionen oder String-Methoden um folgende Fragen zu beantworten:\n\nAus wie vielen Zeichen besteht s?\nAn welcher Stelle (Index) tritt der Buchstabe f das erste mal auf?\nWie viele e kommen in dem String vor?"
  },
  {
    "objectID": "a1/a1.html#übung-21",
    "href": "a1/a1.html#übung-21",
    "title": "Übungen",
    "section": "Übung 21",
    "text": "Übung 21\nGegeben ist eine Liste x = [-13, 22, -2, -14, 33, -16]. Erzeugen Sie mit einer List Comprehension eine neue Liste y, welche die Absolutwerte der Zahlen in x enthält.\n\n\n\n\n\n\nHinweis\n\n\n\nDie eingebaute Funktion abs liefert den Absolutwert einer Zahl zurück."
  },
  {
    "objectID": "a1/a1.html#übung-22",
    "href": "a1/a1.html#übung-22",
    "title": "Übungen",
    "section": "Übung 22",
    "text": "Übung 22\nErzeugen Sie ein NumPy-Array x mit 15 Zeilen und 5 Spalten, welches ganzzahlige Zufallszahlen im Bereich 0 bis 100 (inklusive) beinhalten soll. Initialisieren Sie den Zufallszahlengenerator mit dem Wert 1. Berechnen Sie abschließend die fünf Spaltenmittelwerte von x."
  },
  {
    "objectID": "a1/a1.html#übung-23",
    "href": "a1/a1.html#übung-23",
    "title": "Übungen",
    "section": "Übung 23",
    "text": "Übung 23\nErzeugen Sie ein NumPy-Array x mit 1000 Zahlen im gleichmäßigen Abstand von 10 bis 13 (inklusive)."
  },
  {
    "objectID": "a1/a1.html#übung-24",
    "href": "a1/a1.html#übung-24",
    "title": "Übungen",
    "section": "Übung 24",
    "text": "Übung 24\nGegeben ist ein NumPy-Array x, welches durch folgenden Code erzeugt werden kann:\n\nfrom numpy.random import default_rng\n\nrng = default_rng(2)\nx = 10 + 2 * rng.standard_normal(10000)\n\nErzeugen Sie mit Matplotlib ein Histogram mit 50 Bins von x."
  },
  {
    "objectID": "a1/a1.html#übung-25",
    "href": "a1/a1.html#übung-25",
    "title": "Übungen",
    "section": "Übung 25",
    "text": "Übung 25\nGegeben ist ein NumPy-Array x, welches durch folgenden Code erzeugt werden kann:\n\nfrom numpy.random import default_rng\n\nrng = default_rng(2)\nx = 10 + 2 * rng.standard_normal(10000)\n\nStellen Sie mit Matplotlib die ersten 100 Werte von x als Balkengrafik dar."
  },
  {
    "objectID": "a1/a1.html#übung-26",
    "href": "a1/a1.html#übung-26",
    "title": "Übungen",
    "section": "Übung 26",
    "text": "Übung 26\nDie Datei shakespeare.txt beinhaltet die gesammelten Werke von William Shakespeare. Bestimmen Sie mit Python, wie viele Zeilen diese Datei enthält. Finden Sie außerdem heraus, in welcher Zeile der Text “Go antickly, show outward hideousness,” vorkommt!\n\n\n\n\n\n\nHinweis\n\n\n\nDer gesuchte Text kann auch Leerzeichen am Anfang oder Ende der Zeile enthalten. Verwenden Sie zur Suche daher entweder den in-Operator oder die String-Methode strip, um führende und nachfolgende Leerzeichen zu entfernen."
  },
  {
    "objectID": "a1/a1.html#übung-27",
    "href": "a1/a1.html#übung-27",
    "title": "Übungen",
    "section": "Übung 27",
    "text": "Übung 27\nBerechnen Sie die Summe aller natürlichen Zahlen von 0 bis 1000 (inklusive), die durch 3 oder 5 aber nicht durch 3 und 5 teilbar sind.\n\n\n\n\n\n\nHinweis\n\n\n\nEine Zahl ist durch 3 teilbar, wenn der Rest der Division durch 3 gleich Null ist. Eine Zahl ist durch 3 und 5 teilbar, wenn der Rest der Division durch 15 gleich Null ist.\nVerwenden Sie and bzw. or, um die Bedingungen zu verknüpfen und achten Sie auf die korrekte Klammersetzung."
  },
  {
    "objectID": "a1/a1.html#übung-28",
    "href": "a1/a1.html#übung-28",
    "title": "Übungen",
    "section": "Übung 28",
    "text": "Übung 28\nGegeben ist der String x = \"Pythonista\". Schreiben Sie eine for-Schleife, welche über den String iteriert und jedes Zeichen dieses Strings als Großbuchstaben getrennt durch Bindestriche ausgibt. Die gewünschte Ausgabe sollte also wie folgt aussehen:\nP-Y-T-H-O-N-I-S-T-A-"
  },
  {
    "objectID": "a1/a1.html#übung-29",
    "href": "a1/a1.html#übung-29",
    "title": "Übungen",
    "section": "Übung 29",
    "text": "Übung 29\nDefinieren Sie zwei Funktionen kmh_to_mph bzw. mph_to_kmh, welche Geschwindigkeiten von Kilometer pro Stunde in Meilen pro Stunde bzw. umgekehrt umwandeln und zurückgeben. Die Umrechnungsvorschriften lauten:\n\\[\\mathrm{mph} = \\frac{\\mathrm{kmh}}{\\mathrm{1.609}} \\hspace{35pt} \\mathrm{kmh} = 1.609 \\cdot \\mathrm{mph}\\]\nTesten Sie die Funktionen dann mit folgendem Befehl:\nkmh_to_mph(mph_to_kmh(65))"
  },
  {
    "objectID": "a1/a1.html#übung-30",
    "href": "a1/a1.html#übung-30",
    "title": "Übungen",
    "section": "Übung 30",
    "text": "Übung 30\nAngenommen Sie möchten zu einer bestehenden Liste x ein Element am Ende hinzufügen. Was stimmt nicht im folgenden Code:\nx = [1, 2, 3, 4]\nx = x.append(5)\nErklären Sie was hier passiert und geben Sie auch die korrekte Variante an!"
  },
  {
    "objectID": "a1/a1.html#übung-31",
    "href": "a1/a1.html#übung-31",
    "title": "Übungen",
    "section": "Übung 31",
    "text": "Übung 31\nWie können Sie folgenden Text dem Namen s zuweisen:\nEr sagte: “Sicher!”\nGeben Sie in Ihrer Antwort die korrekte Zuweisung an!"
  },
  {
    "objectID": "a1/a1.html#übung-32",
    "href": "a1/a1.html#übung-32",
    "title": "Übungen",
    "section": "Übung 32",
    "text": "Übung 32\nGegeben sei folgender String:\nx = \"abcdefghijklmnopqrstuvwxyz\"\nWie können Sie durch indizieren/slicen jedes zweite Zeichen herausgreifen? Erzeugen Sie damit einen neuen String a (beginnend mit dem Zeichen \"a\") und einen neuen String b (beginnend mit dem Zeichen \"b\")."
  },
  {
    "objectID": "a1/a1.html#übung-33",
    "href": "a1/a1.html#übung-33",
    "title": "Übungen",
    "section": "Übung 33",
    "text": "Übung 33\nErzeugen Sie eine Liste words mit den einzelnen Wörtern in folgendem String unter Verwendung einer geeigneten String-Methode:\ns = \"eins/zwei/drei/vier/fünf/sechs/sieben/acht\""
  },
  {
    "objectID": "a1/a1.html#übung-34",
    "href": "a1/a1.html#übung-34",
    "title": "Übungen",
    "section": "Übung 34",
    "text": "Übung 34\nDefinieren Sie eine Funktion replace_vowels, die einen Text und ein Zeichen als Argumente entgegennimmt. Die Funktion soll einen neuen String zurückgeben, in dem alle Vokale (Groß- und Kleinbuchstaben) im ursprünglichen Text durch das spezifizierte Zeichen ersetzt werden.\nBeispiele:\n&gt;&gt;&gt; replace_vowels(\"Hello World!\", \"*\")\n\"H*ll* W*rld!\"\n&gt;&gt;&gt; replace_vowels(\"PYTHON IS FUN\", \"#\")\n\"PYTH#N #S F#N\""
  },
  {
    "objectID": "a1/a1.html#übung-35",
    "href": "a1/a1.html#übung-35",
    "title": "Übungen",
    "section": "Übung 35",
    "text": "Übung 35\nErklären Sie, warum der folgende Code zur Berechnung der Summe von fünf Zahlen nicht funktioniert:\nsum(1, 2, 3, 4, 5)\nGeben Sie einen korrekten Funktionsaufruf an, der die Summe dieser Zahlen berechnet!"
  },
  {
    "objectID": "a1/a1.html#übung-36",
    "href": "a1/a1.html#übung-36",
    "title": "Übungen",
    "section": "Übung 36",
    "text": "Übung 36\nDefine a function countdown that prints a countdown on the screen. The countdown should start from a given number and count down to zero. The start number and the step size should be optional arguments (with default values of 5 for the start number and 1 for the step size). Definieren Sie eine Funktion countdown, die einen Countdown am Bildschirm ausgibt. Der Countdown soll von einer gegebenen Zahl starten und bis Null herunterzählen. Die Startzahl und die Schrittweite sollen optionale Argumente sein (mit Standardwerten von 5 für die Startzahl und 1 für die Schrittweite).\nZwei mögliche Funktionsaufrufe und deren Ausgaben sind unten gezeigt:\n&gt;&gt;&gt; countdown()\n5 - 4 - 3 - 2 - 1 - 0 - Liftoff!\n&gt;&gt;&gt; countdown(7, 2)\n7 - 5 - 3 - 1 - Liftoff!\nStellen Sie sicher, dass die Ausgabe genau wie gezeigt aussieht!"
  },
  {
    "objectID": "a1/a1.html#übung-37",
    "href": "a1/a1.html#übung-37",
    "title": "Übungen",
    "section": "Übung 37",
    "text": "Übung 37\nGegeben sei ein NumPy-Array y, welches durch folgenden Code erzeugt wird:\nfrom numpy.random import default_rng\n\nrng = default_rng(2)\ny = 10 + 2 * rng.standard_normal(10000)\nErzeugen Sie mit Matplotlib eine Grafik mit zwei nebeneinanderliegenden Plots. Der linke Plot soll ein Streudiagramm der ersten 100 Werte von y (y-Achse) gegen eine Zahlenfolge von 1 bis 100 (x-Achse) enthalten. Der rechte Plot soll ein Histogramm der Werte in y mit 30 Bins enthalten."
  },
  {
    "objectID": "a1/a1.html#übung-38",
    "href": "a1/a1.html#übung-38",
    "title": "Übungen",
    "section": "Übung 38",
    "text": "Übung 38\nGegeben sei eine Liste von Strings x = [\"This\", \"is\", \"a\", \"sample\", \"list\"]. Verwenden Sie eine List Comprehension, um eine neue Liste namens lengths zu erstellen, welche die Längen jedes Strings in x enthält."
  },
  {
    "objectID": "a1/a1.html#übung-39",
    "href": "a1/a1.html#übung-39",
    "title": "Übungen",
    "section": "Übung 39",
    "text": "Übung 39\nEin Anagramm ist ein Wort, das durch Umordnen der Buchstaben eines anderen Wortes gebildet wird. Schreiben Sie eine Funktion is_anagram, die überprüft, ob zwei gegebene Strings Anagramme voneinander sind. Die Funktion soll True oder False zurückgeben. Testen Sie Ihre Funktion mit den Strings “listen” und “silent” sowie “hello” und “world” (die Funktion sollte für das erste Paar True und für das zweite Paar False zurückgeben).\n\n\n\n\n\n\nHinweis\n\n\n\nThe eingebaute Funktion sorted könnte hilfreich sein."
  },
  {
    "objectID": "a1/a1.html#übung-40",
    "href": "a1/a1.html#übung-40",
    "title": "Übungen",
    "section": "Übung 40",
    "text": "Übung 40\nDefinieren Sie eine Funktion filter_numbers, die eine Liste von Ganzzahlen als Argument entgegennimmt und eine neue Liste zurückgibt. Diese soll nur die geraden oder ungeraden Zahlen aus der Eingabeliste enthalten, abhängig vom Wert eines zweiten Arguments even. Wenn even gleich True ist (Standardwert), soll die Funktion eine Liste mit geraden Zahlen zurückgeben; wenn even gleich False ist, soll sie eine Liste mit ungeraden Zahlen zurückgeben."
  },
  {
    "objectID": "a1/a1.html#übung-41",
    "href": "a1/a1.html#übung-41",
    "title": "Übungen",
    "section": "Übung 41",
    "text": "Übung 41\nVerwenden Sie eine Schleife, um den Text \"Hello number X!\" 10 Mal auszugeben, wobei X die aktuelle Iterationsnummer ist (beginnend bei 1). Die Ausgabe sollte wie folgt aussehen:\nHello number 1!\nHello number 2!\nHello number 3!\nHello number 4!\nHello number 5!\nHello number 6!\nHello number 7!\nHello number 8!\nHello number 9!\nHello number 10!"
  },
  {
    "objectID": "a1/a1.html#übung-42",
    "href": "a1/a1.html#übung-42",
    "title": "Übungen",
    "section": "Übung 42",
    "text": "Übung 42\nDefinieren Sie zwei Funktionen ps_to_kw und kw_to_ps, die zwischen Pferdestärken (PS) und Kilowatt (kW) umrechnen. 1 kW entspricht ungefähr 1.36 PS. Die Funktion ps_to_kw soll eine Leistung in PS in kW zurückgeben, während kw_to_ps eine Leistung in kW in PS zurückgeben soll.\nTesten Sie Ihre Funktionen mit den folgenden Argumenten:\n&gt;&gt;&gt; ps_to_kw(100)\n73.52941176470588\n&gt;&gt;&gt; kw_to_ps(73.53)\n100.00080000000001"
  },
  {
    "objectID": "a1/a1.html#übung-43",
    "href": "a1/a1.html#übung-43",
    "title": "Übungen",
    "section": "Übung 43",
    "text": "Übung 43\nGegeben sei der String s = \"supercalifragilisticexpialidocious\". Verwenden Sie geeignete String-Methoden oder eingebaute Funktionen, um folgendes herauszufinden:\n\nDie Länge des Strings.\nDen Index der ersten Vorkommen des Buchstabens \"i\".\nDen Index der zweiten Vorkommen des Buchstabens \"i\".\nDie Anzahl der Vorkommen des Buchstabens \"i\" im String.\nEinen neuen String, der alle Zeichen in s in Großbuchstaben umwandelt.\nEinen neuen String, der alle Vorkommen des Buchstabens \"i\" durch \"!\" ersetzt.\n\n\n\n\n\n\n\nHinweis\n\n\n\nDefinieren Sie für die Lösung dieser Aufgabe keine eigenen Funktionen!"
  },
  {
    "objectID": "a1/a1.html#übung-44",
    "href": "a1/a1.html#übung-44",
    "title": "Übungen",
    "section": "Übung 44",
    "text": "Übung 44\nSchreiben Sie eine Funktion longest_word, die einen String sentence als Eingabe erhält und das längste Wort in diesem String zurückgibt. Falls es mehrere längste Wörter mit derselben Länge gibt, soll einfach das erste längste Wort zurückgegeben werden. Testen Sie Ihre Funktion mit dem Satz \"The quick brown fox jumps over the lazy dog\" (das längste Wort in diesem Satz ist \"quick\").\n\n\n\n\n\n\nHinweis\n\n\n\nVerwenden Sie die String-Methode split(), um den String sentence in einzelne Wörter aufzuteilen. Sie können davon ausgehen, dass der Eingabestring nur alphabetische Zeichen und Leerzeichen enthält (keine Satzzeichen, Zahlen oder Sonderzeichen). Iterieren Sie dann über alle gefundenen Wörter, um das längste zu finden und zurückzugeben."
  },
  {
    "objectID": "a1/a1.html#übung-45",
    "href": "a1/a1.html#übung-45",
    "title": "Übungen",
    "section": "Übung 45",
    "text": "Übung 45\nErzeugen Sie eine Liste, welche die Wurzeln der geraden Zahlen im Bereich von 300 bis 700 (beides inklusive) beinhaltet. Bestimmen Sie die Anzahl der Elemente sowie die Summe aller Elemente!"
  },
  {
    "objectID": "a1/a1.html#übung-46",
    "href": "a1/a1.html#übung-46",
    "title": "Übungen",
    "section": "Übung 46",
    "text": "Übung 46\nDefinieren Sie eine Funktion count_lower, die die Anzahl der Kleinbuchstaben in einem String zählt und diese Anzahl zurückgibt (der String soll als Argument übergeben werden). Verwenden Sie die String-Methode islower, um jedes einzelne Zeichen im String zu überprüfen.\nRufen Sie Ihre Funktion mit den folgenden Argumenten auf und überprüfen Sie, ob die Ausgaben korrekt sind:\n&gt;&gt;&gt; count_lower(\"Hello World!\")\n8\n&gt;&gt;&gt; count_lower(\"WHAT IS GOING ON???\")\n0\n&gt;&gt;&gt; count_lower(\"nnYzKllLSIkcJD4eEx\")\n9"
  },
  {
    "objectID": "a1/a1.html#übung-47",
    "href": "a1/a1.html#übung-47",
    "title": "Übungen",
    "section": "Übung 47",
    "text": "Übung 47\nDefinieren Sie eine Funktion check_parity, die überprüft, ob eine Zahl (als Argument übergeben) gerade oder ungerade ist. Der Rückgabewert soll wie folgt bestimmt werden:\n\nIst das Argument gerade, soll die Funktion 0 zurückgeben.\nIst das Argument ungerade, soll die Funktion 1 zurückgeben.\n\nTesten Sie Ihre Funktion mit den folgenden Argumenten und überprüfen Sie, ob die Ausgaben korrekt sind:\n&gt;&gt;&gt; check_parity(4)\n0\n&gt;&gt;&gt; check_parity(-7)\n1"
  },
  {
    "objectID": "a1/a1.html#übung-48",
    "href": "a1/a1.html#übung-48",
    "title": "Übungen",
    "section": "Übung 48",
    "text": "Übung 48\nErklären Sie, warum der folgende Code nicht funktioniert:\ndef lambda(x):\n    return x + 1\nGeben Sie eine korrekte Implementierung an!"
  },
  {
    "objectID": "a1/a1.html#übung-49",
    "href": "a1/a1.html#übung-49",
    "title": "Übungen",
    "section": "Übung 49",
    "text": "Übung 49\nDefinieren Sie zwei Funktionen cm_to_inches und inches_to_cm, die Zentimeter in Zoll und umgekehrt umrechnen. Die Umrechnungsfaktoren sind 1 Zoll = 2.54 cm und 1 cm = 1 / 2.54 Zoll. Testen Sie Ihre Funktionen mit den folgenden Argumenten und überprüfen Sie, ob die Ausgaben korrekt sind:\n&gt;&gt;&gt; cm_to_inches(10)\n3.937007874015748\n&gt;&gt;&gt; inches_to_cm(5)\n12.7\n&gt;&gt;&gt; cm_to_inches(inches_to_cm(5))\n5.0"
  },
  {
    "objectID": "a1/a1.html#übung-50",
    "href": "a1/a1.html#übung-50",
    "title": "Übungen",
    "section": "Übung 50",
    "text": "Übung 50\nDefinieren Sie eine Funktion sum_squares, die die Summe der Quadrate der in einer Liste enthaltenen Zahlen (als Argument übergeben) berechnet und zurückgibt. Testen Sie Ihre Funktion mit der folgenden Liste und überprüfen Sie, ob die Ausgabe korrekt ist:\n&gt;&gt;&gt; sum_squares([1, 2, 3, 4, 5])\n55"
  },
  {
    "objectID": "a1/a1.html#übung-51",
    "href": "a1/a1.html#übung-51",
    "title": "Übungen",
    "section": "Übung 51",
    "text": "Übung 51\nErzeugen Sie die folgenden drei NumPy-Arrays x, y und z:\n\nx soll 1000 normalverteilte Zufallszahlen mit einem Mittelwert von 10 und einer Standardabweichung von 2 enthalten.\ny soll 1000 gleichmäßig verteilte Zufallszahlen im Bereich von 5 bis 15 enthalten.\nz soll 1000 Chi-Quadrat-verteilte Zufallszahlen mit 6 Freiheitsgraden enthalten.\n\nInitialisieren Sie den Zufallszahlengenerator mit dem Wert 1.\nVerwenden Sie anschließend Matplotlib, um eine Grafik bestehend aus drei Streudiagrammen in einer Zeile zu erstellen. Das linke Streudiagramm soll x gegen y, das mittlere x gegen z und das rechte y gegen z darstellen. Setzen Sie abschließend fig.set_tight_layout(True) für ein schöneres Layout.\n\n\n\n\n\n\nHinweis\n\n\n\nZur Erzeugung der Zufallszahlen benötigen Sie die Methoden normal, uniform und chisquare des Zufallszahlengenerators."
  },
  {
    "objectID": "a1/a1.html#übung-52",
    "href": "a1/a1.html#übung-52",
    "title": "Übungen",
    "section": "Übung 52",
    "text": "Übung 52\nEine Primzahl ist eine natürliche Zahl größer als 1, die keine positiven Teiler außer 1 und sich selbst hat. Schreiben Sie eine Funktion is_prime, die überprüft, ob eine gegebene Zahl eine Primzahl ist oder nicht. Die Funktion soll True oder False zurückgeben. Testen Sie Ihre Funktion mit den Zahlen 7 und 10 (die Funktion sollte für die erste Zahl True und für die zweite Zahl False zurückgeben).\n\n\n\n\n\n\nHinweis\n\n\n\nDer Modulo-Operator % könnte im Zusammenhang mit der Tatsache, dass eine Primzahl nur durch 1 und sich selbst teilbar ist, hilfreich sein. Sie könnten also überprüfen, ob die Zahl \\(n\\) durch irgendeine Zahl zwischen 2 und \\(n - 1\\) teilbar ist. Falls ja, ist \\(n\\) keine Primzahl (sonst schon)."
  },
  {
    "objectID": "a1/a1.html#übung-53",
    "href": "a1/a1.html#übung-53",
    "title": "Übungen",
    "section": "Übung 53",
    "text": "Übung 53\nDefinieren Sie eine Funktion f, welche eine beliebige positive ganze Zahl entgegennimmt und sich wie folgt verhält:\n\nFalls die Zahl gerade ist, soll die Hälfte dieser Zahl zurückgegeben werden (verwenden Sie hier den Ganzzahl-Divisionsoperator).\nFalls die Zahl ungerade ist, soll das um 1 erhöhte Dreifache der Zahl zurückgegeben werden.\n\nRufen Sie diese Funktion mit der Zahl 1000 auf. Danach rufen Sie die Funktion erneut auf, und zwar mit dem Rückgabewert des ersten Funktionsaufrufs. Wiederholen Sie diese Prozedur (den Rückgabewert als neues Argument verwenden), bis die Funktion die Zahl 1 zurückgibt. Wie oft wird die Funktion insgesamt aufgerufen?\n\n\n\n\n\n\nHinweis\n\n\n\nVerwenden Sie für den zweiten Teil der Aufgabenstellung eine while-Schleife!"
  },
  {
    "objectID": "a1/a1.html#übung-54",
    "href": "a1/a1.html#übung-54",
    "title": "Übungen",
    "section": "Übung 54",
    "text": "Übung 54\nErklären Sie, warum folgender Code nicht funktioniert:\ndef f:\n    return 42\nGeben Sie auch die korrekte Funktionsdefinition an!"
  },
  {
    "objectID": "a1/a1.html#übung-55",
    "href": "a1/a1.html#übung-55",
    "title": "Übungen",
    "section": "Übung 55",
    "text": "Übung 55\nGeben Sie mit Hilfe einer Schleife den folgenden Text am Bildschirm aus:\nCountdown starting now!\nt minus 10...\nt minus 9...\nt minus 8...\nt minus 7...\nt minus 6...\nt minus 5...\nt minus 4...\nt minus 3...\nt minus 2...\nt minus 1...\nt minus 0...\nLift-off!"
  },
  {
    "objectID": "a1/a1.html#übung-56",
    "href": "a1/a1.html#übung-56",
    "title": "Übungen",
    "section": "Übung 56",
    "text": "Übung 56\nDie F-Statistik berechnet sich mit folgender Formel:\n\\[F = \\frac{\\text{MSM}}{\\text{MSR}}\\]\nHier ist MSM die mittlere Modellquadratsumme und MSR die mittlere Residuenquadratsumme, welche sich wie folgt berechnen lassen:\n\\[\\text{MSM} = \\frac{\\text{SSM}}{p - 1}\\] \\[\\text{MSR} = \\frac{\\text{SSR}}{N - p}\\]\nDefinieren Sie eine Funktion f_statistic, welche den Wert der F-Statistik in Abhängigkeit von SSM (Modellquadratsumme), SSR (Residuenquadratsumme), p (Anzahl der Modellparameter) und N (Stichprobengröße) zurückgibt! Wie lautet der Wert von F für die konkreten Werte von 2452, 1688, 4 und 412 für SSM, SSR, p sowie n?"
  },
  {
    "objectID": "a1/a1.html#übung-57",
    "href": "a1/a1.html#übung-57",
    "title": "Übungen",
    "section": "Übung 57",
    "text": "Übung 57\nDefinieren Sie eine Funktion namens convert_celsius, welche eine Temperatur in °C (Grad Celsius) entweder in K (Kelvin) oder °F (Grad Fahrenheit) umwandelt und zurückgibt! Ob Kelvin oder Fahrenheit zurückgegeben werden soll, wird durch einen optionalen Parameter namens to bestimmt; dieser soll standardmäßig so gesetzt sein, dass die Temperatur in Kelvin zurückgegeben wird.\nDie Umrechnungsvorschriften lauten:\n\\[F = C \\cdot \\frac{9}{5} + 32\\] \\[K = C + 273.15\\]\nRufen Sie Ihre Funktion dann auf, um folgende Temperaturen umzuwandeln:\n\n100°C in K\n38°C in °F\n0°C in K"
  },
  {
    "objectID": "a1/a1.html#übung-58",
    "href": "a1/a1.html#übung-58",
    "title": "Übungen",
    "section": "Übung 58",
    "text": "Übung 58\nErklären Sie, warum folgender Code nicht funktioniert:\nsum = 0\nfor i in range(10):\n    sum += i\nsum([1, 2, 3, 4, 5])\nGeben Sie auch eine korrekte Implementierung an!"
  },
  {
    "objectID": "a1/a1.html#übung-59",
    "href": "a1/a1.html#übung-59",
    "title": "Übungen",
    "section": "Übung 59",
    "text": "Übung 59\nErklären Sie, warum folgender Code nicht funktioniert und geben Sie eine korrekte Lösung an:\nx = (2)  # create tuple with one element\nprint(x[0])  # access and print that element\nEs soll ein Tuple mit einem einzigen Element angelegt werden. Anschließend soll dieses Element per Indizierung am Bildschirm ausgegeben werden."
  },
  {
    "objectID": "a1/a1.html#übung-60",
    "href": "a1/a1.html#übung-60",
    "title": "Übungen",
    "section": "Übung 60",
    "text": "Übung 60\nSchreiben Sie eine Funktion describe_number, welche überprüft, ob eine per Argument übergebene ganze Zahl gleich 10, gerade oder ungerade ist. Ist sie gerade, soll die Zahl 1 zurückgegeben werden. Ist sie ungerade, soll 2 zurückgegeben werden. Ist die Zahl durch 10 teilbar, soll 10 zurückgegeben werden.\nRufen Sie anschließend Ihre Funktion mit den ganzen Zahlen von \\(-110\\) bis \\(230\\) (inklusive) auf und summieren Sie alle Rückgabewerte. Die korrekte Summe beträgt 826.\n\n\n\n\n\n\nHinweis\n\n\n\nZahlen, die durch 10 teilbar sind, sind auch gerade Zahlen. Dennoch soll für diese Zahlen immer 10 zurückgegeben werden (und nicht 1)."
  },
  {
    "objectID": "a1/a1.html#übung-61",
    "href": "a1/a1.html#übung-61",
    "title": "Übungen",
    "section": "Übung 61",
    "text": "Übung 61\nErklären Sie, warum folgender Code nicht funktioniert (er enthält zwei Fehler):\na = 3\nif a &lt; 10\n    print \"a is less than 10.\"\nGeben Sie auch den korrekten Code an!"
  },
  {
    "objectID": "a1/a1.html#übung-62",
    "href": "a1/a1.html#übung-62",
    "title": "Übungen",
    "section": "Übung 62",
    "text": "Übung 62\nDefinieren Sie eine Funktion f, welche zwei Parameter hat und damit folgenden mathematischen Ausdruck berechnet und zurückgibt:\n\\[\\sqrt{\\frac{s_1^2 + s_2^2}{2}}\\]\nRufen Sie anschließend Ihre Funktion mit Werten von \\(s_1 = 5\\) und \\(s_2 = 27\\) auf!"
  },
  {
    "objectID": "a1/a1.html#übung-63",
    "href": "a1/a1.html#übung-63",
    "title": "Übungen",
    "section": "Übung 63",
    "text": "Übung 63\nSchreiben Sie eine Funktion decibel, welche eine Zahl in die Einheit Dezibel umrechnet und zurückgibt. Es gibt zwei verschiedene Arten, diese Umrechnung für eine gegebene Zahl \\(x\\) durchzuführen:\n\n\\(10 \\cdot \\log_{10}(x)\\)\n\\(20 \\cdot \\log_{10}(x)\\)\n\nDie Funktion soll beide Varianten berechnen können – welche berechnet wird soll durch einen optionalen Parameter bestimmt werden können. Standardmäßig soll die Variante 1 durchgeführt werden. Die beiden möglichen Werte dieses Parameters sollen die Strings \"power\" (Variante 1) bzw. \"amplitude\" (Variante 2) sein.\nVerwenden Sie die Funktion log10 aus dem Modul math.\nHier einige Beispiele für mögliche Funktionsaufrufe:\n&gt;&gt;&gt; decibel(10)\n10.0\n&gt;&gt;&gt; decibel(10, \"amplitude\")\n20.0\n&gt;&gt;&gt; decibel(2, \"power\")\n3.010299956639812"
  },
  {
    "objectID": "01/01.html",
    "href": "01/01.html",
    "title": "1 – Grundlagen",
    "section": "",
    "text": "Dieser Kurs vermittelt die Grundlagen der Programmiersprache Python. Zunächst werden die wichtigsten Elemente der Sprache wie Schleifen, Funktionen, Bedingungen und grundlegende Datentypen vorgestellt. Nach einer ausführlichen Behandlung dieser Grundlagen lernen Sie auch, wie man Python für die Datenanalyse verwenden kann. Dabei werden sehr grundlegende Themen wie das Einlesen von Textdateien, das Arbeiten mit numerischen Daten und das Erstellen einfacher Grafiken behandelt. Abschließend werden Sie mit dem in der Psychologie populären Python-Paket PsychoPy einfache Experimente erstellen.\nFür diesen Kurs sind keinerlei Vorkenntnisse erforderlich. Sie werden die Grundlagen der Programmierung anhand praktischer Beispiele erlernen und können dieses Wissen anschließend auf die meisten anderen Programmiersprachen übertragen. Aufgrund der begrenzten Zeit werden nur grundlegende Python-Konzepte behandelt, aber diese bilden die Basis für alle weiterführenden Anwendungen. Sie werden somit ein solides Wissen über diese Grundlagen erwerben, um anschließend selbständig weiterführende Methoden zu erlernen."
  },
  {
    "objectID": "01/01.html#überblick",
    "href": "01/01.html#überblick",
    "title": "1 – Grundlagen",
    "section": "",
    "text": "Dieser Kurs vermittelt die Grundlagen der Programmiersprache Python. Zunächst werden die wichtigsten Elemente der Sprache wie Schleifen, Funktionen, Bedingungen und grundlegende Datentypen vorgestellt. Nach einer ausführlichen Behandlung dieser Grundlagen lernen Sie auch, wie man Python für die Datenanalyse verwenden kann. Dabei werden sehr grundlegende Themen wie das Einlesen von Textdateien, das Arbeiten mit numerischen Daten und das Erstellen einfacher Grafiken behandelt. Abschließend werden Sie mit dem in der Psychologie populären Python-Paket PsychoPy einfache Experimente erstellen.\nFür diesen Kurs sind keinerlei Vorkenntnisse erforderlich. Sie werden die Grundlagen der Programmierung anhand praktischer Beispiele erlernen und können dieses Wissen anschließend auf die meisten anderen Programmiersprachen übertragen. Aufgrund der begrenzten Zeit werden nur grundlegende Python-Konzepte behandelt, aber diese bilden die Basis für alle weiterführenden Anwendungen. Sie werden somit ein solides Wissen über diese Grundlagen erwerben, um anschließend selbständig weiterführende Methoden zu erlernen."
  },
  {
    "objectID": "01/01.html#was-ist-python",
    "href": "01/01.html#was-ist-python",
    "title": "1 – Grundlagen",
    "section": "Was ist Python?",
    "text": "Was ist Python?\nPython ist eine universelle Programmiersprache, welche in vielen verschiedenen Anwendungsgebieten eingesetzt werden kann. Im Gegensatz dazu gibt es spezialisierte Programmiersprachen (wie z.B. R), welche für sehr spezifische Aufgaben entwickelt wurden. Beide Ansätze haben Vor- und Nachteile: Spezialisierte Programmiersprachen erlauben es oft, bestimmte Aufgaben schneller, besser oder eleganter zu lösen als universelle Programmiersprachen. Universelle Programmiersprachen sind dafür vielseitiger einsetzbar, was auch den Vorteil hat, dass man nicht unbedingt mehrere Programmiersprachen erlernen muss. Python deckt nicht nur Datenanalyse und Statistik ab, sondern auch komplett andere Anwendungen wie z.B. Webapplikationen, das Erstellen von Programmen mit grafischen Benutzeroberflächen oder auch das Programmieren des Raspberry Pi.\nWichtig ist auf jeden Fall, dass man sich vorher überlegt, welche Programmiersprache für ein gegebenes Problem geeignet ist, denn es gibt keine “beste” Programmiersprache, die für alle Anwendungsfälle optimal ist.\n\n\n\n© xkcd, CC BY-NC 2.5\n\n\nPython wird oft mit den folgenden Eigenschaften beschrieben:\n\nEinfach und elegant\nOpen Source (nicht nur gratis, sondern auch offen, da der Quellcode frei verfügbar ist)\nPlattformübergreifend (läuft auf Windows, macOS und Linux)\nUniverselle Programmiersprache mit vielen Anwendungsgebieten\nUmfangreiche Standardbibliothek, welche viele nützliche Funktionen und Werkzeuge enthält und direkt mit Python mitgeliefert wird\nExtrem viele Zusatzpakete, die weitere Funktionalität bereitstellen\nRiesige und aktive Community"
  },
  {
    "objectID": "01/01.html#popularität",
    "href": "01/01.html#popularität",
    "title": "1 – Grundlagen",
    "section": "Popularität",
    "text": "Popularität\nPython wurde bereits 1991 von Guido van Rossum veröffentlicht und hat gerade in den letzten Jahren enorm an Popularität gewonnen. Bereits seit einiger Zeit ist Python die beliebteste bzw. meistverwendete Programmiersprache weltweit (siehe beispielsweise PYPL, TIOBE und IEEE Spectrum Top Programming Languages). Außerdem zeigt die Stack Overflow Developer Survey 2025, dass Python nach wie vor sehr stark wächst und sehr gefragt ist.\nIn der Praxis ist die Popularität einer Programmiersprache durchaus relevant, denn je größer und aktiver die Community einer Sprache ist, desto einfacher wird es, bestehende Lösungen für Probleme zu finden oder Antworten auf neue Fragen zu bekommen."
  },
  {
    "objectID": "01/01.html#wie-sieht-python-code-aus",
    "href": "01/01.html#wie-sieht-python-code-aus",
    "title": "1 – Grundlagen",
    "section": "Wie sieht Python-Code aus?",
    "text": "Wie sieht Python-Code aus?\nIm Folgenden sehen Sie einige Beispiele für Python-Code. Manche Befehle sind vielleicht intuitiv verständlich, andere wiederum können durchaus verwirrend wirken. Alle Beispiele werden aber im Laufe der Lehrveranstaltung erklärt, im Moment sollen diese nur der Veranschaulichung dienen.\nDie grauen Kästchen zeigen Python-Befehle, unmittelbar darunter folgt das Ergebnis des jeweiligen Befehls.\n\nprint(\"Hello World!\")\n\nHello World!\n\n\n\n\"only lowercase letters\".upper()\n\n'ONLY LOWERCASE LETTERS'\n\n\n\nfor i in range(10):\n    print(i, end=\", \")\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9, \n\n\n\nprint(\", \".join([str(i) for i in range(10)]))\n\n0, 1, 2, 3, 4, 5, 6, 7, 8, 9\n\n\n\n[k**2 for k in range(0, 100, 10)]\n\n[0, 100, 400, 900, 1600, 2500, 3600, 4900, 6400, 8100]"
  },
  {
    "objectID": "01/01.html#installation",
    "href": "01/01.html#installation",
    "title": "1 – Grundlagen",
    "section": "Installation",
    "text": "Installation\nDie offizielle Python-Website enthält viele nützliche Informationen rund um Python. Im Download-Bereich findet man Installationspakete für Windows und macOS. Unter Windows installiert man den Python Install Manager, welchen man auch aus dem Microsoft Store beziehen kann. Weitere Informationen zur Verwendung von Python unter Windows finden Sie in der offiziellen Python-Dokumentation. Für weiterführende Informationen zur Verwendung von Python unter macOS lesen Sie bitte die offizielle Python-Dokumentation. Bei den meisten Linux-Distributionen ist Python bereits vorinstalliert, ansonsten kann man dieses sehr einfach über den Paketmanager der jeweiligen Distribution installieren.\n\n\n\n\n\n\nHinweis\n\n\n\nEs ist sinnvoll, stets die neueste Python-Version zu verwenden."
  },
  {
    "objectID": "01/01.html#erste-schritte",
    "href": "01/01.html#erste-schritte",
    "title": "1 – Grundlagen",
    "section": "Erste Schritte",
    "text": "Erste Schritte\nNachdem Sie Python installiert haben, können Sie den sogenannten Python-Interpreter starten. Dabei handelt es sich um ein Programm, welches Python-Befehle verstehen und verarbeiten kann. Man kann mit dem Python-Interpreter auch interaktiv arbeiten. Dies bedeutet, dass man einen Befehl eintippt und mit der Eingabetaste bestätigt. Danach wird der eingegebene Befehl direkt verarbeitet und das Ergebnis ausgegeben.\nEs gibt viele Möglichkeiten, den Python-Interpreter zu starten. Eine der einfachsten Methoden ist die Verwendung von IDLE, einer einfachen Lernumgebung für Python, die mit der Python-Installation mitgeliefert wird. Nach dem Start von IDLE öffnet sich ein Fenster mit dem Titel IDLE Shell, in dem der interaktive Python-Interpreter läuft. Ein sogenannter Prompt (die Symbole &gt;&gt;&gt;) zeigt an, dass der Interpreter bereit für Eingaben ist. Hier können wir also einen Python-Befehl eingeben und mit der Eingabetaste bestätigen. Der Interpreter verarbeitet den Befehl und gibt das Ergebnis (falls vorhanden) in der nächsten Zeile aus.\n\n\n\n\n\n\n\nHinweis\n\n\n\nIn den Kursunterlagen wird Python-Code immer in grauen Kästchen dargestellt. Der Prompt &gt;&gt;&gt; wird dabei weggelassen, da er nicht Teil des Python-Codes ist.\n\n\nVersuchen wir nun, mit Python einfache arithmetische Aufgaben zu lösen. Die Symbole für die vier Grundrechenarten sind + (Addition), - (Subtraktion), * (Multiplikation) und / (Division). Tippen Sie dazu die folgenden Befehle in die IDLE-Shell ein und bestätigen Sie jeweils mit der Eingabetaste:\n\n1 + 1\n\n2\n\n\n\n10 - 7\n\n3\n\n\n\n7 * 8\n\n56\n\n\n\n120 / 7\n\n17.142857142857142\n\n\n\n\n\n\n\n\nTipp\n\n\n\nAus Gründen der besseren Lesbarkeit sollten Leerzeichen vor und nach einem Operator eingefügt werden, also besser 10 - 7 und nicht 10-7. Für Python ist zwar beides korrekt, aber die erste Variante ist leichter lesbar.\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nBeachten Sie, dass Python die englische Zahlenschreibweise mit einem Punkt als Dezimaltrennzeichen verwendet und nicht das im deutschen Sprachraum übliche Komma. Dezimalzahlen müssen daher immer mit einem Punkt eingegeben werden, ganz egal welche Sprache im Betriebssystem eingestellt ist.\n\n\nDie ganzzahlige Division hat einen eigenen Operator //, der aus zwei Zeichen besteht:\n\n120 // 7\n\n17\n\n\nDer ganzzahlige Rest einer Division wird mit dem Rest-Operator % berechnet:\n\n120 % 7\n\n1\n\n\nPotenzieren (also eine Zahl hoch eine andere Zahl) ist ebenso möglich:\n\n2**64\n\n18446744073709551616\n\n\nPython kennt die Vorrangs- und Klammerregeln:\n\n(13 + 6) * 8 - 12 / (2.5 + 1.6)\n\n149.0731707317073\n\n\nWenn man mathematische Funktionen wie beispielsweise Sinus oder Kosinus verwenden möchte, muss man zuerst das math-Modul importieren (aktivieren). Dazu tippt man den folgenden Befehl ein:\n\nimport math\n\nDanach kann man eine Vielzahl an mathematischen Funktionen und Konstanten verwenden, z.B. sqrt (Quadratwurzel), log (Logarithmus), sin (Sinus), cos (Kosinus) sowie Konstanten wie pi (die Kreiszahl \\(\\pi\\)) oder e (Eulersche Zahl).\nWichtig ist, dass diese Funktionen und Konstanten immer mit einem vorangestellten math. verwendet werden müssen:\n\nmath.sqrt(2)\n\n1.4142135623730951\n\n\n\nmath.pi\n\n3.141592653589793\n\n\n\nmath.e\n\n2.718281828459045\n\n\n\n1 + math.sqrt(5) * 7 - 2 * math.pi * 1.222\n\n8.974423397125074\n\n\n\n\n\n\n\n\nTipp\n\n\n\nIn Python ist es notwendig, Module zu importieren, um deren Funktionen und Variablen verwenden zu können. Wir werden im Laufe dieses Kurses viele verschiedene Module importieren und verwenden."
  },
  {
    "objectID": "01/01.html#anwendungsbeispiele",
    "href": "01/01.html#anwendungsbeispiele",
    "title": "1 – Grundlagen",
    "section": "Anwendungsbeispiele",
    "text": "Anwendungsbeispiele\nPython wird heutzutage in vielen verschiedenen Bereichen verwendet. Um zu verdeutlichen, wie vielfältig man Python vor allem in der Forschung einsetzen kann, sind hier einige relevante Beispiele angeführt. Diese Auswahl ist jedoch bei weitem nicht vollständig und spiegelt vor allem meine persönliche Erfahrung wider.\n\nPräsentation von Stimuli\nPsychoPy ist ein Programm zur Präsentation von Stimuli für psychophysiologische Untersuchungen. Beispielsweise kann man mit PsychoPy Experimente erstellen, um Reaktionszeiten zu messen. Das Programm kann aber auch für fMRI- bzw. EEG-Untersuchungen verwendet werden, um die dort benötigten (visuellen bzw. auditorischen) Stimuli zeitpräzise zu präsentieren. PsychoPy kann über eine grafische Oberfläche bedient werden, aber spezielle Versuchsdesigns, die über die mitgelieferten Standardparadigmen hinausgehen, erstellt man am besten direkt mit Python-Code. Wir werden uns in den letzten beiden Einheiten mit PsychoPy beschäftigen.\n\n\n\nNeurowissenschaften\nPython ist sehr populär in den Neurowissenschaften. Auf der NIPY-Website (Neuroimaging for Python) haben sich einzelne Projekte zusammengeschlossen, welche spezifische Aufgaben im Bereich der Neurowissenschaften abdecken. Besonders viele Pakete gibt es für die Auswertung von fMRT-Daten. Hier gibt es z.B. NiBabel zum Einlesen verschiedenster Neuroimaging-Datenformate, Nipype zur einheitlichen Verwendung unterschiedlicher fMRT-Analyseprogramme, sowie NIPY, NiTime und Nilearn zur Analyse von fMRT-Daten.\n\nMNE-Python kann man zur Analyse von EEG- bzw. MEG-Signalen verwenden. Es werden eine Vielzahl an Methoden unterstützt, welche in der Verarbeitung von elektrophysiologischen Gehirnsignalen eine Rolle spielen, wie z.B. Filterung, Artefaktbereinigung, Quelllokalisation und Konnektivitätsanalysen. Es gibt auch eine grafische Oberfläche names MNELAB.\n\n\nStatistische Datenanalyse\nZur statistischen Auswertung von Daten gibt es in Python ebenfalls eine große Anzahl an Paketen. Besonders hervorzuheben sind hier NumPy, SciPy, Polars, pandas, statsmodels, Matplotlib, seaborn und scikit-learn. Einige dieser Pakete werden wir im Rahmen dieses Kurses kennenlernen (wenn auch nur sehr oberflächlich).\n\n\n\nGrafische Oberflächen\nIn Python kann man auch eigenständige Programme mit grafischen Oberflächen erstellen. Ein Beispiel dafür ist Spyder, eine Entwicklungsumgebung für Python, welche selbst komplett in Python geschrieben ist. Auch die grafischen Oberflächen von PsychoPy und MNELAB sind in Python geschrieben.\n\n\nAstronomie\nZwei sehr prominente Beispiele dürfen an dieser Stelle nicht fehlen: das erste Bild eines schwarzen Lochs (im Zentrum der etwa 55 Millionen Lichtjahre entfernten Galaxie Messier 87) wurde mit Hilfe von Python erzeugt:\n\n\n\n© EHT, CC BY 4.0\n\n\nAuch bei der Visualisierung des schwarzen Lochs Sagittarius A* im Zentrum unser eigenen Galaxie wurde Python verwendet:\n\n\n\n© EHT, CC BY 4.0"
  },
  {
    "objectID": "01/01.html#übungen",
    "href": "01/01.html#übungen",
    "title": "1 – Grundlagen",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nInstallieren Sie Python auf Ihrem Rechner. Starten Sie dann den Python-Interpreter. Welche Version von Python meldet der Interpreter? Ist dies die aktuellste Version?\n\n\nÜbung 2\nTippen Sie im Python-Interpreter import antigravity ein. Was passiert? Was geschieht, wenn Sie import this eingeben? Was bewirkt import math?\n\n\nÜbung 3\nDie Erde kann näherungsweise als Kugel mit einem Radius von 6371 km betrachtet werden. Berechnen Sie damit die Oberfläche der Erde! Die Formel für die Oberfläche \\(A\\) einer Kugel mit Radius \\(r\\) lautet:\n\\[A = 4 \\pi r^2\\]\n\n\nÜbung 4\nGegeben seien folgende Messwerte: 11, 27, 15, 10, 33, 18, 25, 22, 39, 11. Berechnen Sie den arithmetischen sowie den geometrischen Mittelwert (unter Verwendung von Grundrechenarten). Führen Sie die Berechnung mit jeweils einem einzigen Befehl (ohne Zwischenergebnisse) durch.\nDie Formeln für den arithmetischen bzw. geometrischen Mittelwert lauten:\n\\[\\bar x = \\frac{1}{n} \\sum_{i=1}^n x_i\\]\n\\[\\bar x_g = \\sqrt[n]{\\prod_{i=1}^n x_i}\\]\n\n\n\n\n\n\nHinweis\n\n\n\nDie n-te Wurzel kann man auch als Potenz anschreiben, also \\(\\sqrt[n]{x}\\) ist gleichbedeutend mit \\(x^\\frac{1}{n}\\).\n\n\n\n\nÜbung 5\nBerechnen Sie das Ergebnis des folgenden Ausdrucks mit einem Befehl (in einer Zeile):\n\\[\\frac{(5^5 - \\pi) \\cdot \\frac{19}{3}}{\\sqrt{13} + 7^\\frac{2}{3}}\\]\n\n\n\n\n\n\nHinweis\n\n\n\nAchten Sie auf die Klammersetzung! Das richtige Ergebnis beträgt ungefähr 2722.\n\n\n\n\nÜbung 6\nWarum funktioniert der folgende Befehl nicht (unter der Annahme, dass vorher import math ausgeführt wurde)?\nmath.Sqrt(4)"
  },
  {
    "objectID": "10/10-solutions.html",
    "href": "10/10-solutions.html",
    "title": "10 – Lösungen",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n\nair = np.genfromtxt(\"airquality.csv\", delimiter=\",\", skip_header=1)\nair.shape  # 153 Zeilen, 6 Spalten\n\n(153, 6)"
  },
  {
    "objectID": "10/10-solutions.html#übung-1",
    "href": "10/10-solutions.html#übung-1",
    "title": "10 – Lösungen",
    "section": "",
    "text": "import numpy as np\nimport matplotlib.pyplot as plt\n\nair = np.genfromtxt(\"airquality.csv\", delimiter=\",\", skip_header=1)\nair.shape  # 153 Zeilen, 6 Spalten\n\n(153, 6)"
  },
  {
    "objectID": "10/10-solutions.html#übung-2",
    "href": "10/10-solutions.html#übung-2",
    "title": "10 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\n\nozone = air[:, 0]\nsolar = air[:, 1]\nwind = air[:, 2]\ntemp = air[:, 3]\nmonth = air[:, 4]\nday = air[:, 5]"
  },
  {
    "objectID": "10/10-solutions.html#übung-3",
    "href": "10/10-solutions.html#übung-3",
    "title": "10 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\nfig, ax = plt.subplots()\nax.hist(wind, edgecolor=\"white\")\nax.set_title(\"Wind (mph)\")"
  },
  {
    "objectID": "10/10-solutions.html#übung-4",
    "href": "10/10-solutions.html#übung-4",
    "title": "10 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\nfig, ax = plt.subplots()\nax.scatter(temp, wind, alpha=0.5)\nax.set_xlabel(\"Temperature (°F)\")\nax.set_ylabel(\"Wind (mph)\")"
  },
  {
    "objectID": "10/10-solutions.html#übung-5",
    "href": "10/10-solutions.html#übung-5",
    "title": "10 – Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\n\nfig, axes = plt.subplots(2, 2)  # 2 Zeilen, 2 Spalten\n\naxes[0, 0].scatter(ozone, solar, alpha=0.5)\naxes[0, 0].set(xlabel=\"Ozone (ppb)\", ylabel=\"Solar (lang)\")\n\naxes[0, 1].plot(temp)\naxes[0, 1].set_xlabel(\"Index\")\naxes[0, 1].set_ylabel(\"Temperature (°F)\")\n\naxes[1, 0].violinplot([temp[:31], temp[31:61], temp[61:92], temp[92:123], temp[123:]])\naxes[1, 0].set_xlabel(\"Month\")\naxes[1, 0].set_ylabel(\"Temperature (°F)\")\n\naxes[1, 1].scatter(wind, ozone, alpha=0.5)\naxes[1, 1].set_xlabel(\"Wind (mph)\")\naxes[1, 1].set_ylabel(\"Ozone (ppb)\")\n\nfig.set_tight_layout(True)"
  },
  {
    "objectID": "08/08-solutions.html",
    "href": "08/08-solutions.html",
    "title": "8 – Lösungen",
    "section": "",
    "text": "name = \"Anna\"\na = 7\nb = 13\nprint(f\"Hallo {name}! {a} / {b} ≈ {a / b:.3f}, oder?\")\n\nHallo Anna! 7 / 13 ≈ 0.538, oder?"
  },
  {
    "objectID": "08/08-solutions.html#übung-1",
    "href": "08/08-solutions.html#übung-1",
    "title": "8 – Lösungen",
    "section": "",
    "text": "name = \"Anna\"\na = 7\nb = 13\nprint(f\"Hallo {name}! {a} / {b} ≈ {a / b:.3f}, oder?\")\n\nHallo Anna! 7 / 13 ≈ 0.538, oder?"
  },
  {
    "objectID": "08/08-solutions.html#übung-2",
    "href": "08/08-solutions.html#übung-2",
    "title": "8 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\n\nstudents = [\n    {\"name\": \"Lukas\", \"score\": 87.5},\n    {\"name\": \"Maya\", \"score\": 42.0},\n    {\"name\": \"Anna\", \"score\": 59.0},\n    {\"name\": \"Tim\", \"score\": 49.9},\n    {\"name\": \"Zoe\", \"score\": 100.0},\n]\n\nfor i, s in enumerate(students, 1):\n    if s[\"score\"] &gt;= 50:\n        status = \"PASS\"\n    else:\n        status = \"FAIL\"\n    print(f\"{i:2d} | {s['name']:&lt;12} | {s['score']:6.1f} | {status}\")\n\n 1 | Lukas        |   87.5 | PASS\n 2 | Maya         |   42.0 | FAIL\n 3 | Anna         |   59.0 | PASS\n 4 | Tim          |   49.9 | FAIL\n 5 | Zoe          |  100.0 | PASS"
  },
  {
    "objectID": "08/08-solutions.html#übung-3",
    "href": "08/08-solutions.html#übung-3",
    "title": "8 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\nlst = range(0, 101, 2)\n\nwith open(\"ex1.txt\", \"w\") as f:\n    f.write(\"\\n\".join([str(x) for x in lst]))"
  },
  {
    "objectID": "08/08-solutions.html#übung-4",
    "href": "08/08-solutions.html#übung-4",
    "title": "8 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\nwith open(\"ex2.txt\", \"w\") as f:\n    f.write(\",\".join([str(x) for x in lst]))"
  },
  {
    "objectID": "08/08-solutions.html#übung-5",
    "href": "08/08-solutions.html#übung-5",
    "title": "8 – Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\n\nwith open(\"sowpods.txt\") as f:\n    for _ in range(6):  # skip the first 6 lines\n        f.readline()\n    counter = 0\n    for line in f:\n        if len(line.strip()) &gt; 0:  # there are empty lines in the file!\n            counter += 1\n\nprint(f\"There are {counter} words in the Scrabble list.\")\n\nThere are 267752 words in the Scrabble list."
  },
  {
    "objectID": "08/08-solutions.html#übung-6",
    "href": "08/08-solutions.html#übung-6",
    "title": "8 – Lösungen",
    "section": "Übung 6",
    "text": "Übung 6\n\nwith open(\"sowpods.txt\") as f:\n    for _ in range(6):  # skip the first 6 lines\n        f.readline()\n    counter = 0\n    for line in f:\n        if len(line.strip()) &gt; 14:\n            counter += 1\n            # print(line.strip())  # print words with 15+ letters\n\nprint(f\"There are {counter} words with 15+ letters in the Scrabble list.\")\n\nThere are 5757 words with 15+ letters in the Scrabble list.\n\n\nWenn Sie die langen Wörter ausgeben lassen möchten, entfernen Sie einfach das Kommentarzeichen vor der print-Anweisung innerhalb der Schleife."
  },
  {
    "objectID": "03/03.html",
    "href": "03/03.html",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "",
    "text": "Alles in Python ist ein Objekt. Ein Objekt hat einen bestimmten Wert, z.B.\n\n1\n\n1\n\n\n\n2.15\n\n2.15\n\n\n\n\"Hallo\"\n\n'Hallo'\n\n\n\n\"3\"\n\n'3'\n\n\n\n\n\n\n\n\nTipp\n\n\n\nPython gibt im interaktiven Modus Werte automatisch aus.\n\n\nJedes Objekt hat neben einem Wert auch einen bestimmten Typ. Mit type kann man den Typ eines beliebigen Objekts herausfinden:\n\ntype(1)\n\nint\n\n\n\ntype(2.15)\n\nfloat\n\n\n\ntype(\"Hallo\")\n\nstr\n\n\n\ntype(\"3\")\n\nstr\n\n\nMan kann sich ein Objekt als eine Entität eines bestimmten Typs vorstellen, die einen bestimmten Wert hat und im Speicher des Computers lebt:\n\n\n\nEin Python-Objekt.\n\n\nJedes Objekt hat auch einen eindeutigen Identifikator. Mit der Funktion id kann man diesen herausfinden:\n\nid(3)\n\n140533325670832\n\n\n\nid(4)\n\n140533325670864\n\n\nDie tatsächlichen Identifikationsnummern sind irrelevant (und sehr wahrscheinlich von Sitzung zu Sitzung unterschiedlich). Es ist nur wichtig, ob zwei Identifikationsnummern in einer laufenden Python-Sitzung identisch sind oder nicht. Im vorherigen Beispiel hat das Objekt 3 eine andere Identifikationsnummer als das Objekt 4, daher wissen wir, dass dies zwei verschiedene Objekte sind."
  },
  {
    "objectID": "03/03.html#objekte-werte-und-typen",
    "href": "03/03.html#objekte-werte-und-typen",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "",
    "text": "Alles in Python ist ein Objekt. Ein Objekt hat einen bestimmten Wert, z.B.\n\n1\n\n1\n\n\n\n2.15\n\n2.15\n\n\n\n\"Hallo\"\n\n'Hallo'\n\n\n\n\"3\"\n\n'3'\n\n\n\n\n\n\n\n\nTipp\n\n\n\nPython gibt im interaktiven Modus Werte automatisch aus.\n\n\nJedes Objekt hat neben einem Wert auch einen bestimmten Typ. Mit type kann man den Typ eines beliebigen Objekts herausfinden:\n\ntype(1)\n\nint\n\n\n\ntype(2.15)\n\nfloat\n\n\n\ntype(\"Hallo\")\n\nstr\n\n\n\ntype(\"3\")\n\nstr\n\n\nMan kann sich ein Objekt als eine Entität eines bestimmten Typs vorstellen, die einen bestimmten Wert hat und im Speicher des Computers lebt:\n\n\n\nEin Python-Objekt.\n\n\nJedes Objekt hat auch einen eindeutigen Identifikator. Mit der Funktion id kann man diesen herausfinden:\n\nid(3)\n\n140533325670832\n\n\n\nid(4)\n\n140533325670864\n\n\nDie tatsächlichen Identifikationsnummern sind irrelevant (und sehr wahrscheinlich von Sitzung zu Sitzung unterschiedlich). Es ist nur wichtig, ob zwei Identifikationsnummern in einer laufenden Python-Sitzung identisch sind oder nicht. Im vorherigen Beispiel hat das Objekt 3 eine andere Identifikationsnummer als das Objekt 4, daher wissen wir, dass dies zwei verschiedene Objekte sind."
  },
  {
    "objectID": "03/03.html#namen",
    "href": "03/03.html#namen",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "Namen",
    "text": "Namen\nNamen in Python sind nichts anderes als Namen für bestimmte Objekte (in anderen Programmiersprachen werden Namen meistens als Variablen bezeichnet). Mit dem Zuweisungsoperator = können wir einem Objekt einen Namen geben:\n\na = 1\n\nEinen Namen kann man sich als Etikett vorstellen, das an ein Objekt gehängt wird:\n\n\n\nDer Name a ist dem Objekt 1 zugeordnet. Ein weiteres Objekt 2.4 hat (noch) keinen Namen.\n\n\nIn Python kann man einen existierenden Namen jederzeit einem anderen Objekt zuweisen. Dabei verliert der Name seine Verbindung zum alten Objekt (im folgenden Beispiel hat das Objekt 1 danach keinen Namen mehr):\n\na = 2.4\n\n\n\n\nNun ist a dem Objekt 2.4 zugeordnet, und das Objekt 1 hat keinen Namen mehr.\n\n\nEin Objekt kann auch mehr als einen Namen haben:\n\nb = a\n\n\n\n\nJetzt hat das Objekt 2.4 zwei Namen a und b.\n\n\nWir können bestätigen, dass die Namen a und b auf dasselbe Objekt verweisen, indem wir ihre entsprechenden Identifikatoren überprüfen:\n\nid(a)\n\n140533212420176\n\n\n\nid(b)\n\n140533212420176\n\n\nTatsächlich sind sie identisch, es gibt also nur ein Objekt mit zwei Namen. Wenn wir überprüfen wollen, ob zwei Namen an ein und dasselbe Objekt gebunden sind, können wir auch das Schlüsselwort is als Abkürzung verwenden:\n\na is b\n\nTrue\n\n\nDer Typ eines Namens entspricht dem Typ des Objekts, auf das er verweist:\n\ntype(a)\n\nfloat\n\n\n\ntype(b)\n\nfloat\n\n\nWenn Python einen Namen verwendet, ersetzt es diesen Namen immer durch den Wert des entsprechenden Objekts. Außerdem wertet Python immer zuerst die rechte Seite einer Zuweisung aus, bevor es den Namen zuweist. Betrachten wir folgendes Beispiel:\n\nx = 11\n9 + x  # x wird zu 11 ausgewertet, dann wird 9 + 11 zu 20 ausgewertet\n\n20\n\n\nNun hat x immer noch den Wert 11:\n\nx\n\n11\n\n\nWir können jetzt den Namen x einem anderen Objekt 2 zuweisen:\n\nx = 2\n2 * x  # x wird zu 2 ausgewertet, dann wird 2 * 2 zu 4 ausgewertet\n\n4\n\n\nAn dieser Stelle hat x nach wie vor den Wert 2 (und nicht 4). Wir können x jedoch erneut zuweisen und sogar den alten Wert von x auf der rechten Seite der Zuweisung verwenden:\n\nx = 2 * x  # zuerst wird die rechte Seite zu 2 * 2 = 4 ausgewertet, dann wird x = 4 zugewiesen\nx\n\n4"
  },
  {
    "objectID": "03/03.html#gültige-und-gute-namen",
    "href": "03/03.html#gültige-und-gute-namen",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "Gültige und gute Namen",
    "text": "Gültige und gute Namen\n\nGrundregeln\nGültige Namen können Buchstaben (Groß- und Kleinbuchstaben), Ziffern und Unterstriche enthalten (aber ein Name darf nicht mit einer Ziffer beginnen). Zusätzlich gibt es noch PEP8, welches Empfehlungen zur Auswahl guter Namen enthält. Vorerst ist nur eine Konvention für uns wichtig, nämlich dass alle Namen in Kleinbuchstaben geschrieben werden sollten und, wenn nötig, auch Unterstriche enthalten dürfen, wie z.B. lower_case_with_underscores.\nNamen sollten Bedeutung vermitteln, daher sollte man anstelle eines generischen x oder i versuchen, einen Namen zu finden, der etwas über die beabsichtigte Verwendung aussagt. Außerdem ist es gute Praxis, englische (und nicht z.B. deutsche) Namen zu verwenden, da man nie weiß, wer den eigenen Code in Zukunft lesen wird.\nHier sind einige Beispiele für die Benennung eines Objekts, das die Anzahl der Schüler in einer Schulklasse darstellt:\n\nnumber_of_students_in_class = 23  # zu lang\nNumberOfStudents = 23  # falscher Stil, nicht mit Unterstrichen getrennt\nn_students = 23  # sehr gut\nn = 23  # wahrscheinlich zu kurz (aber manchmal OK)\n\n\n\nSchlüsselwörter\nEs gibt in Python vordefinierte Namen (sogenannte Schlüsselwörter oder englisch Keywords) – diese dürfen nicht als eigene Namen verwendet werden, da sie vom Python-Interpreter benötigt werden, um die Struktur eines Programmes zu erkennen. Mit folgenden Befehlen bekommt man eine Liste aller Schlüsselwörter:\n\nimport keyword\nkeyword.kwlist\n\n['False',\n 'None',\n 'True',\n 'and',\n 'as',\n 'assert',\n 'async',\n 'await',\n 'break',\n 'class',\n 'continue',\n 'def',\n 'del',\n 'elif',\n 'else',\n 'except',\n 'finally',\n 'for',\n 'from',\n 'global',\n 'if',\n 'import',\n 'in',\n 'is',\n 'lambda',\n 'nonlocal',\n 'not',\n 'or',\n 'pass',\n 'raise',\n 'return',\n 'try',\n 'while',\n 'with',\n 'yield']\n\n\nDas bedeutet zum Beispiel, dass man den Namen lambda nicht verwenden kann. Wenn man es doch tut, wird Python einen Fehler ausgeben:\n\nlambda = 7\n\n\n  Cell In[25], line 1\n    lambda = 7\n           ^\nSyntaxError: invalid syntax\n\n\n\n\n\n\nEingebaute Funktionen\nNeben Schlüsselwörtern gibt es aber auch sogenannte eingebaute Funktionen, die standardmäßig in Python verfügbar sind. Diese Funktionen kann man also ohne import direkt verwenden. Es ist nicht sinnvoll, diese Funktionen zu “überschreiben”, obwohl dies nicht explizit verboten ist. Eine Liste aller eingebauten Funktionen bekommt man mit folgendem Funktionsaufruf (beachten Sie, dass dir ebenfalls eine eingebaute Funktion ist):\ndir(__builtins__)\n\n\n\n\n\n\nTipp\n\n\n\nWenn man wirklich einen Namen einer eingebauten Funktion verwenden möchte, ist es besser, den Namen leicht zu verändern, z.B. indem man einen Unterstrich anhängt. Anstelle von lambda könnte man daher lambda_ verwenden."
  },
  {
    "objectID": "03/03.html#operatoren",
    "href": "03/03.html#operatoren",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "Operatoren",
    "text": "Operatoren\nOperatoren sind spezielle Symbole, mit denen man Berechnungen wie Additionen, Subtraktionen usw. durchführen kann, also z.B. +, -, *, /, **, //, %, usw. Wir haben einige Operatoren bereits bei der Verwendung von Python als Taschenrechner kennengelernt. Manche Operatoren benötigen zwei Operanden (z.B. die Multiplikation 2 * 3), andere brauchen hingegen nur einen einzigen Operanden (z.B. die Negierung -5). Solche Operatoren werden als binäre bzw. unäre Operatoren bezeichnet."
  },
  {
    "objectID": "03/03.html#ausdrücke",
    "href": "03/03.html#ausdrücke",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "Ausdrücke",
    "text": "Ausdrücke\nEin Ausdruck ist Code, der zu einem Wert ausgewertet (reduziert) werden kann. Das kann ein einzelner Wert (z.B. 42), ein Name (z.B. x) oder eine Kombination aus Werten, Namen und Operatoren (z.B. x + 2) sein. Hier sind einige Beispiele für Ausdrücke:\n\n17  # nur ein Wert\n\n17\n\n\n\n23 + 4**2 - 2  # vier Werte und drei Operatoren\n\n37\n\n\n\nn = 25  # eine Zuweisung ist kein Ausdruck!\n\n\nn + 5  # ein Name, ein Wert und ein Operator\n\n30\n\n\nPython reduziert einen Ausdruck immer auf einen einzigen Wert. Ein komplexerer Ausdruck wird schrittweise gemäß den Regeln der Operatorpräzedenz (z.B. Punkt- vor Strichrechnung) von links nach rechts ausgewertet. Wie bereits erwähnt, wertet Python zuerst die rechte Seite einer Zuweisung aus, bevor es einen Namen zuweist."
  },
  {
    "objectID": "03/03.html#anweisungen",
    "href": "03/03.html#anweisungen",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "Anweisungen",
    "text": "Anweisungen\nEine Anweisung ist eine Einheit Code, die Python ausführen kann. Dies ist eine recht breite Definition, und Anweisungen umfassen daher Ausdrücke als Sonderfall (ein Ausdruck ist also eine Anweisung mit einem Wert). Es gibt jedoch auch Anweisungen, die keinen Wert haben, wie z.B. eine Zuweisung. Hier sind zwei Beispiele für Anweisungen, die keine Ausdrücke sind:\n\nx = 13\nprint(\"Hello world!\")\n\nHello world!\n\n\nWenn man diese Anweisungen im interaktiven Interpreter ausführt, gibt es keine Ausgaben – der Grund dafür ist, dass diese beiden Anweisungen keine Werte haben, d.h. es gibt hier im interaktiven Modus des Python-Interpreters nichts, was ausgegeben werden könnte.\n\n\n\n\n\n\nHinweis\n\n\n\nDass der Aufruf der print-Funktion trotzdem eine Ausgabe am Bildschirm bewirkt, liegt an der Funktion, deren Zweck ja genau diese Ausgabe ist. Dies kann man sehen, wenn man dem Funktionsaufruf einen Namen zuweist:\n\ns = print(\"Python\")\n\nPython\n\n\nDer Typ des Wertes von print(\"Python\"), der ja jetzt den Namen s hat, ist also:\n\ntype(s)\n\nNoneType\n\n\nDamit ist also klar, dass print(\"Python\") keinen Wert hat (eigentlich None, denn in Python gibt es einen speziellen Wert None vom Typ NoneType, welcher für “kein Wert” steht)."
  },
  {
    "objectID": "03/03.html#datentypen",
    "href": "03/03.html#datentypen",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "Datentypen",
    "text": "Datentypen\nPython bringt eine Menge nützlicher Datentypen mit. Im Folgenden werden die wichtigsten Typen aufgelistet und kurz beschrieben. Eine ausführliche Behandlung ausgewählter (wichtiger) Datentypen folgt dann in den nächsten Einheiten.\n\nLogische Typen\nDer Typ bool wird für Vergleiche verwendet; es gibt nur zwei mögliche Werte, nämlich True und False.\n\nb = True\ntype(b)\n\nbool\n\n\n\nc = False\ntype(c)\n\nbool\n\n\n\n\nNumerische Typen\n\nint (Ganzzahlen)\nfloat (Dezimalzahlen)\ncomplex (Komplexe Zahlen)\n\n\na = 17\ntype(a)\n\nint\n\n\n\na = 23.221\ntype(a)\n\nfloat\n\n\nAufgrund der begrenzten Rechengenauigkeit, mit denen Computer Dezimalzahlen darstellen, kann es zu Rundungsfehlern kommen (Dezimalzahlen können im Allgemeinen nicht exakt repräsentiert werden). Beispiel:\n\n0.1 + 0.2\n\n0.30000000000000004\n\n\nMan sollte daher Dezimalzahlen nie miteinander vergleichen:\n\n0.1 + 0.2 == 0.3\n\nFalse\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nStatt Dezimalzahlen mit == zu vergleichen ist es besser, wenn man überprüft, ob der Unterschied zwischen den beiden Zahlen sehr klein ist. Dazu gibt es im math-Modul eine eigene Funktion math.isclose, die man wie folgt verwendet:\n\nimport math\n\nmath.isclose(0.1 + 0.2, 0.3)\n\nTrue\n\n\n\n\nBei Ganzzahlen ist ein Vergleich aber kein Problem, da diese Zahlen exakt repräsentiert werden.\nIn speziellen Anwendungsfällen benötigt man komplexe Zahlen, welche direkt von Python unterstützt werden. Die imaginäre Einheit wird durch j dargestellt.\n\na = 3 + 5.5j\ntype(a)\n\ncomplex\n\n\n\n\nSequenzen\nSequenzdatentypen können mehrere Elemente beinhalten. Folgende wichtige Sequenzdatentypen werden von Python unterstützt:\n\nstr (String bzw. Zeichenkette)\nlist (Liste)\ntuple (ähnlich wie list, kann aber nachträglich nicht mehr verändert werden)\nset (Ansammlung von unterschiedlichen Elementen, d.h. keine Duplikate)\n\n\ns = \"Python\"\ntype(s)\n\nstr\n\n\n\ns = 'String'\ntype(s)\n\nstr\n\n\n\nk = [1, 2, 18.33, \"Python\", 44]\ntype(k)\n\nlist\n\n\n\nt = 1, 2, 18.33, \"Python\", 44\ntype(t)\n\ntuple\n\n\n\ns = {1, 2, \"test\", \"test\", \"test\", 1, 2, 3}\ns\n\n{1, 2, 3, 'test'}\n\n\n\ntype(s)\n\nset\n\n\n\n\nZuordnungen\nDer Datentyp dict beinhaltet Wertepaare, also Schlüssel (Keys) und zugehörige Werte (Values). Dieser Mechanismus funktioniert ähnlich wie ein Wörterbuch, daher auch die englische Bezeichnung “dictionary”.\n\nd = {\"a\": 12, \"b\": 3.14, 5: \"Python\", \"c\": \"yes\"}\ntype(d)\n\ndict"
  },
  {
    "objectID": "03/03.html#übungen",
    "href": "03/03.html#übungen",
    "title": "3 – Namen, Ausdrücke, Anweisungen",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nGegeben seien folgende Anweisungen:\nwidth = 17\nheight = 12\ndelimiter = \".\"\nGeben Sie zu jedem der folgenden Ausdrücke dessen Wert und Typ an. Versuchen Sie zunächst, die Antworten durch Überlegen herauszufinden und verwenden Sie erst dann den Python-Interpreter zum Überprüfen Ihrer Antworten.\n\nwidth / 2\nheight / 3\nheight * 3\nheight * 3.0\ndelimiter * 5\n2 * (width + height) + 1.5\n12 + 3\n\"12 + 3\"\n\n\n\nÜbung 2\nWas ist der Unterschied zwischen einem Ausdruck und einer Anweisung? Führen Sie jeweils ein Beispiel an.\n\n\nÜbung 3\nWas sind Schlüsselwörter in Python und wie erhalten Sie eine Liste aller Schlüsselwörter? Was sind eingebaute Funktionen und wie erhalten Sie eine Liste aller eingebauten Funktionen? Was müssen Sie beim Erstellen von Namen im Zusammenhang mit diesen beiden Konzepten beachten?\nNennen Sie außerdem einige Richtlinien, wie man gute Namen erstellt. Führen Sie ein Beispiel für einen guten Namen an!\n\n\nÜbung 4\nWie groß ist die Oberfläche bzw. das Volumen einer Kugel mit einem Radius von \\(r=5\\)? Führen Sie die Berechnung mit Python durch und weisen Sie den Ergebnissen die Namen area bzw. volume zu. Verwenden Sie für den Radius den Namen r und setzen Sie den Wert von r auf 5.\n\n\n\n\n\n\nHinweis\n\n\n\nSie können die Zahl \\(\\pi\\) als math.pi verwenden, wenn Sie folgende Zeile ganz am Anfang Ihres Scripts hinzufügen:\nimport math\nDie Formel für die Oberfläche \\(A\\) einer Kugel lautet:\n\\[A = 4 \\pi r^2\\]\nDas Volumen \\(V\\) einer Kugel kann man mit folgender Formel berechnen:\n\\[V = \\frac{4}{3} \\pi r^3\\]\n\n\n\n\nÜbung 5\nMit welchem Befehl können Sie den Typ des Wertes True bestimmen? Um welchen Typ handelt es sich dabei? Welchen Typ hat der Name x, wenn Sie vorher x = \"True\" ausführen? Achtung: die Werte True und \"True\" in diesem Beispiel haben unterschiedliche Typen!\nWenn Sie in Übung 4 den Befehl import math ausgeführt haben, welchen Typ hat der Name math?"
  },
  {
    "objectID": "11/11.html",
    "href": "11/11.html",
    "title": "11 – PsychoPy (1)",
    "section": "",
    "text": "PsychoPy ist ein in Python geschriebenes Paket zur Erstellung von Experimenten in den Neurowissenschaften oder der experimentellen Psychologie. Es ist frei verfügbar (Open Source) und unterstützt zwei verschiedene Möglichkeiten Experimente zu erstellen:\n\nVisuelle Erstellung über eine grafische Oberfläche (GUI) namens Builder\nProgrammatische Erstellung mit Python-Code (z.B. mit dem mitgelieferten Editor namens Coder)\n\nErsteres erleichtert den Einstieg, da keinerlei Programmierwissen notwendig ist. Ein mit Builder erstelltes Experiment wird automatisch in Python-Code übersetzt, welcher dann ausgeführt werden kann. Obwohl viele Parameter des Experimentes grafisch angepasst werden können, ist es mit dem Builder mitunter schwierig, komplexere Designs umzusetzen. Dafür ist die zweite Möglichkeit gedacht – man kann die grafische Oberfläche auch komplett ignorieren und das Experiment direkt mit Python-Code erstellen, oder man verfeinert ein mit dem Builder erstelltes Experiment mit angepasstem Python-Code. Dazu sind allerdings sowohl grundlegende Python-Kenntnisse als auch Wissen über die Funktionsweise von PsychoPy notwendig.\nIn dieser Lehrveranstaltung werden wir beide Möglichkeiten kennenlernen. Zunächst werden wir die grafische Oberfläche Builder verwenden, um einfache Experimente zu erstellen. Im nächsten Kapitel werden wir dann den zugrundeliegenden Python-Code näher betrachten und Experimente direkt mit Python-Code erstellen."
  },
  {
    "objectID": "11/11.html#allgemeines",
    "href": "11/11.html#allgemeines",
    "title": "11 – PsychoPy (1)",
    "section": "",
    "text": "PsychoPy ist ein in Python geschriebenes Paket zur Erstellung von Experimenten in den Neurowissenschaften oder der experimentellen Psychologie. Es ist frei verfügbar (Open Source) und unterstützt zwei verschiedene Möglichkeiten Experimente zu erstellen:\n\nVisuelle Erstellung über eine grafische Oberfläche (GUI) namens Builder\nProgrammatische Erstellung mit Python-Code (z.B. mit dem mitgelieferten Editor namens Coder)\n\nErsteres erleichtert den Einstieg, da keinerlei Programmierwissen notwendig ist. Ein mit Builder erstelltes Experiment wird automatisch in Python-Code übersetzt, welcher dann ausgeführt werden kann. Obwohl viele Parameter des Experimentes grafisch angepasst werden können, ist es mit dem Builder mitunter schwierig, komplexere Designs umzusetzen. Dafür ist die zweite Möglichkeit gedacht – man kann die grafische Oberfläche auch komplett ignorieren und das Experiment direkt mit Python-Code erstellen, oder man verfeinert ein mit dem Builder erstelltes Experiment mit angepasstem Python-Code. Dazu sind allerdings sowohl grundlegende Python-Kenntnisse als auch Wissen über die Funktionsweise von PsychoPy notwendig.\nIn dieser Lehrveranstaltung werden wir beide Möglichkeiten kennenlernen. Zunächst werden wir die grafische Oberfläche Builder verwenden, um einfache Experimente zu erstellen. Im nächsten Kapitel werden wir dann den zugrundeliegenden Python-Code näher betrachten und Experimente direkt mit Python-Code erstellen."
  },
  {
    "objectID": "11/11.html#installation",
    "href": "11/11.html#installation",
    "title": "11 – PsychoPy (1)",
    "section": "Installation",
    "text": "Installation\nDa PsychoPy ein Python-Paket ist, kann es prinzipiell mit pip install psychopy installiert werden. Allerdings ist es durch die vielen und teilweise sehr spezifischen Abhängigkeiten von PsychoPy in der Praxis relativ aufwändig, eine funktionsfähige PsychoPy-Umgebung zu erhalten.\nDie offizielle Dokumentation beschreibt einige mögliche Installationsvarianten für unterschiedliche Betriebssysteme. In vielen Fällen ist es am einfachsten, die vorgefertigten Standalone-Pakete zu verwenden. Diese Pakete beinhalten eine komplette Python-Umgebung inklusive aller notwendigen Zusatzpakete, welche parallel zu einer eventuell bereits vorhandenen Python-Umgebung installiert werden können. Es gibt diese Standalone-Pakete sowohl für Windows als auch macOS. Für Linux werden keine Installer angeboten, hier muss man PsychoPy manuell installieren (es gibt aber PsychoPy Installation Script for Linux, welches die Installation automatisiert und daher drastisch vereinfacht)."
  },
  {
    "objectID": "11/11.html#builder",
    "href": "11/11.html#builder",
    "title": "11 – PsychoPy (1)",
    "section": "Builder",
    "text": "Builder\nNach dem Start von PsychoPy öffnen sich normalerweise drei unabhängige Fenster, nämlich die grafische Oberfläche Builder, der Code-Editor Coder sowie der Runner (welcher zum Starten von Experimenten dient).\nDas Builder-Fenster sollte nach dem Starten ungefähr so aussehen:\n\n\nFlow\nIm unteren Bereich (“Flow”) sieht man eine Übersicht über das gesamte Experiment, welches aus Routinen und Schleifen besteht. Momentan gibt es nur eine einzige Routine namens “trial” (als blaues Kästchen dargestellt).\n\n\nRoutinen\nDie Routinen sind im Hauptbereich des Programmfensters (“Routines”) mit einer Zeitleiste detailliert dargestellt. Wenn mehrere Routinen im Experiment vorhanden sind, werden diese in separaten Tabs visualisiert. Mit der Zeitleiste kann man nachvollziehen, wann bestimmte Komponenten in einer Routine aktiv sind.\n\n\nKomponenten\nKomponenten kann man einer Routine hinzufügen, indem man diese aus dem Bereich rechts auswählt. Es gibt viele unterschiedliche Komponenten, wie beispielsweise Text-Stimuli, Tastatur-Eingaben, Bild-Stimuli, Sound-Stimuli, usw."
  },
  {
    "objectID": "11/11.html#stroop-experiment",
    "href": "11/11.html#stroop-experiment",
    "title": "11 – PsychoPy (1)",
    "section": "Stroop-Experiment",
    "text": "Stroop-Experiment\nWenden wir uns jetzt aber einem praktischen Beispiel zu. Die folgenden Schritte demonstrieren, wie man mit PsychoPy Builder ein Experiment erstellt, welches den Stroop-Effekt misst.\n\nExperiment-Einstellungen\nZunächst sollte man grundlegende Eigenschaften in den “Experiment Settings” festlegen. Durch einen Klick auf das Icon mit dem Zahnrad (siehe Abbildung unten) öffnet sich ein Dialog, in dem man diverse Einstellungen für das Experiment vornehmen kann. Für unser Beispiel ändern wir den Namen auf “stroop” und löschen die zweite Zeile von “Experiment info” durch Klicken auf das Minus-Symbol ganz rechts in dieser Zeile. Dies bewirkt, dass vor dem Starten des Experiments nur der Name der Versuchsperson (“participant”) abgefragt wird.\nDas Dialogfenster sollte also wie folgt aussehen und kann durch Klicken auf OK bestätigt werden:\n\n\n\n\n\n\n\nTipp\n\n\n\nWährend man ein Experiment erstellt, sollte man den Vollbildmodus ausschalten (da es sonst teilweise nicht möglich ist, ein laufendes Experiment vorzeitig abzubrechen). Dies kann man in den Experiment Settings im Tab “Screen” tun, indem man die Option “Full-screen window” deaktiviert. Wenn das Experiment dann fertig ist, kann man den Vollbildmodus wieder aktivieren.\n\n\n\n\nRoutine “Instructions”\nBevor das eigentliche Experiment beginnt, sollte man eine kurze Erklärung am Bildschirm anzeigen. Dies setzen wir in einer eigenen Routine um – wir können die bereits vorhandene Routine “trial” (die ja noch keine Komponenten enthält) dafür verwenden.\nDurch einen Rechtsklick auf das blaue Routinen-Symbol und Auswahl von “rename” können wir einen neuen Namen vergeben – für dieses Beispiel verwenden wir instructions. Danach fügen wir einen Text-Stimulus aus der Komponenten-Ansicht hinzu, mit dem wir einen kurzen Text anzeigen können. Ein Klick auf die Text-Stimulus-Schaltfläche öffnet einen Dialog, in dem wir diverse Eigenschaften ändern können. Wichtige Punkte sind hier\n\nder Name,\ndie Start- und Stopp-Zeit,\ndie Textgröße sowie\nder eigentliche Text (die Instruktionen).\n\nDie Instruktionen sollen so lange angezeigt werden, bis die Leertaste gedrückt wird. Deswegen löschen wir die Zahl aus dem Eingabefeld “Stop” – dies bedeutet, dass der Stimulus unendlich lange angezeigt wird. Wir werden aber gleich mit einer weiteren Komponente das Beenden durch einen Tastendruck erzwingen. Die Eigenschaften des Text-Stimulus sollten wie folgt eingegeben werden:\n\nIn der Zeitleiste wird, nachdem man OK geklickt hat, der Text-Stimulus grafisch dargestellt. Man erkennt, dass dieser bei Sekunde 0 startet und kein Ende hat. Durch Klicken auf den Stimulus in der Zeitleiste können die Eigenschaften nachträglich verändert bzw. angepasst werden.\nUm die Routine per Tastendruck zu beenden und das eigentliche Experiment zu starten, fügen wir eine Keyboard-Komponente hinzu, welche Tastatureingaben aufzeichnen kann. In deren Eigenschaften vergeben wir wieder einen sinnvollen Namen (instructions_resp), lassen das Feld “Stop” leer, lassen das Häkchen bei “Force end of Routine” gesetzt (dies bewirkt, dass die gesamte Routine nach dem Drücken einer Taste beendet wird) und schreiben in die Liste der “Allowed keys” lediglich 'space' (dies bedeutet, dass nur die Leertaste die Routine beendet). Bei “Store” im Tab “Data” kann man “nothing” auswählen, da wir die Information, wann genau die Leertaste gedrückt wurde, nicht benötigen.\nDas PsychoPy-Fenster sollte nun wie folgt aussehen:\n\n\n\nAusführen des Experiments\nWir können nun bereits versuchen, das Experiment zu starten. Dazu klickt man auf das grüne “Run experiment” Icon. Nachdem unser Experiment noch nicht gespeichert ist, müssen wir dies nun tun (z.B. unter dem Namen stroop.psyexp). Danach öffnet sich der Runner-Dialog und das Experiment startet.\n\n\n\n\n\n\nWichtig\n\n\n\nUnter macOS muss man PsychoPy erlauben, den Computer zu steuern (sonst funktionieren die Experimente nicht). Dies kann man in den Systemeinstellungen im Bereich “Sicherheit & Datenschutz” tun, indem man im Tab “Datenschutz” unter “Bedienungshilfen” auf “PsychoPy” klickt (zuvor muss man auf das Schloss links unten klicken und das Administratorpasswort eingeben).\n\n\n\nWie erwartet erscheint zuerst ein Dialogfenster, in dem wir den Namen (bzw. den Code) der Versuchsperson eingeben müssen. Dieser Name wird in den von PsychoPy erstellten Dateien verwendet, welche alle Informationen über das Experiment automatisch abspeichern (also wann etwas passiert ist) – standardmäßig befinden sich diese Dateien im Unterordner data.\n\n\nRoutine “Task”\nNun soll das eigentliche Stroop-Experiment beginnen. Dazu erstellen wir eine neue Routine durch Klicken auf “Insert Routine” – “(new)”. Für die neue Routine vergeben wir den Namen trial. Danach klicken wir an das rechte Ende der Routine “instructions”, um “trial” direkt danach einzufügen. Durch Klicken auf die soeben erstellte Routine können wir dieser wieder Komponenten hinzufügen.\nSpätestens jetzt sollte man sich Gedanken über den exakten Ablauf des Experimentes machen. In unserem einfachen Stroop-Beispiel möchten wir nur die drei Farben rot, grün und blau verwenden. Die Wörter, die am Bildschirm erscheinen, sollen die englischen Begriffe “red”, “green” und “blue” sein. Die Versuchspersonen sollen mit den Tasten “r”, “g” und “b” die Farbe des Wortes angeben (und nicht den Text des Wortes). Wir möchten alle neun möglichen Kombinationen dieser Farben und Begriffe verwenden, also z.B. das rote Wort “red”, das grüne Wort “blue”, usw.\nDazu können wir alle möglichen Bedingungen in einer Excel-Tabelle zusammenfassen. Folgende Tabelle sollte in der Datei conditions.xlsx abgespeichert werden (Textformatierungen wie z.B. fett sollten nicht verwendet werden):\n\n\n\nword\ncolor\ncorrect\n\n\n\n\nred\nred\nr\n\n\nred\ngreen\ng\n\n\nred\nblue\nb\n\n\ngreen\nred\nr\n\n\ngreen\ngreen\ng\n\n\ngreen\nblue\nb\n\n\nblue\nred\nr\n\n\nblue\ngreen\ng\n\n\nblue\nblue\nb\n\n\n\nDie erste Zeile beinhaltet die Spaltennamen – diese Namen können wir dann in PsychoPy verwenden. Die erste Spalte beinhaltet den Text der am Bildschirm angezeigt werden soll, und die zweite Spalte bestimmt die Farbe des Textes. In der dritten Spalte halten wir den korrekten Tastendruck fest.\nUnsere Routine “trial” zeigt genau ein Wort an (mehr dazu gleich) – wir möchten diese Routine aber für jede Zeile in der Excel-Tabelle wiederholen. Dazu benötigen wir eine Schleife, die wir durch Klicken auf “Insert Loop” einfügen können. Als Startpunkt klicken wir auf den Punkt links von “trial”, und als Endpunkt auf den Punkt rechts von “trial”. Danach öffnet sich ein Dialog mit den Eigenschaften der Schleife. Hier können wir z.B. die Anzahl an Wiederholungen einstellen (standardmäßig ist hier 5 gesetzt, diesen Wert können wir beibehalten). Im Eingabefeld “Conditions” können wir nun durch Klicken auf das Ordner-Icon unsere Datei conditions.xlsx auswählen. Die neun Bedingungen und drei Parameter werden erkannt, und diese werden nach Klicken auf OK insgesamt fünf Mal wiederholt (d.h. das Experiment besteht aus insgesamt 45 Trials).\nDas PsychoPy-Fenster sollte jetzt in etwa so aussehen:\n\nNun müssen wir die Routine “trial” mit den benötigten Komponenten befüllen. Wir möchten die Wörter für jeweils eine Sekunde am Bildschirm anzeigen, daher fügen wir einen Text-Stimulus hinzu. Die Eigenschaften sollten wie folgt gesetzt werden:\n\n\nDer Clou an diesem Stimulus liegt in der Verwendung von Variablennamen, welche wir mit einem Dollar-Zeichen kennzeichnen können. Der darzustellende Text ist also nicht konstant, sondern wird durch den Inhalt der Variablen $word bestimmt. Wichtig ist hier, dass “set every repeat” ausgewählt ist, damit der Inhalt des Textes bei jeder Schleifenwiederholung aktualisiert wird. Wir können alle Spaltennamen aus der Datei conditions.xlsx als Variablen verwenden, $word bezieht sich hier also auf die erste Spalte mit diesem Namen.\nDie Textfarbe wird im Tab “Appearance” durch $color bestimmt (“set every repeat” muss auch ausgewählt sein) – color ist ebenso ein Spaltenname in der Datei conditions.xlsx.\nWir möchten außerdem das jeweilige Wort etwas größer am Bildschirm darstellen, deswegen ändern wir im Tab “Formatting” den Eintrag von “Letter height” auf 0.1.\nNun ist ein guter Zeitpunkt, das Experiment wieder auszuführen, um zu prüfen, ob und wie alles funktioniert. Nach den Instruktionen sollten dann \\(9 \\cdot 5 = 45\\) Wörter in verschiedenen Farben für jeweils 1 Sekunde am Bildschirm erscheinen.\nEs fehlt noch die Möglichkeit, Tastatureingaben als Antworten geben zu können. Dazu können wir eine Keyboard-Komponente mit folgenden Eigenschaften hinzufügen:\n\n\nDamit haben die Versuchspersonen 2 Sekunden Zeit, eine der drei Tasten r, g oder b zu drücken. Falls dies nicht geschieht, wird die Routine beendet und der nächste Schleifendurchlauf startet. Außerdem wird gespeichert, ob die Antwort korrekt war oder nicht – dies wird mit Hilfe der Spalte correct (aus des Excel-Datei) erreicht, die ja bereits die erwarteten korrekten Tasteneingaben enthält. Damit kann die erwartete Antwort mit der tatsächlichen Antwort verglichen werden – das Ergebnis dieses Vergleichs wird dann automatisch in die Ergebnisdateien gespeichert. Wir sollten auch den ersten Tastendruck (“first key”) speichern, da dieser für die Antwort relevant ist.\nWir können das Experiment speichern und ausführen – unser einfaches Stroop-Experiment sollte bereits funktionieren. Das Experiment sollte in PsychoPy in etwa so aussehen:\n\n\n\nAuswerten der Ergebnisse\nNachdem ein Experiment erfolgreich ausgeführt wurde, befinden sich im Ergebnisordner (standardmäßig ist das der Unterordner data) drei Dateien mit folgendem Inhalt:\n\nKompakte Informationen für jedes Trial (.csv-Datei)\nDetailliertere Informationen über den zeitlichen Ablauf des gesamten Experimentes (.log-Datei)\nFür das Debuggen relevante Informationen über das gesamte Experiment (.psydat-Datei)\n\nDie Namen dieser Dateien setzen sich normalerweise aus dem Probandencode, dem Experimentnamen, dem Datum sowie der Uhrzeit zusammen (dies kann aber in den Experiment-Einstellungen angepasst werden, falls man ein anderes Namensschema verwenden möchte).\n\n\n\n\n\n\nTipp\n\n\n\nAngenommen, wir hätten die folgende Aufzeichnung durchgeführt:\n\nFür den Probandencode wurde im Dialogfenster gleich nach dem Start des Experimentes s01 eingegeben.\nDer Name des Experimentes wurde in den Experiment-Einstellungen auf stroop gesetzt.\nDas Experiment wurde am 30. Oktober 2022 um 11:32 gestartet.\n\nDie drei Dateinamen lauten dann s01_stroop_2022-10-30_11h32.51.619 mit den Endungen .csv, .log und .psydat.\n\n\nÜblicherweise ist es ausreichend, die .csv-Datei zur Auswertung des Experimentes zu verwenden. Man kann diese Datei z.B. in Excel öffnen bzw. importieren. Eine Zeile entspricht einem bestimmten Trial im Experiment, die Spalten enthalten diverse Variablen. Die folgende Tabelle zeigt die für die Auswertung relevanten Spalten (in der Datei sind noch viel mehr zusätzliche Spalten enthalten, die für uns aber nicht von Interesse sind):\n\n\n\n\n\n\n\n\n\n\n\nword\ncolor\ncorrect\ntrial_key.keys\ntrial_key.corr\ntrial_key.rt\n\n\n\n\nred\nred\nr\nr\n1\n0.9099219\n\n\nred\nblue\nb\nb\n1\n1.0798603\n\n\ngreen\nblue\nb\ng\n0\n0.6511786\n\n\nblue\nred\nr\nr\n1\n1.377726\n\n\nblue\nblue\nb\nb\n1\n1.0776839\n\n\nred\ngreen\ng\nr\n0\n0.7208335\n\n\ngreen\nred\nr\nr\n1\n1.4581527\n\n\nblue\ngreen\ng\nb\n0\n1.0556199\n\n\ngreen\ngreen\ng\ng\n1\n1.5644918\n\n\nblue\nblue\nb\nb\n1\n0.6078371\n\n\nred\nred\nr\nr\n1\n0.574091\n\n\ngreen\nred\nr\nr\n1\n1.1114685\n\n\nred\ngreen\ng\nb\n0\n1.2182108\n\n\ngreen\ngreen\ng\ng\n1\n0.7759897\n\n\ngreen\nblue\nb\nb\n1\n1.0443643\n\n\nred\nblue\nb\nb\n1\n0.4471338\n\n\nblue\ngreen\ng\ng\n1\n0.8137774\n\n\nblue\nred\nr\nr\n1\n0.50785\n\n\nblue\nred\nr\nr\n1\n0.9630382\n\n\nred\nred\nr\nNone\n0\n\n\n\nblue\ngreen\ng\nNone\n0\n\n\n\ngreen\ngreen\ng\nNone\n0\n\n\n\ngreen\nblue\nb\nNone\n0\n\n\n\nred\nblue\nb\nNone\n0\n\n\n\ngreen\nred\nr\nr\n1\n0.4799467\n\n\nred\ngreen\ng\ng\n1\n0.5921032\n\n\nblue\nblue\nb\nb\n1\n0.5423042\n\n\ngreen\nred\nr\nr\n1\n0.9103351\n\n\nred\nblue\nb\nb\n1\n0.9621963\n\n\ngreen\nblue\nb\ng\n0\n0.7260921\n\n\nred\nred\nr\nr\n1\n1.0694482\n\n\nblue\nred\nr\nr\n1\n0.652598\n\n\nred\ngreen\ng\ng\n1\n1.2136657\n\n\nblue\nblue\nb\nr\n0\n0.761413\n\n\ngreen\ngreen\ng\ng\n1\n1.2664384\n\n\nblue\ngreen\ng\ng\n1\n0.4940767\n\n\ngreen\ngreen\ng\ng\n1\n0.4782196\n\n\nred\nred\nr\nr\n1\n0.4826069\n\n\ngreen\nblue\nb\nb\n1\n0.4881791\n\n\ngreen\nred\nr\nr\n1\n0.6130762\n\n\nblue\nred\nr\nr\n1\n0.4593343\n\n\nred\nblue\nb\nb\n1\n0.5275998\n\n\nblue\nblue\nb\nb\n1\n0.4871046\n\n\nblue\ngreen\ng\ng\n1\n0.6172059\n\n\nred\ngreen\ng\ng\n1\n0.4211524\n\n\n\nMan könnte nun beispielsweise die mittleren Reaktionszeiten (Spalte trial_key.rt) der kongruenten (Wort und Farbe stimmen überein) und inkongruenten (Wort und Farbei stimmen nicht überein) korrekt gelösten (Spalte trial_key.corr) Trials vergleichen."
  },
  {
    "objectID": "11/11.html#erweitertes-stroop-experiment",
    "href": "11/11.html#erweitertes-stroop-experiment",
    "title": "11 – PsychoPy (1)",
    "section": "Erweitertes Stroop-Experiment",
    "text": "Erweitertes Stroop-Experiment\nIn den folgenden Abschnitten wollen wir versuchen, das Stroop-Experiment um folgende zwei Features zu erweitern:\n\nAnzeigen eines Textes am Ende des Experimentes (z.B. könnte man sich bei den Versuchspersonen für die Teilnahme bedanken).\nFeedback nach jedem Trial, welches die Versuchspersonen informiert ob die gerade erfolgte Antwort korrekt oder inkorrekt war (oder zu langsam, falls sie nicht innerhalb von zwei Sekunden geantwortet haben).\n\n\nVerabschiedungstext\nUm einen Text am Ende des Experimentes anzuzeigen, können wir ähnlich wie bei den Instruktionen eine Routine mit einem Text-Stimulus erstellen, welcher so lange angezeigt wird, bis die Leertaste gedrückt wird.\n\n\nFeedback nach jedem Trial\nUm nach jedem Trial rückzumelden, ob die Versuchsperson die richtige Taste gedrückt hat, fügen wir direkt nach der Routine “trial” eine neue Routine namens “feedback” hinzu. Es ist wichtig, dass sich diese noch innerhalb der Schleife befindet, da wir das Feedback nach jedem Trial geben möchten. Da wir dazu einen Text anzeigen möchten, fügen wir einen Text-Stimulus names “feedback_text” hinzu. Weil wir keinen fixen Text anzeigen können, geben wir die Namen $msg bei Text bzw. $msg_color (im Tab “Appearance”) bei der Textfarbe an (bei beiden Feldern muss “set every repeat” gesetzt werden). Diese beiden Python-Objekte sollen den Text (“Correct!”, “Wrong!” oder “Too slow!”) sowie die zugehörigen Farben (grün, rot oder weiß) beinhalten – dies werden wir im nächsten Schritt implementieren.\n\nWir können Python-Objekte in einer Code-Komponente erstellen – dazu klickt man auf das entsprechende Icon in der Gruppe “Custom”. Im Dialogfeld kann man nun Python-Code einfügen.\nIn PsychoPy muss man alle Python-Objekte zu Beginn des Experimentes erstellen und z.B. auf Standardwerte setzen. Dazu fügt man im Abschnitt “Begin Experiment” folgenden Code ein:\nmsg = \"\"\nmsg_color = \"white\"\n\n\n\n\n\n\n\nHinweis\n\n\n\nDen Wert von “Code Type” können wir auf “Py” setzen, da wir unser Experiment nur mit Python erstellen wollen. PsychoPy unterstützt zusätzlich noch Javascript, was eine Ausführung des Experiments im Browser ermöglicht. Wir benötigen diese Funktionalität aber nicht.\n\n\nIm Abschnitt “Begin Routine” befindet sich der Code, der immer am Beginn der Routine ausgeführt wird:\nif trial_key.keys:\n    if trial_key.corr:\n        msg = \"Correct!\"\n        msg_color = \"green\"\n    else:\n        msg = \"Wrong!\"\n        msg_color = \"red\"\nelse:\n    msg = \"Too slow!\"\n    msg_color = \"white\"\n\nSehen wir uns an, wie dieser Code funktioniert. Wir verwenden hier die Keyboard-Komponente trial_key, welche wie jede Keyboard-Komponente zwei wichtige Eigenschaften (als Attribute) enthält:\n\ntrial_key.keys ist eine Liste, welche die im aktuellen Trial gedrückte Taste(n) enthält. Wurde noch keine Taste gedrückt, ist diese Liste leer.\ntrial_key.corr ist ein bool-Wert (also True oder False), welcher angibt, ob die gedrückte Taste richtig oder falsch ist.\n\nDie Bedingung if trial_key.keys überprüft, ob die Liste Elemente enthält oder leer ist. Dies ist eine abgekürzte und empfohlene Schreibweise, denn eine nicht-leere Liste entspricht dem bool-Wert True, und eine leere Liste entspricht dem bool-Wert False.\n\n\n\n\n\n\nTipp\n\n\n\nAngenommen, wir hätten x = True, dann wäre die Bedingung if x: äquivalent zu if x == True:. Ebenso wäre if not x: äquivalent zu if x == False:. In Python ist es üblich, Bedingungen so kompakt wie möglich zu formulieren, daher werden diese abgekürzten Schreibweisen empfohlen.\n\n\nWenn die Liste trial_key.keys also nicht leer ist, wurde eine Taste gedrückt, und der entsprechende Codezweig wird ausgeführt. Dieser besteht aus einer weiteren Bedingung, nämlich if trial_key.corr (auch das ist eine abgekürzte Schreibweise für if trial_key.corr == True). Dies bedeutet also, wenn die gedrückte Taste der korrekten Antwort entspricht, wird msg auf \"Correct!\" und msg_color auf \"green\" gesetzt. Falls die Taste nicht korrekt war, wird der else-Zweig ausgeführt (msg = \"Wrong!\" und msg_color = \"red\").\nDer abschließende else-Zweig wird nur ausgeführt, wenn keine Taste gedrückt wurde (also trial_key.keys leer ist). Dann werden msg und msg_color entsprechend gesetzt.\n\n\n\n\n\n\nWichtig\n\n\n\nEs ist wichtig, dass die Code-Komponente ganz am Beginn der Routine ausgeführt wird, d.h. sie muss sich auch ganz oben in der Zeitübersicht (über dem Text-Stimulus) befinden. Die Position in der Liste der Komponenten kann man verändern, wenn man auf eine Komponente rechtsklickt und z.B. “move to top” auswählt.\n\n\nDie fertige Feedback-Routine sollte dann so aussehen:\n\nUnser erweitertes Stroop-Experiment ist nun fertig und kann ausgeführt werden. Als Übung könnten Sie versuchen, zu Beginn jedes Trials einen kurzen Ton abzuspielen."
  },
  {
    "objectID": "11/11.html#übungen",
    "href": "11/11.html#übungen",
    "title": "11 – PsychoPy (1)",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nErstellen Sie das in den Unterlagen beschriebene Stroop-Experiment mit Feedback und führen Sie als Versuchsperson das Experiment durch. Berechnen Sie dann aus den Ergebnisdaten die mittleren Reaktionszeiten für korrekte kongruente und inkongruente Stimuli!\n\n\nÜbung 2\nErstellen Sie mit PsychoPy Builder ein Experiment namens number_comparison, in dem die Versuchsperson zwei am Bildschirm erscheinende Zahlen vergleichen soll. Sie soll angeben, ob die rechte oder linke Zahl die (numerisch) größere der beiden Zahlen ist.\nVerwenden Sie als Stimuli alle 20 Kombinationen der Zahlen von 1 bis 5, also z.B. 1–2, 1–3, 1–4, 1–5, 2–1, 2–3, usw. (die Excel-Datei soll also inklusive Kopfzeile 21 Zeilen beinhalten; gleiche Zahlen sollen nicht miteinander verglichen werden).\nFür die Antworten sollen entweder die Pfeil-nach-links-Taste oder die Pfeil-nach-rechts-Taste gedrückt werden können. Die Pfeil-nach-links-Taste heißt in PsychoPy \"left\" und bedeutet in diesem Experiment, dass die linke Zahl größer als die rechte ist. Die Pfeil-nach-rechts-Taste heißt \"right\" und bedeutet, dass die rechte Zahl größer ist.\nEin Trial (also ein Zahlenpaar) soll maximal 2 Sekunden am Bildschirm sichtbar sein – falls bis dahin keine Antwort gegeben wurde, soll das nächste Trial starten. Nach einer gegebenen Antwort bzw. nach dem Timeout von 2 Sekunden soll ein kurzes Feedback gegeben werden, ob die Antwort richtig oder falsch war (Dauer 1 Sekunde). Wenn keine Antwort gegeben wurde, soll kein Text (also ein leerer String) angezeigt werden.\nDie 20 Bedingungen sollen alle in zufälliger Reihenfolge angezeigt werden und drei mal wiederholt werden, d.h. insgesamt soll das Experiment aus 60 Trials bestehen.\nDas Experiment soll außerdem einen Instruktionstext sowie einen Verabschiedungstext beinhalten, welche nur durch Drücken der Leertaste beendet werden können."
  },
  {
    "objectID": "11/11-solutions.html",
    "href": "11/11-solutions.html",
    "title": "11 – Lösungen",
    "section": "",
    "text": "Das Stroop-Experiment ist hier verfügbar."
  },
  {
    "objectID": "11/11-solutions.html#übung-1",
    "href": "11/11-solutions.html#übung-1",
    "title": "11 – Lösungen",
    "section": "",
    "text": "Das Stroop-Experiment ist hier verfügbar."
  },
  {
    "objectID": "11/11-solutions.html#übung-2",
    "href": "11/11-solutions.html#übung-2",
    "title": "11 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\nDas Zahlenvergleichsexperiment ist hier verfügbar."
  },
  {
    "objectID": "03/03-solutions.html",
    "href": "03/03-solutions.html",
    "title": "3 – Lösungen",
    "section": "",
    "text": "width = 17\nheight = 12\ndelimiter = \".\"\n\n\nDer Ausdruck width / 2 hat vermutlich den Wert 8.5 (Typ float). Diese Vermutung kann bestätigt werden.\n\nwidth / 2\n\n8.5\n\n\n\ntype(width / 2)\n\nfloat\n\n\nDer Ausdruck height / 3 hat vermutlich den Wert 4 (Typ int). Diese Vermutung ist nicht korrekt – der tatsächliche Wert ist 4.0 (Typ float). Eine Division ergibt also immer Dezimalzahlen, auch wenn beide Operanden Ganzzahlen sind.\n\nheight / 3\n\n4.0\n\n\n\ntype(height / 3)\n\nfloat\n\n\nDer Ausdruck height * 3 hat vermutlich den Wert 36 (Typ int). Diese Vermutung kann bestätigt werden.\n\nheight * 3\n\n36\n\n\n\ntype(height * 3)\n\nint\n\n\nDer Ausdruck height * 3.0 hat vermutlich den Wert 36.0 (Typ float). Diese Vermutung ist korrekt, sobald ein Operand ein float ist, ist auch das Ergebnis einer Multiplikation ein float.\n\nheight * 3.0\n\n36.0\n\n\n\ntype(height * 3.0)\n\nfloat\n\n\nDer Ausdruck delimiter * 5 ergibt vermutlich einen Fehler (einen Punkt kann man nicht mal 5 rechnen). Diese Vermutung ist allerdings falsch, denn das Ergebnis lautet \".....\" (Typ str) – das Zeichen delimiter (ein Punkt) wird also verfünffacht.\n\ndelimiter * 5\n\n'.....'\n\n\n\ntype(delimiter * 5)\n\nstr\n\n\nDer Ausdruck 2 * (width + height) + 1.5 hat vermutlich den Wert 59.5 (Typ float). Diese Vermutung ist korrekt.\n\n2 * (width + height) + 1.5\n\n59.5\n\n\n\ntype(2 * (width + height) + 1.5)\n\nfloat\n\n\nDer Ausdruck 12 + 3 hat vermutlich den Wert 15 (Typ int).\n\n12 + 3\n\n15\n\n\n\ntype(12 + 3)\n\nint\n\n\nDer Ausdruck \"12 + 3\" ist ein String und hat daher den Wert \"12 + 3\" (Typ str). Daher kann damit auch nichts ausgerechnet werden, da es sich nur um eine Sequenz an Zeichen handelt.\n\n\"12 + 3\"\n\n'12 + 3'\n\n\n\ntype(\"12 + 3\")\n\nstr"
  },
  {
    "objectID": "03/03-solutions.html#übung-1",
    "href": "03/03-solutions.html#übung-1",
    "title": "3 – Lösungen",
    "section": "",
    "text": "width = 17\nheight = 12\ndelimiter = \".\"\n\n\nDer Ausdruck width / 2 hat vermutlich den Wert 8.5 (Typ float). Diese Vermutung kann bestätigt werden.\n\nwidth / 2\n\n8.5\n\n\n\ntype(width / 2)\n\nfloat\n\n\nDer Ausdruck height / 3 hat vermutlich den Wert 4 (Typ int). Diese Vermutung ist nicht korrekt – der tatsächliche Wert ist 4.0 (Typ float). Eine Division ergibt also immer Dezimalzahlen, auch wenn beide Operanden Ganzzahlen sind.\n\nheight / 3\n\n4.0\n\n\n\ntype(height / 3)\n\nfloat\n\n\nDer Ausdruck height * 3 hat vermutlich den Wert 36 (Typ int). Diese Vermutung kann bestätigt werden.\n\nheight * 3\n\n36\n\n\n\ntype(height * 3)\n\nint\n\n\nDer Ausdruck height * 3.0 hat vermutlich den Wert 36.0 (Typ float). Diese Vermutung ist korrekt, sobald ein Operand ein float ist, ist auch das Ergebnis einer Multiplikation ein float.\n\nheight * 3.0\n\n36.0\n\n\n\ntype(height * 3.0)\n\nfloat\n\n\nDer Ausdruck delimiter * 5 ergibt vermutlich einen Fehler (einen Punkt kann man nicht mal 5 rechnen). Diese Vermutung ist allerdings falsch, denn das Ergebnis lautet \".....\" (Typ str) – das Zeichen delimiter (ein Punkt) wird also verfünffacht.\n\ndelimiter * 5\n\n'.....'\n\n\n\ntype(delimiter * 5)\n\nstr\n\n\nDer Ausdruck 2 * (width + height) + 1.5 hat vermutlich den Wert 59.5 (Typ float). Diese Vermutung ist korrekt.\n\n2 * (width + height) + 1.5\n\n59.5\n\n\n\ntype(2 * (width + height) + 1.5)\n\nfloat\n\n\nDer Ausdruck 12 + 3 hat vermutlich den Wert 15 (Typ int).\n\n12 + 3\n\n15\n\n\n\ntype(12 + 3)\n\nint\n\n\nDer Ausdruck \"12 + 3\" ist ein String und hat daher den Wert \"12 + 3\" (Typ str). Daher kann damit auch nichts ausgerechnet werden, da es sich nur um eine Sequenz an Zeichen handelt.\n\n\"12 + 3\"\n\n'12 + 3'\n\n\n\ntype(\"12 + 3\")\n\nstr"
  },
  {
    "objectID": "03/03-solutions.html#übung-2",
    "href": "03/03-solutions.html#übung-2",
    "title": "3 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\nEine Anweisung ist eine Einheit von Code, welcher vom Python-Interpreter ausgeführt werden kann. Es gibt Anweisungen, die einen Wert haben und Anweisungen, die keinen Wert haben. Erstere (also Anweisungen mit Wert) nennt man auch Ausdrücke. Beispiele:\n\n12 + 5  # Ausdruck (Anweisung mit Wert)\n\n17\n\n\n\ntype(5)  # Ausdruck (Anweisung mit Wert)\n\nint\n\n\n\nx = 12 + 5  # Anweisung (Zuweisung)\nprint(x)  # Anweisung\n\n17\n\n\nIm interaktiven Modus gibt Python die Werte von Ausdrücken automatisch aus. Im Script-Modus ist dies jedoch nicht der Fall, hier müssen Werte explizit mit der print-Funktion ausgegeben werden."
  },
  {
    "objectID": "03/03-solutions.html#übung-3",
    "href": "03/03-solutions.html#übung-3",
    "title": "3 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\nSchlüsselwörter sind vordefinierte Namen, die Python zum Verstehen eines Python-Scripts benötigt. Eine Liste aller Schlüsselwörter bekommt man mit:\nimport keyword\nprint(keyword.kwlist)\nEingebaute Funktionen sind mit Python mitgelieferte Funktionen, welche ohne jeglichen Import sofort verfügbar sind. Eine Liste bekommt man mit:\ndir(__builtins__)\nBei der Namensgebung ist zu beachten, dass Schlüsselwörter nicht als Namen verwendet werden können (dies führt zu einer Fehlermeldung). Eingebaute Funktionen sollten prinzipiell ebenfalls nicht für eigene Namen verwendet werden (jedoch wäre dies technisch möglich).\nGute Namen sollten selbsterklärend sein und auf ihren Verwendungszweck hinweisen. Sie sollten so kurz wie möglich, aber dennoch so lang wie notwendig sein. Prinzipiell sollte man englische Begriffe als Namen verwenden. Ebenso hat es sich eingebürgert, dass Namen nur aus Kleinbuchstaben bestehen sollten, gegebenenfalls kann man einen Unterstrich _ zur Trennung von Wörtern verwenden.\nBeispiel für einen Namen, welcher die Anzahl an Versuchspersonen beinhaltet:\nn_subjects = 14"
  },
  {
    "objectID": "03/03-solutions.html#übung-4",
    "href": "03/03-solutions.html#übung-4",
    "title": "3 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\n\nimport math\n\nr = 5\narea = 4 * r**2 * math.pi\nvolume = 4/3 * math.pi * r**3\nprint(area, volume)\n\n314.1592653589793 523.5987755982989"
  },
  {
    "objectID": "03/03-solutions.html#übung-5",
    "href": "03/03-solutions.html#übung-5",
    "title": "3 – Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\n\ntype(True)\n\nbool\n\n\n\nx = \"True\"\ntype(x)\n\nstr\n\n\n\ntype(math)\n\nmodule"
  },
  {
    "objectID": "00/00.html",
    "href": "00/00.html",
    "title": "Organisatorisches",
    "section": "",
    "text": "In dieser Lehrveranstaltung werden Sie die Programmiersprache Python kennenlernen. Nach einer detaillierten Einführung in die Grundlagen werden auch praxisrelevante Themen wie das Importieren von Textdateien, die Arbeit mit numerischen Daten und das Erstellen von Grafiken behandelt. Außerdem werden Sie lernen, mit dem in der Psychologie populären Python-Paket PsychoPy einfache Experimente zu erstellen.\nDer Plan für dieses Semester sieht wie folgt aus:\n\n\n\n\n\n\n\n\nEinheit\nDatum\nInhalt\n\n\n\n\n1\n2.3.2026\nGrundlagen\n\n\n2\n9.3.2026\nDie Python-Umgebung\n\n\n3\n16.3.2026\nNamen, Ausdrücke, Anweisungen\n\n\n4\n23.3.2026\nFunktionen\n\n\n5\n13.4.2026\nBedingungen und Schleifen\n\n\n6\n20.4.2026\nStrings\n\n\n7\n27.4.2026\nListen und Dictionaries\n\n\n8\n4.5.2026\nEin- und Ausgabe\n\n\n9\n11.5.2026\nNumerische Daten\n\n\n10\n18.5.2026\nGrafiken\n\n\n11\n1.6.2026\nPsychoPy (1)\n\n\n12\n8.6.2026\nPsychoPy (2)\n\n\n13\n15.6.2026\nPrüfung\n\n\n14\n22.6.2026\nPrüfung (Ersatztermin)\n\n\n\nAlle Informationen und Unterlagen zu dieser Lehrveranstaltung werden auf Moodle zur Verfügung gestellt. Insbesondere wird auch die Kommunikation (Ankündigungen, Forumsdiskussionen, Fragen & Antworten) über Moodle abgewickelt.\nDie Einheiten finden grundsätzlich in Präsenz statt. Sollte das einmal nicht möglich sein, wird dies auf Moodle bekanntgegeben und die betreffende Einheit wird gegebenenfalls zur geplanten Zeit online abgehalten."
  },
  {
    "objectID": "00/00.html#allgemeines",
    "href": "00/00.html#allgemeines",
    "title": "Organisatorisches",
    "section": "",
    "text": "In dieser Lehrveranstaltung werden Sie die Programmiersprache Python kennenlernen. Nach einer detaillierten Einführung in die Grundlagen werden auch praxisrelevante Themen wie das Importieren von Textdateien, die Arbeit mit numerischen Daten und das Erstellen von Grafiken behandelt. Außerdem werden Sie lernen, mit dem in der Psychologie populären Python-Paket PsychoPy einfache Experimente zu erstellen.\nDer Plan für dieses Semester sieht wie folgt aus:\n\n\n\n\n\n\n\n\nEinheit\nDatum\nInhalt\n\n\n\n\n1\n2.3.2026\nGrundlagen\n\n\n2\n9.3.2026\nDie Python-Umgebung\n\n\n3\n16.3.2026\nNamen, Ausdrücke, Anweisungen\n\n\n4\n23.3.2026\nFunktionen\n\n\n5\n13.4.2026\nBedingungen und Schleifen\n\n\n6\n20.4.2026\nStrings\n\n\n7\n27.4.2026\nListen und Dictionaries\n\n\n8\n4.5.2026\nEin- und Ausgabe\n\n\n9\n11.5.2026\nNumerische Daten\n\n\n10\n18.5.2026\nGrafiken\n\n\n11\n1.6.2026\nPsychoPy (1)\n\n\n12\n8.6.2026\nPsychoPy (2)\n\n\n13\n15.6.2026\nPrüfung\n\n\n14\n22.6.2026\nPrüfung (Ersatztermin)\n\n\n\nAlle Informationen und Unterlagen zu dieser Lehrveranstaltung werden auf Moodle zur Verfügung gestellt. Insbesondere wird auch die Kommunikation (Ankündigungen, Forumsdiskussionen, Fragen & Antworten) über Moodle abgewickelt.\nDie Einheiten finden grundsätzlich in Präsenz statt. Sollte das einmal nicht möglich sein, wird dies auf Moodle bekanntgegeben und die betreffende Einheit wird gegebenenfalls zur geplanten Zeit online abgehalten."
  },
  {
    "objectID": "00/00.html#ablauf-einer-einheit",
    "href": "00/00.html#ablauf-einer-einheit",
    "title": "Organisatorisches",
    "section": "Ablauf einer Einheit",
    "text": "Ablauf einer Einheit\nZu jeder Einheit gibt es auf Moodle ausführliche Unterlagen, welche das jeweilige Thema detailliert behandeln. Diese Unterlagen sind so gestaltet, dass Sie sich die Inhalte im Selbststudium aneignen können. Alle inhaltlichen Einheiten (mit Ausnahme der ersten) werden nach dem Prinzip des Flipped Classroom abgehalten. Das bedeutet, dass Sie die Inhalte der jeweiligen Einheit vor dem tatsächlichen Termin erarbeiten müssen. Besonders wichtig sind die Übungsbeispiele am Ende jedes Kapitels. Diese überprüfen Ihr Verständnis der vermittelten Inhalte und sind außerdem eine essenzielle Vorbereitung für die abschließende Prüfung.\n\n\n\n\n\n\nTipp\n\n\n\nNutzen Sie während der Vorbereitungszeit das Diskussionsforum auf Moodle – dort können Sie Fragen stellen und selbstverständlich auch beantworten. Je mehr Personen sich aktiv im Forum beteiligen, desto hilfreicher wird es für alle!\n\n\n\n\n\n\n\n\nTipp\n\n\n\nWenn Sie die Möglichkeit haben, sich die Inhalte gemeinsam mit anderen Studierenden zu erarbeiten, ist das natürlich umso besser! Gerade bei Programmieraufgaben ist es oft hilfreich, sich auszutauschen und gemeinsam Lösungen zu erarbeiten (Pair Programming).\n\n\nJede Einheit beginnt mit einem kurzen Quiz zum Thema der jeweiligen Einheit (dazu später mehr). Danach werden die von Ihnen vorbereiteten Übungsbeispiele aus den Unterlagen detailliert besprochen und Musterlösungen präsentiert. Dabei haben Sie die Möglichkeit, Fragen zu stellen bzw. Ihre individuellen Lösungsansätze zu diskutieren. Falls darüber hinaus noch Zeit bleiben sollte, wird das jeweilige Thema durch vertiefende Beispiele bzw. Erklärungen ergänzt.\n\n\n\n\n\n\nHinweis\n\n\n\nDer Einsatz von Künstlicher Intelligenz, insbesondere von Large Language Models (wie z.B. ChatGPT, Gemini, Mistral oder Claude), ist für die Vorbereitung der Einheiten ausdrücklich erlaubt und wird sogar empfohlen. Diese Werkzeuge können helfen, Konzepte zu verstehen, Codebeispiele nachzuvollziehen und alternative Erklärungen zu finden. Allerdings sollten Sie immer versuchen, die Übungsaufgaben selbständig zu lösen, um ein tiefes Verständnis der Materie zu entwickeln."
  },
  {
    "objectID": "00/00.html#beurteilungskriterien",
    "href": "00/00.html#beurteilungskriterien",
    "title": "Organisatorisches",
    "section": "Beurteilungskriterien",
    "text": "Beurteilungskriterien\n\nAnwesenheit\nDurch den immanenten Prüfungscharakter dieser Lehrveranstaltung besteht Anwesenheitspflicht. Ihre Anwesenheit wird zu einem zufälligen Zeitpunkt während der Einheit überprüft. Sie können allerdings ohne Auswirkungen auf die Beurteilung bei bis zu drei Einheiten fehlen (eine Begründung ist nicht erforderlich).\n\n\nQuizzes\nZu Beginn jeder Einheit (mit Ausnahme der ersten) findet ein Quiz auf Moodle statt. Es werden kurze Fragen zum jeweiligen Thema der Einheit gestellt (meist Multiple-Choice). Hilfsmittel (wie z.B. die Unterlagen) sind nicht erlaubt.\nSie können bei einem Quiz maximal 10 Punkte erreichen (es gibt auch Teilpunkte). Das Quiz muss vor Ort auf einem Universitäts-PC absolviert werden. Ein nicht absolviertes Quiz (z.B. durch Fehlen oder Zuspätkommen) zählt 0 Punkte.\n\n\n\n\n\n\nHinweis\n\n\n\nStellen Sie vorab sicher, dass Ihre aktuellen Zugangsdaten (einschließlich der Zwei-Faktor-Authentifizierung) für die Anmeldung funktionieren!\n\n\n\n\nPrüfung\nAm Ende des Semesters findet eine Prüfung über alle Inhalte der Lehrveranstaltung statt, welche vor Ort auf einem Universitäts-PC absolviert wird. Als einziges Hilfsmittel ist ein von Ihnen erstelltes, zweiseitig beschriebenes A4-Blatt erlaubt, auf dem Sie die wichtigsten Inhalte der Lehrveranstaltung zusammenfassen können. Fertig gelöste Beispiele dürfen darauf jedoch nicht enthalten sein. Da Sie mit dem interaktiven Python-Interpreter arbeiten werden (Ihre Lösung ist dann als Python-Script auf Moodle abzugeben), können Sie natürlich auch die integrierte Hilfe von Python nutzen, um Informationen zu Funktionen oder Paketen abzurufen.\nEs können maximal 10 Punkte erreicht werden (Teilpunkte sind möglich).\nDie Prüfung kann bei Bedarf wiederholt werden. In diesem Fall zählen die Punkte des zweiten Termins, d.h. man kann sich sowohl verbessern als auch verschlechtern."
  },
  {
    "objectID": "00/00.html#benotung",
    "href": "00/00.html#benotung",
    "title": "Organisatorisches",
    "section": "Benotung",
    "text": "Benotung\nDie Gesamtnote ergibt sich aus den drei beschriebenen Kriterien:\n\nWenn Sie nicht öfter als drei Mal gefehlt haben, ist das Anwesenheitskriterium erfüllt. Mehr als drei Fehleinheiten führen automatisch zu einer negativen Beurteilung der Lehrveranstaltung.\nAus den Punkten aller Quizzes werden zunächst die niedrigsten drei Bewertungen entfernt. Aus den übrigen Bewertungen wird der arithmetische Mittelwert berechnet – dieser Mittelwert fließt dann zu 50% in die Gesamtnote ein.\nDie Punkte aus der Prüfung fließen ebenfalls zu 50% in die Gesamtnote ein. Es müssen allerdings mindestens 6 Punkte bei der Prüfung erreicht werden, um die Lehrveranstaltung positiv abzuschließen.\n\nSofern diese Kriterien erfüllt sind, ergibt sich die Gesamtnote aus dem Mittelwert der Punkte aus den Quizzes und der Prüfung wie folgt:\n\n\n\n\n\n\n\n\n\n\nSehr gut\nGut\nBefriedigend\nGenügend\nNicht genügend\n\n\n\n\n9–10 Punkte\n8–9 Punkte\n7–8 Punkte\n6–7 Punkte\n&lt; 6 Punkte\n\n\n\nDie niedrigste Punkteanzahl einer Kategorie wird immer der besseren Note zugeordnet. Beispielsweise entsprechen exakt 9 Punkte der Note “Sehr gut”. Die gemittelte Punkteanzahl wird auch nicht mehr auf- oder abgerundet, daher entsprechen z.B. 8.97 Punkte der Note “Gut”."
  },
  {
    "objectID": "08/08.html",
    "href": "08/08.html",
    "title": "8 – Ein- und Ausgabe",
    "section": "",
    "text": "Unter Eingabe versteht man die Eingabe von Informationen von der Tastatur bzw. aus einer Datei, um diese in einem Programm verarbeiten zu können. Unter Ausgabe versteht man die Ausgabe von Informationen am Bildschirm bzw. in eine Datei (also z.B. Ergebnisse einer Berechnung). Im Folgenden werden wir sehen, wie wir Strings für die Ausgabe formatieren können und wie wir damit Textdateien lesen bzw. schreiben können."
  },
  {
    "objectID": "08/08.html#allgemeines",
    "href": "08/08.html#allgemeines",
    "title": "8 – Ein- und Ausgabe",
    "section": "",
    "text": "Unter Eingabe versteht man die Eingabe von Informationen von der Tastatur bzw. aus einer Datei, um diese in einem Programm verarbeiten zu können. Unter Ausgabe versteht man die Ausgabe von Informationen am Bildschirm bzw. in eine Datei (also z.B. Ergebnisse einer Berechnung). Im Folgenden werden wir sehen, wie wir Strings für die Ausgabe formatieren können und wie wir damit Textdateien lesen bzw. schreiben können."
  },
  {
    "objectID": "08/08.html#ausgabe-von-strings",
    "href": "08/08.html#ausgabe-von-strings",
    "title": "8 – Ein- und Ausgabe",
    "section": "Ausgabe von Strings",
    "text": "Ausgabe von Strings\n\nStrings verketten\nWir haben bereits die print-Funktion kennengelernt, welche Strings (und andere Objekte) als Text am Bildschirm ausgeben kann. Im einfachsten Fall kann so ein String ausgegeben werden:\n\nprint(\"Hallo\")\n\nHallo\n\n\nAuch Zahlen kann man als Argument für print verwenden:\n\nprint(55)\n\n55\n\n\nMit der Funktion str kann man beliebige Objekte (also auch z.B. Ganzzahlen) in einen String umwandeln:\n\nstr(55)\n\n'55'\n\n\nDie print-Funktion kann beliebig viele Argumente entgegennehmen. Sie gibt dann alle Argumente, getrennt mit Leerzeichen, am Bildschirm aus.\n\na = 5\nb = 10\nprint(a, \"+\", b, \"=\", a + b)  # fünf Argumente\n\n5 + 10 = 15\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nDie print-Funktion hat zwei optionale Parameter sep bzw. end, welche das Trennzeichen zwischen den Argumenten und das Zeichen am Ende der Ausgabe beeinflussen:\n\nsep=\" \": Trennzeichen zwischen den Argumenten (Standard: Leerzeichen)\nend=\"\\n\": Zeichen am Ende der Ausgabe (Standard: Zeilenumbruch)\n\nWas wäre die Ausgabe des obigen Beispiels, wenn man sep=\"\" setzen würde? Was bewirkt end=\"!!!\"?\n\n\nWie wir bereits wissen, kann man mehrere Strings mit + verketten. Daher könnte man obige Ausgabe auch durch Ausgabe eines einzigen Strings durch Verketten von einzelnen Strings erzeugen:\n\nprint(str(a) + \" + \" + str(b) + \" = \" + str(a + b))  # ein Argument\n\n5 + 10 = 15\n\n\n\n\nf-Strings\nSogenannte f-Strings sind ganz normale Strings, man kann aber bei ihrer Erzeugung beliebige Ausdrücke verwenden, die dann ausgewertet in den String eingesetzt (interpoliert) werden. Man definiert einen f-String wie einen regulären String mittels Anführungszeichen, stellt aber ein f voran, also z.B.:\n\nf\"Hallo\"\n\n'Hallo'\n\n\nSinnvoll sind f-Strings nur dann, wenn man auch tatsächlich Ausdrücke integriert, welche innerhalb von geschwungenen Klammern {} angegeben werden. Alle Ausdrücke werden ausgewertet und in den String interpoliert:\n\nname = \"World\"\nf\"Hello {name}!\"\n\n'Hello World!'\n\n\nDen fertigen String kann man dann einfach mit print am Bildschirm ausgeben. Das Beispiel aus dem vorigen Abschnitt kann man daher wie folgt anschreiben:\n\nprint(f\"{a} + {b} = {a + b}\")\n\n5 + 10 = 15\n\n\nAusdrücke wie z.B. Zahlen, können optional auch formatiert werden. Sehen wir uns zunächst an, wie die Kreiszahl \\(\\pi\\) standardmäßig ausgegeben wird:\n\nimport math\n\nprint(f\"π ≈ {math.pi}\")\n\nπ ≈ 3.141592653589793\n\n\nMit einem optionalen Doppelpunkt und einem sogenannten Format Specifier innerhalb der geschwungenen Klammern kann ein Ausdruck gezielt formatiert werden. Das folgende Beispiel formatiert die Zahl \\(\\pi\\) so, dass sie mit drei Nachkommastellen ausgegeben wird:\n\nprint(f\"π ≈ {math.pi:.3f}\")\n\nπ ≈ 3.142\n\n\nOder mit 16 Nachkommastellen:\n\nprint(f\"π ≈ {math.pi:.16f}\")\n\nπ ≈ 3.1415926535897931\n\n\nEine Ganzzahl wird mit dem Format Specifier d ausgegeben:\n\nnumber = 42\nprint(f\"number = {number:d}\")\n\nnumber = 42\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nd steht für “decimal” (Basis 10) und formatiert ganze Zahlen. Der Begriff “Dezimalzahl” kann im Alltag aber auch “Kommazahl” (Dezimalbruch) bedeuten – dafür verwendet man aber den Format Specifier f (steht für “float”).\n\n\nDie minimale Feldbreite kann mit einer Zahl direkt nach dem Doppelpunkt spezifiziert werden, im folgenden Beispiel soll diese 15 Zeichen betragen:\n\nprint(f\"π ≈ {math.pi:15.3f}\")\n\nπ ≈           3.142\n\n\nMan kann auch die Ausrichtung innerhalb des Feldes spezifizieren. Standardmäßig wird rechtsbündig ausgerichtet (für Zahlen sinnvoll), mit &lt; wird linksbündig ausgerichtet:\n\nprint(f\"π ≈ {math.pi:&lt;15.3f}, more text\")  # linksbündig\nprint(f\"π ≈ {math.pi:15.3f}, more text\")  # rechtsbündig (Standard)\n\nπ ≈ 3.142          , more text\nπ ≈           3.142, more text\n\n\nFührende Nullen können ebenfalls hinzugefügt werden, indem man eine 0 vor die Feldbreite setzt:\n\nprint(f\"number = {number:5d}\")    # 5 Stellen, mit Leerzeichen\nprint(f\"number = {number:05d}\")   # 5 Stellen, mit führenden Nullen\n\nnumber =    42\nnumber = 00042\n\n\nDies funktioniert auch mit Dezimalzahlen:\n\nprint(f\"π ≈ {math.pi:015.3f}, more text\")\n\nπ ≈ 00000000003.142, more text\n\n\nAlle Möglichkeiten, die Format Specifier innerhalb der geschwungenen Klammern bieten, finden sich in der offiziellen Dokumentation (inklusive einer Menge Beispiele)."
  },
  {
    "objectID": "08/08.html#dateien-lesen-und-schreiben",
    "href": "08/08.html#dateien-lesen-und-schreiben",
    "title": "8 – Ein- und Ausgabe",
    "section": "Dateien lesen und schreiben",
    "text": "Dateien lesen und schreiben\nDie Funktion open gibt ein Datei-Objekt zurück, welches zum Lesen oder Schreiben von Dateien verwendet werden kann (die im Beispiel verwendete Datei test.txt ist hier verfügbar):\nf = open(\"test.txt\", \"w\")\nDas erste Argument ist der Dateiname, und das zweite Argument beschreibt den Modus (\"r\" lesen, \"w\" schreiben, \"a\" hinzufügen). Standardmäßig wird der Modus \"r\" angenommen, wenn das Argument nicht explizit übergeben wird.\nMit dem Datei-Objekt f kann man dann aus der Datei lesen bzw. in die Datei schreiben (je nach Modus).\n\n\n\n\n\n\nWichtig\n\n\n\nNach Beendigung aller Lese- und Schreiboperationen muss man das Datei-Objekt wieder schließen:\nf.close()\nEs ist sinnvoll, alle Datei-Operationen innerhalb eines with-Blocks durchzuführen. So wird die Datei bei Verlassen des Blocks automatisch geschlossen, d.h. man benötigt kein f.close():\nwith open(\"test.txt\") as f:\n    data = f.read()\n\n\nZu Beachten ist noch, dass der Dateiname als String übergeben wird. Dieser enthält entweder den vollständigen Pfad der zu öffnenden Datei (z.B. \"C:/Program Files/Test Program/test.txt\"), oder nur den Dateinamen. Im letzteren Fall wird dann angenommen, dass sich die Datei im Arbeitsverzeichnis befindet.\n\n\n\n\n\n\nHinweis\n\n\n\nPfade sollten immer mit einem normalen / getrennt werden und nicht wie unter Windows üblich mit einem verkehrten \\, da man mit letzterem eine Escape-Sequenz einleitet. Möchte man dennoch \\ verwenden, muss man diesen mit der Escape-Sequenz \\\\ schreiben.\n\n\nDie Methode read eines Datei-Objektes liest die gesamte Datei ein und gibt den Inhalt als String zurück:\n\nf = open(\"test.txt\")\ntext = f.read()\nprint(text)\n\nHello!\n\nThis is just a test file containing some random text.\n\nNice!\n\n\nZu beachten ist hier, dass der gesamte Inhalt der Datei in den Speicher geladen wird. Bei sehr großen Dateien kann das eventuell zu Problemen führen, weswegen man diese zeilenweise einlesen sollte (dazu gleich mehr).\n\n\n\n\n\n\nTipp\n\n\n\nDer Inhalt einer Datei kann immer nur ein Mal gelesen werden. Wenn bereits der gesamte Inhalt gelesen wurde, befindet sich der sogenannte Dateizeiger am Ende der Datei. Wenn dann nochmals gelesen wird, wird nur mehr ein leerer String zurückgegeben:\n\nf.read()  # Ende der Datei bereits erreicht\n\n''\n\n\nMöchte man die Datei erneut lesen, muss man sie schließen und kann sie dann wieder erneut öffnen:\n\nf.close()  # schließt Datei (notwendig wenn man kein with verwendet)\n\n\n\nDie Methode readline liest eine Zeile aus der Datei:\n\nwith open(\"test.txt\") as f:\n    print(\"1. Zeile: \", f.readline(), end=\"\")\n    print(\"2. Zeile: \", f.readline(), end=\"\")\n    print(\"3. Zeile: \", f.readline(), end=\"\")\n\n1. Zeile:  Hello!\n2. Zeile:  \n3. Zeile:  This is just a test file containing some random text.\n\n\nIn einer Schleife kann man die Datei ebenso Zeile für Zeile auslesen, in dem man über das Datei-Objekt iteriert:\n\nwith open(\"test.txt\") as f:\n    for line in f:\n        print(line, end=\"\")\n\nHello!\n\nThis is just a test file containing some random text.\n\nNice!\n\n\nSo kann man einzelne Zeilen einfach manipulieren, z.B. um Zeilennummern auszugeben (die nicht in der Datei selbst sind):\n\nwith open(\"test.txt\") as f:\n    for no, line in enumerate(f):\n        print(no, line, end=\"\")\n\n0 Hello!\n1 \n2 This is just a test file containing some random text.\n3 \n4 Nice!\n\n\n\n\n\n\n\n\nTipp\n\n\n\nIn der for-Schleife wird hier nicht direkt über f, sondern über enumerate(f) iteriert. Diese Funktion zählt die Schleifendurchläufe mit und gibt ein Tupel bestehend aus dem aktuellen Wert des Schleifenzählers sowie der aktuellen Zeile zurück.\n\n\nText in Dateien schreiben funktioniert sehr ähnlich – man öffnet die Datei im \"w\"-Modus und übergibt der write-Methode den gewünschten Inhalt als String:\nwith open(\"test2.txt\", \"w\") as f:\n    f.write(\"Das ist ein Test.\\nSo kann man einfach\\nText\\nin Dateien schreiben.\")\nIn diesem Beispiel steht die Escape-Sequenz \\n für einen Zeilenumbruch (neue Zeile)."
  },
  {
    "objectID": "08/08.html#beispiel-csv-datei-lesen",
    "href": "08/08.html#beispiel-csv-datei-lesen",
    "title": "8 – Ein- und Ausgabe",
    "section": "Beispiel: CSV-Datei lesen",
    "text": "Beispiel: CSV-Datei lesen\nMit den bis jetzt vorgestellten Mitteln können wir bereits CSV1-Dateien einlesen und rudimentäre Statistiken rechnen. CSV-Dateien werden häufig verwendet, um tabellarische Daten abzuspeichern. Diese Dateien sind reine Textdateien, in denen die Variablen (Spalten) durch Kommas getrennt sind und die einzelnen Datensätze zeilenweise vorliegen.\nIm Folgenden werden drei Möglichkeiten zum Lesen einer CSV-Datei vorgestellt (die Beispieldatei correlation.csv ist hier verfügbar). Die erste Methode verwendet Python ohne spezielle Module, die zweite Methode ist eine Verallgemeinerung der ersten. Die dritte und einfachste Variante verwendet das Package pandas, welches wir in dieser Lehrveranstaltung aber nicht genauer kennenlernen werden (sie wird der Vollständigkeit halber trotzdem erwähnt).\n\nMöglichkeit 1\nWir starten mit einer leeren Liste data. Dieser Liste fügen wir den Inhalt jeder Zeile schrittweise (mittels append) hinzu. Eine Zeile wird dabei als Liste mit zwei Strings abgebildet. Zuerst entfernen wir eventuelle Leerzeichen am Anfang und Ende einer Zeile mittels .strip(), und danach spalten wir die Zeile am Komma in eine Liste mit zwei Elementen mittels .split(\",\") auf:\n\ndata = []  # leere Liste\nwith open(\"correlation.csv\") as f:\n    for row in f:\n        data.append(row.strip().split(\",\"))\n\n\ndata\n\n[['essay', 'hours'],\n ['61.6754974920745', '10.6303372921189'],\n ['69.5450056362295', '7.28522617959232'],\n ['48.2293039713449', '5.05204775449098'],\n ['70.6786516311817', '2.88661436120476'],\n ['59.8996225857332', '9.54501229482367'],\n ['61.1620237718455', '11.3108384701452'],\n ['67.6247016928604', '7.46507180351913'],\n ['64.7790589873963', '8.47127906794298'],\n ['63.207063456166', '8.71537345316006'],\n ['49.6910817003072', '6.20347356947365'],\n ['63.7189196026189', '4.77251550782322'],\n ['72.2425933666743', '10.9815424018851'],\n ['70.5862210579123', '5.2215409766568'],\n ['58.6398615751171', '6.85848450383968'],\n ['58.7153800614887', '9.7984118965962'],\n ['67.3999698058767', '9.49072930246925'],\n ['60.7037631406063', '6.51736420324962'],\n ['60.931351175695', '11.8021326615165'],\n ['62.3401801239333', '8.96313112993931'],\n ['59.9662288209405', '5.42249029575092'],\n ['52.1619843495503', '6.40972025602273'],\n ['76.5879640890472', '15.0104773734972'],\n ['60.9196973933278', '8.07064211676739'],\n ['66.6330159660378', '10.9720986214915'],\n ['73.6195367228337', '14.7776461317624'],\n ['60.2224731091917', '5.2455561967939'],\n ['59.257246898708', '8.67216132385057'],\n ['51.9302907572568', '8.55546259639567'],\n ['59.4301075638833', '6.08144370899007'],\n ['69.4087175381595', '7.42190548469444'],\n ['65.2986136310666', '12.3137937416164'],\n ['60.2838297249765', '9.93443882388444'],\n ['60.8535237978012', '7.79529820172183'],\n ['71.6333469504558', '6.5627956116459'],\n ['69.1407939072155', '10.2828636303044'],\n ['66.4753904156445', '5.11639249646656'],\n ['63.0477561140632', '8.66268357519631'],\n ['68.1678280737943', '6.59320568183171'],\n ['64.7480342462125', '3.70537792316693'],\n ['68.2804343717536', '12.9178683539958'],\n ['60.4052387002632', '8.6962361085862'],\n ['64.6313248038771', '11.2150596156186'],\n ['58.2594898681359', '6.83244891007452'],\n ['52.2352473953415', '8.62308388223269'],\n ['79.8777504975499', '7.84368345377415']]\n\n\nNun können die Daten in eine Struktur umgewandelt werden, die sich besser für nachfolgende Berechnungen eignet (also inbesondere werden die Zahlen, die als Strings vorliegen, mit der Funktion float in Kommazahlen umgewandelt).\n\ncols = [[], []]  # zwei leere Listen für die zwei Spalten\nfor row in data[1:]:  # die erste Zeile 0 wird übersprungen (Kopfzeile)\n    cols[0].append(float(row[0]))  # erste Spalte\n    cols[1].append(float(row[1]))  # zweite Spalte\n\nNun stehen die beiden Spalten in der Liste cols zur weiteren Verfügung. Diese Liste hat zwei Elemente:\n\nlen(cols)\n\n2\n\n\nDie beiden Einträge in cols sind ebenfalls Listen:\n\ntype(cols[0]), type(cols[1])\n\n(list, list)\n\n\nDie Länge beider Listen entspricht der Anzahl an Zeilen in der CSV-Datei (ohne Kopfzeile):\n\nlen(cols[0]), len(cols[1])\n\n(45, 45)\n\n\nDie Elemente in diesen beiden Listen sind Zahlen:\n\ncols[0]\n\n[61.6754974920745,\n 69.5450056362295,\n 48.2293039713449,\n 70.6786516311817,\n 59.8996225857332,\n 61.1620237718455,\n 67.6247016928604,\n 64.7790589873963,\n 63.207063456166,\n 49.6910817003072,\n 63.7189196026189,\n 72.2425933666743,\n 70.5862210579123,\n 58.6398615751171,\n 58.7153800614887,\n 67.3999698058767,\n 60.7037631406063,\n 60.931351175695,\n 62.3401801239333,\n 59.9662288209405,\n 52.1619843495503,\n 76.5879640890472,\n 60.9196973933278,\n 66.6330159660378,\n 73.6195367228337,\n 60.2224731091917,\n 59.257246898708,\n 51.9302907572568,\n 59.4301075638833,\n 69.4087175381595,\n 65.2986136310666,\n 60.2838297249765,\n 60.8535237978012,\n 71.6333469504558,\n 69.1407939072155,\n 66.4753904156445,\n 63.0477561140632,\n 68.1678280737943,\n 64.7480342462125,\n 68.2804343717536,\n 60.4052387002632,\n 64.6313248038771,\n 58.2594898681359,\n 52.2352473953415,\n 79.8777504975499]\n\n\n\ncols[1]\n\n[10.6303372921189,\n 7.28522617959232,\n 5.05204775449098,\n 2.88661436120476,\n 9.54501229482367,\n 11.3108384701452,\n 7.46507180351913,\n 8.47127906794298,\n 8.71537345316006,\n 6.20347356947365,\n 4.77251550782322,\n 10.9815424018851,\n 5.2215409766568,\n 6.85848450383968,\n 9.7984118965962,\n 9.49072930246925,\n 6.51736420324962,\n 11.8021326615165,\n 8.96313112993931,\n 5.42249029575092,\n 6.40972025602273,\n 15.0104773734972,\n 8.07064211676739,\n 10.9720986214915,\n 14.7776461317624,\n 5.2455561967939,\n 8.67216132385057,\n 8.55546259639567,\n 6.08144370899007,\n 7.42190548469444,\n 12.3137937416164,\n 9.93443882388444,\n 7.79529820172183,\n 6.5627956116459,\n 10.2828636303044,\n 5.11639249646656,\n 8.66268357519631,\n 6.59320568183171,\n 3.70537792316693,\n 12.9178683539958,\n 8.6962361085862,\n 11.2150596156186,\n 6.83244891007452,\n 8.62308388223269,\n 7.84368345377415]\n\n\nMit diesen beiden Listen kann man jetzt also Berechnungen durchführen. Beispielsweise kann man die Spaltenmittelwerte so ausrechnen:\n\nsum(cols[0]) / len(cols[0])\n\n63.449913700936655\n\n\n\nsum(cols[1]) / len(cols[1])\n\n8.349021354368457\n\n\nDiese Lösung ist allerdings alles andere als ideal. Erstens sollte man immer bereits existierende Lösungen verwenden und nicht alles von Grund auf neu entwickeln (es gibt in Python wie bereits erwähnt ein eigenes csv-Modul, und das Package pandas ist für solche Aufgaben geradezu prädestiniert). Zweitens ist diese Lösung auch sehr auf die konkrete Datei angepasst, z.B. funktioniert der Ansatz nur für eine Datei mit exakt zwei Spalten.\n\n\nMöglichkeit 2\nEine verallgemeinerte Lösung für eine beliebige Anzahl an Spalten sieht wie folgt aus:\n\nwith open(\"correlation.csv\") as f:\n    header = f.readline().strip().split(\",\")  # erste Zeile\n\n    data = {}  # dict mit einem Eintrag pro Spalte\n    for name in header:\n        data[name] = []  # Key ist der Spaltenname, Value eine leere Liste\n\n    for row in f:  # restliche Zeilen\n        values = row.strip().split(\",\")\n        for h, v in zip(header, values):\n            data[h].append(float(v))  # füge zur jeweiligen Liste hinzu\n\nHier werden zunächst die Variablennamen aus der ersten Zeile (der Kopfzeile) gelesen. Die Daten werden dann in ein Dictionary geschrieben, wobei die Werte der Spalten zu den richtigen Dictionary-Einträgen (Listen) hinzugefügt werden. Die Funktion zip kombiniert die Werte von header und values in ein Tupel, die dann innerhalb der Schleife als h bzw. v zur Verfügung stehen (so kann man in einer Schleife also gleichzeitig über zwei Objekte iterieren).\n\ndata\n\n{'essay': [61.6754974920745,\n  69.5450056362295,\n  48.2293039713449,\n  70.6786516311817,\n  59.8996225857332,\n  61.1620237718455,\n  67.6247016928604,\n  64.7790589873963,\n  63.207063456166,\n  49.6910817003072,\n  63.7189196026189,\n  72.2425933666743,\n  70.5862210579123,\n  58.6398615751171,\n  58.7153800614887,\n  67.3999698058767,\n  60.7037631406063,\n  60.931351175695,\n  62.3401801239333,\n  59.9662288209405,\n  52.1619843495503,\n  76.5879640890472,\n  60.9196973933278,\n  66.6330159660378,\n  73.6195367228337,\n  60.2224731091917,\n  59.257246898708,\n  51.9302907572568,\n  59.4301075638833,\n  69.4087175381595,\n  65.2986136310666,\n  60.2838297249765,\n  60.8535237978012,\n  71.6333469504558,\n  69.1407939072155,\n  66.4753904156445,\n  63.0477561140632,\n  68.1678280737943,\n  64.7480342462125,\n  68.2804343717536,\n  60.4052387002632,\n  64.6313248038771,\n  58.2594898681359,\n  52.2352473953415,\n  79.8777504975499],\n 'hours': [10.6303372921189,\n  7.28522617959232,\n  5.05204775449098,\n  2.88661436120476,\n  9.54501229482367,\n  11.3108384701452,\n  7.46507180351913,\n  8.47127906794298,\n  8.71537345316006,\n  6.20347356947365,\n  4.77251550782322,\n  10.9815424018851,\n  5.2215409766568,\n  6.85848450383968,\n  9.7984118965962,\n  9.49072930246925,\n  6.51736420324962,\n  11.8021326615165,\n  8.96313112993931,\n  5.42249029575092,\n  6.40972025602273,\n  15.0104773734972,\n  8.07064211676739,\n  10.9720986214915,\n  14.7776461317624,\n  5.2455561967939,\n  8.67216132385057,\n  8.55546259639567,\n  6.08144370899007,\n  7.42190548469444,\n  12.3137937416164,\n  9.93443882388444,\n  7.79529820172183,\n  6.5627956116459,\n  10.2828636303044,\n  5.11639249646656,\n  8.66268357519631,\n  6.59320568183171,\n  3.70537792316693,\n  12.9178683539958,\n  8.6962361085862,\n  11.2150596156186,\n  6.83244891007452,\n  8.62308388223269,\n  7.84368345377415]}\n\n\nDiese Lösung funktioniert also bereits mit einer beliebigen Spaltenanzahl, setzt aber voraus, dass es eine Kopfzeile gibt. Die Spaltenmittelwerte können dann wie folgt berechnet werden:\n\nsum(data[\"essay\"]) / len(data[\"essay\"])\n\n63.449913700936655\n\n\n\nsum(data[\"hours\"]) / len(data[\"hours\"])\n\n8.349021354368457\n\n\n\n\nMöglichkeit 3\nDas Package pandas eignet sich ideal zum Verarbeiten von tabellarischen Daten. Es beinhaltet auch Funktionen zum Lesen von Dateien. Damit würde der Code wie folgt aussehen:\n\nimport pandas as pd\n\ndata = pd.read_csv(\"correlation.csv\")\n\n\ndata\n\n\n\n\n\n\n\n\nessay\nhours\n\n\n\n\n0\n61.675497\n10.630337\n\n\n1\n69.545006\n7.285226\n\n\n2\n48.229304\n5.052048\n\n\n3\n70.678652\n2.886614\n\n\n4\n59.899623\n9.545012\n\n\n5\n61.162024\n11.310838\n\n\n6\n67.624702\n7.465072\n\n\n7\n64.779059\n8.471279\n\n\n8\n63.207063\n8.715373\n\n\n9\n49.691082\n6.203474\n\n\n10\n63.718920\n4.772516\n\n\n11\n72.242593\n10.981542\n\n\n12\n70.586221\n5.221541\n\n\n13\n58.639862\n6.858485\n\n\n14\n58.715380\n9.798412\n\n\n15\n67.399970\n9.490729\n\n\n16\n60.703763\n6.517364\n\n\n17\n60.931351\n11.802133\n\n\n18\n62.340180\n8.963131\n\n\n19\n59.966229\n5.422490\n\n\n20\n52.161984\n6.409720\n\n\n21\n76.587964\n15.010477\n\n\n22\n60.919697\n8.070642\n\n\n23\n66.633016\n10.972099\n\n\n24\n73.619537\n14.777646\n\n\n25\n60.222473\n5.245556\n\n\n26\n59.257247\n8.672161\n\n\n27\n51.930291\n8.555463\n\n\n28\n59.430108\n6.081444\n\n\n29\n69.408718\n7.421905\n\n\n30\n65.298614\n12.313794\n\n\n31\n60.283830\n9.934439\n\n\n32\n60.853524\n7.795298\n\n\n33\n71.633347\n6.562796\n\n\n34\n69.140794\n10.282864\n\n\n35\n66.475390\n5.116392\n\n\n36\n63.047756\n8.662684\n\n\n37\n68.167828\n6.593206\n\n\n38\n64.748034\n3.705378\n\n\n39\n68.280434\n12.917868\n\n\n40\n60.405239\n8.696236\n\n\n41\n64.631325\n11.215060\n\n\n42\n58.259490\n6.832449\n\n\n43\n52.235247\n8.623084\n\n\n44\n79.877750\n7.843683\n\n\n\n\n\n\n\nDie Spaltenmittelwerte kann man dann wie folgt berechnen:\n\ndata.mean()\n\nessay    63.449914\nhours     8.349021\ndtype: float64"
  },
  {
    "objectID": "08/08.html#übungen",
    "href": "08/08.html#übungen",
    "title": "8 – Ein- und Ausgabe",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nGegeben sind die Zuweisungen name = \"Anna\", a = 7 und b = 13. Erzeugen Sie mit einem f-String eine Ausgabe der Form:\n\nHallo Anna! 7 / 13 ≈ 0.538, oder?\n\n\n\nÜbung 2\nErzeugen Sie eine tabellarische Ausgabe aus der folgenden Liste von Dictionaries:\nstudents = [\n    {\"name\": \"Lukas\", \"score\": 87.5},\n    {\"name\": \"Maya\", \"score\": 42.0},\n    {\"name\": \"Anna\", \"score\": 59.0},\n    {\"name\": \"Tim\", \"score\": 49.9},\n    {\"name\": \"Zoe\", \"score\": 100.0},\n]\nDie Ausgabe soll wie folgt aussehen:\n 1 | Lukas        |   87.5 | PASS\n 2 | Maya         |   42.0 | FAIL\n 3 | Anna         |   59.0 | PASS\n 4 | Tim          |   49.9 | FAIL\n 5 | Zoe          |  100.0 | PASS\nDie Zahlen in der ersten Spalte sollen rechtsbündig in einem Feld der Breite 2 ausgegeben werden, die Namen in der zweiten Spalte linksbündig in einem Feld der Breite 12, und die Punktzahlen in der dritten Spalte rechtsbündig in einem Feld der Breite 6 mit einer Nachkommastelle. In der vierten Spalte soll “PASS” ausgegeben werden, wenn die Punktzahl größer oder gleich 50 ist, ansonsten “FAIL”.\nLösen Sie die Aufgabe mit einer for-Schleife, in der Sie mit einem f-String jeden Eintrag in der Liste students (ein Dictionary) formatieren und ausgeben. Die Zahlen in der ersten Spalte müssen Sie selbst generieren, indem Sie die Schleifendurchläufe mitzählen. Dies können Sie z.B. mit der Funktion enumerate erreichen:\nfor no, student in enumerate(students, start=1):\n    ...  # ihre Lösung hier\n\n\nÜbung 3\nErstellen Sie eine Liste lst, welche die geraden Zahlen zwischen 0 und 100 (inklusive) beinhaltet, und speichern Sie diese Zahlen in eine Datei ue1.txt. In der Datei soll jede Zahl in einer eigenen Zeile stehen.\n\n\n\n\n\n\nHinweis\n\n\n\nZahlen sollten vor dem Schreiben in die Datei mit der Funktion str in Strings umgewandelt werden. Das Zeichen für einen Zeilenumbruch lautet \\n. Sie können z.B. eine for-Schleife über die Zahlenliste machen und die einzelnen Elemente nacheinander in die Datei schreiben. Alternativ können Sie auch die Liste in einen richtig formatierten String umwandeln (die String-Methode join ist hier hilfreich) und diesen dann in die Datei schreiben.\n\n\n\n\nÜbung 4\nVerwenden Sie wieder die Liste lst aus Übung 1, aber schreiben Sie die Zahlen nun so in eine Datei ue2.txt, dass diese durch Kommas getrennt in einer Zeile stehen.\n\n\nÜbung 5\nDas Spiel Scrabble eignet sich hervorragend, um über die Existenz von Wörtern zu diskutieren. Zumindest für die englische Ausgabe gibt es eine offizielle Wortliste, die man konsultieren kann, wenn man nicht sicher ist, ob es sich bei einer Kreation um ein gültiges Wort handelt oder nicht. Alle Wörter in dieser Datenbank können als Textdatei heruntergeladen werden.\nFür diese Übung laden Sie sich diese Datei herunter und speichern Sie sie in Ihrem Arbeitsverzeichnis ab. Lesen Sie die Datei dann in Python ein und finden Sie heraus, wie viele Wörter (Zeilen) sich in der Datei befinden.\n\n\n\n\n\n\nHinweis\n\n\n\nIterieren Sie mit einer for-Schleife über das Datei-Objekt und zählen Sie die Schleifendurchläufe mit. Am Ende der Schleife (d.h. am Ende der Datei) entspricht dann ihr Zähler der Zeilenanzahl der Datei (d.h. der Anzahl der Wörter). Beachten Sie, dass die ersten paar Zeilen in der Datei keine Wörter beinhalten!\nWenn man es ganz exakt machen möchte, sollte man auch noch überprüfen, ob die aktuelle Zeile auch tatsächlich ein Wort enthält (also keine Leerzeile ist).\n\n\n\n\nÜbung 6\nVerwenden Sie die Wörter-Datei aus Übung 3 und finden Sie heraus, wie viele Wörter mit mehr als 14 Buchstaben in der Liste enthalten sind (also Wörter mit 15 Buchstaben oder mehr).\n\n\n\n\n\n\nHinweis\n\n\n\nWenn Sie die Datei Zeile für Zeile einlesen, entfernen Sie unsichtbare Zeichen (wie z.B. Zeilenumbruch) mit der Methode strip, bevor Sie die Länge des aktuellen Wortes bestimmen (ansonsten ist die Länge immer um 1 größer als die Länge des Wortes, weil der Inhalt einer Zeile z.B. abandon\\n lautet, und \\n wird als ein Zeichen gezählt). Erhöhen Sie Ihren Zähler nur, wenn die Länge des aktuellen Wortes (ohne Zeilenumbruch) größer als 14 ist."
  },
  {
    "objectID": "08/08.html#footnotes",
    "href": "08/08.html#footnotes",
    "title": "8 – Ein- und Ausgabe",
    "section": "Fußnoten",
    "text": "Fußnoten\n\n\nComma-Separated Values↩︎"
  },
  {
    "objectID": "10/10.html",
    "href": "10/10.html",
    "title": "10 – Grafiken",
    "section": "",
    "text": "In Python gibt es eine große Anzahl an Paketen, welche sich auf das Erstellen von Grafiken spezialisiert haben. Eine Übersicht über dieses sehr umfangreiche Ökosystem gibt es hier, die bekanntesten Pakete sind momentan:\n\nMatplotlib\nSeaborn\nPlotly\nBokeh\nVega-Altair\n\nMatplotlib ist das älteste und bekannteste Paket, es ist aber manchmal etwas umständlich zu bedienen – dafür ist es möglich, Grafiken bis ins kleinste Detail anzupassen. Matplotlib erzeugt grundsätzlich statische Grafiken und ist daher nicht für interaktive Anwendungen geeignet. Nachdem viele Grafikpakete auf Matplotlib basieren, ist es auf jeden Fall hilfreich, wenn man zumindest ein grundlegendes Verständnis von Matplotlib besitzt.\nBokeh und Plotly können vor allem interaktive Grafiken für Webanwendungen erstellen. Seaborn und Vega-Altair haben sich auf statistische Grafiken spezialisiert. Seaborn baut auf Matplotlib auf und bietet sehr viele zusätzliche Grafiktypen zur Datenvisualisierung. Vega-Altair hat sich außerdem das Ziel gesetzt, komplexe Grafiken möglichst einfach erstellen zu können (auch interaktive Grafiken können damit erzeugt werden).\nNeben diesen häufig verwendeten Paketen gibt es noch plotnine, welches sehr ähnlich wie ggplot2 für R zu verwenden ist.\nKurz zusammengefasst kann man also die Pakete Matplotlib, seaborn und plotnine zur Erzeugung von klassischen statischen Grafiken sowie Vega-Altair, Bokeh und Plotly zur Erstellung von interaktiven Grafiken empfehlen.\nIn den folgenden Abschnitten werden wir uns mit Matplotlib beschäftigen und die Grundlagen zur Erstellung von Grafiken kennenlernen."
  },
  {
    "objectID": "10/10.html#allgemeines",
    "href": "10/10.html#allgemeines",
    "title": "10 – Grafiken",
    "section": "",
    "text": "In Python gibt es eine große Anzahl an Paketen, welche sich auf das Erstellen von Grafiken spezialisiert haben. Eine Übersicht über dieses sehr umfangreiche Ökosystem gibt es hier, die bekanntesten Pakete sind momentan:\n\nMatplotlib\nSeaborn\nPlotly\nBokeh\nVega-Altair\n\nMatplotlib ist das älteste und bekannteste Paket, es ist aber manchmal etwas umständlich zu bedienen – dafür ist es möglich, Grafiken bis ins kleinste Detail anzupassen. Matplotlib erzeugt grundsätzlich statische Grafiken und ist daher nicht für interaktive Anwendungen geeignet. Nachdem viele Grafikpakete auf Matplotlib basieren, ist es auf jeden Fall hilfreich, wenn man zumindest ein grundlegendes Verständnis von Matplotlib besitzt.\nBokeh und Plotly können vor allem interaktive Grafiken für Webanwendungen erstellen. Seaborn und Vega-Altair haben sich auf statistische Grafiken spezialisiert. Seaborn baut auf Matplotlib auf und bietet sehr viele zusätzliche Grafiktypen zur Datenvisualisierung. Vega-Altair hat sich außerdem das Ziel gesetzt, komplexe Grafiken möglichst einfach erstellen zu können (auch interaktive Grafiken können damit erzeugt werden).\nNeben diesen häufig verwendeten Paketen gibt es noch plotnine, welches sehr ähnlich wie ggplot2 für R zu verwenden ist.\nKurz zusammengefasst kann man also die Pakete Matplotlib, seaborn und plotnine zur Erzeugung von klassischen statischen Grafiken sowie Vega-Altair, Bokeh und Plotly zur Erstellung von interaktiven Grafiken empfehlen.\nIn den folgenden Abschnitten werden wir uns mit Matplotlib beschäftigen und die Grundlagen zur Erstellung von Grafiken kennenlernen."
  },
  {
    "objectID": "10/10.html#matplotlib",
    "href": "10/10.html#matplotlib",
    "title": "10 – Grafiken",
    "section": "Matplotlib",
    "text": "Matplotlib\nMit Matplotlib kann man verschiedenste Grafiken vor allem für wissenschaftliche Anwendungen erstellen. Meist stehen die darzustellenden Daten als NumPy-Arrays zur Verfügung.\n\n\n\n\n\n\nHinweis\n\n\n\nDie offizielle Matplotlib-Website beinhaltet einige Tutorials. Insbesondere der Quick Start Guide ist eine gute Ergänzung zu den Unterlagen dieser Einheit.\n\n\nWir beginnen wie immer mit den entsprechenden Import-Befehlen:\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nWir importieren hier matplotlib.pyplot (als plt) und nicht direkt matplotlib. Dies hat historische Gründe, denn die allermeisten Funktionen zur Erstellung von Grafiken befinden sich in matplotlib.pyplot und nicht direkt in matplotlib.\n\n\n\n\n\n\nWichtig\n\n\n\nMit Matplotlib erstellte Grafiken werden standardmäßig nicht angezeigt. Um eine Grafik in einem separaten Fenster anzuzeigen, muss man explizit den folgenden Befehl ausführen:\nplt.show()\nDieses Fenster blockiert aber den Python-Interpreter, d.h. man kann keine weiteren Befehle eingeben, so lange das Grafik-Fenster geöffnet ist. Um dieses Verhalten zu umgehen, kann man im interaktiven Python-Interpreter direkt nach dem Importieren folgenden Befehl eingeben:\nplt.ion()\nDamit werden Grafiken sofort nach deren Erstellung angezeigt und blockieren auch nicht den Python-Interpreter (“ion” steht für “interactive on”).\n\n\n\nErstellung von Grafiken\nUm mit Matplotlib Grafiken zu erzeugen, sollte man sich mit einigen Grundbegriffen sowie dem Aufbau einer Grafik vertraut machen, was in der folgenden Abbildung veranschaulicht wird (modifiziert von hier):\n\n\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\nfindfont: Font family 'Courier New' not found.\n\n\n\n\n\n\n\n\n\nFür den Anfang benötigen wir nur die zwei Begriffe Figure und Axes (in der Abbildung rot dargestellt). Eine Figure entspricht einer Abbildung, welche eine oder mehrere Grafiken (sogenannte Axes) enthalten kann.\nDie Funktion plt.subplots erzeugt eine Figure und die gewünschte Anzahl an Axes. Möchte man also z.B. eine Abbildung mit einer einzigen Grafik erzeugen, erstellt man diese beiden (leeren) Objekte mit folgendem Befehl:\n\nfig, ax = plt.subplots()\n\n\n\n\n\n\n\n\nDie Funktion gibt die Figure sowie die Axes zurück; wir nennen diese fig bzw. ax. Danach kann man Methoden des Axes-Objekts (welches wir ax genannt haben) aufrufen, um die gewünschte Grafik zu erstellen (mehr dazu im nächsten Abschnitt).\nWenn man mehrere Grafiken in einer Abbildung kombinieren möchte, kann man mit plt.subplots eine Figure mit der gewünschten Anzahl an Axes erzeugen. Dazu verwendet man das erste bzw. die ersten beiden Argumente, welche der Anzahl an Zeilen bzw. Spalten, in denen die Grafiken angeordnet werden sollen, entsprechen:\nfig, axes = plt.subplots(1, 3)  # 1 Zeile, 3 Spalten\n\n\n\n\n\n\n\n\n\nIn diesem Beispiel erzeugen wir eine Figure, welche drei Axes beinhaltet, die in einer Zeile und drei Spalten angeordnet sind. In anderen Worten sind das also drei Grafiken, die nebeneinander dargestellt werden. Diese drei Axes-Objekte haben wir axes genannt, und dabei handelt es sich um ein eindimensionales NumPy-Array. Wir können daher auf die einzelnen Elemente mittels axes[0], axes[1] und axes[2] zugreifen und damit die gewünschten Grafiken erzeugen.\nAuch eine echte zweidimensionale Anordnung, bestehend aus mehreren Zeilen und Spalten, ist so möglich. Zu beachten ist in diesem Fall aber, dass die zurückgegebenen Achsen in einem zweidimensionalen NumPy-Array vorhanden sind. Daher kann man die einzelnen Axes-Objekte auch mit einem zweidimensionalen Index (also Zeile und Spalte) ansprechen, z.B. axes[0, 2] wäre das Axes-Objekt in Zeile 0 (also erste Zeile) und Spalte 2 (also dritte Spalte).\nDamit sich in einer Figure mit mehreren Axes-Objekten keine Überlappungen ergeben, sollte man zum Abschluss folgende Zeile ausführen:\nfig.set_tight_layout(True)\nDies bewirkt, dass die Abstände zwischen den Axes-Objekten so angepasst werden, dass keine Texte oder andere Elemente abgeschnitten werden oder überlappen. Sehen wir uns das anhand eines Beispiels an. Zunächst erzeugen wir eine Grafik mit 2 Zeilen und 3 Spalten und verwenden das Standard-Layout:\n\nfig, axes = plt.subplots(2, 3)\n\n\n\n\n\n\n\n\nUnd so sieht die Grafik mit optimiertem Layout aus:\n\nfig, axes = plt.subplots(2, 3)\nfig.set_tight_layout(True)\n\n\n\n\n\n\n\n\n\n\nx/y-Grafiken\nMatplotlib unterstützt viele unterschiedliche Grafiktypen. Als erstes sehen wir uns an, wie wir Liniengrafiken (z.B. zur Darstellung von Zeitverläufen) erstellen können. Dazu verwenden wir die folgenden Beispieldaten x und y:\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\nEine Liniengrafik erhält man dann durch Aufruf der plot-Methode, welcher man die Daten für die x- bzw. y-Achsen übergibt:\n\nfig, ax = plt.subplots()\nax.plot(x, y)\n\n\n\n\n\n\n\n\nZur Erstellung eines Scatterplots verwendet man die Methode scatter, welche sinnvolle Standardwerte für diesen Grafiktyp bietet:\nfig, ax = plt.subplots()\nax.scatter(x, y)\n\n\n\n\n\n\n\n\n\n\n\nBalken- und Stängelgrafiken\nFür eine Balkengrafik benötigt man die Höhen der einzelnen Balken sowie die Positionen der Balken auf der x-Achse:\n\nx = np.arange(8)\ny = [17, 5, 23, 33, 12, 21, 27, 18]\n\nDiese Werte kann man dann mit der bar-Methode darstellen:\nfig, ax = plt.subplots()\nax.bar(x, y)\n\n\n\n\n\n\n\n\n\nDieselben Werte könnte man auch als Stängelgrafik visualisieren:\nfig, ax = plt.subplots()\nax.stem(x, y)\n\n\n\n\n\n\n\n\n\n\n\nHistogramme\nAuch komplexere statistische Grafiken können erzeugt werden. Dazu erstellen wir zunächst neue Beispieldaten x (10000 normalverteilte Zufallszahlen mit Mittelwert 100 und Standardabweichung 15):\n\nfrom numpy.random import default_rng\n\nrng = default_rng(1)\nx = rng.normal(loc=100, scale=15, size=10000)\n\nNun können wir die Verteilung von x als Histogramm darstellen:\nfig, ax = plt.subplots()\nax.hist(x, bins=50, edgecolor=\"white\")\n\n\n\n\n\n\n\n\n\nIn diesem Beispiel haben wir die Anzahl der Bins manuell auf 50 gesetzt. Außerdem verwenden wir eine weiße Randfarbe, um die einzelnen Balken besser voneinander abzugrenzen.\n\n\n\n\n\n\nTipp\n\n\n\nAlle Methoden (also z.B. auch plot, scatter, bar, stem) haben optionale Argumente, mit denen man das Aussehen der Grafik anpassen kann. Diese sind in den jeweiligen Dokumentationen beschrieben.\n\n\n\n\nBoxplots\nAuch Boxplots dienen zur Visualisierung der Verteilung einer oder auch mehrerer Variablen. Erzeugen wir daher die folgenden drei Beispiel-Arrays:\n\nx = rng.normal(loc=0, scale=5, size=10000)\ny = rng.exponential(5, size=10000)\nz = rng.poisson(2.8, size=10000)\n\nDie Verteilungen der drei Variablen können wir mit drei Boxplots darstellen:\nfig, ax = plt.subplots()\nax.boxplot([x, y, z])\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nEine Box erstreckt sich vom ersten bis zum dritten Quartil, ihre Höhe entspricht also dem Interquartilsabstand (IQR). Die orange Linie innerhalb der Box entspricht dem Median. Die sogenannten Whiskers außerhalb der Box erstrecken sich bis zum 1,5-fachen des IQR über bzw. unter dem ersten bzw. dritten Quartil. Punkte außerhalb dieser Grenzen werden als Ausreißer einzeln dargestellt.\n\n\n\n\nViolinenplots\nEine Alternative zu Boxplots sind sogenannte Violinenplots. Die Daten aus dem vorigen Abschnitt könnte man also auch so darstellen:\nfig, ax = plt.subplots()\nax.violinplot([x, y, z])\n\n\n\n\n\n\n\n\n\n\n\nWeitere statistische Grafiken\nMöchte man beispielsweise Scatterplots mit überlagerten Regressionsgeraden oder andere komplexere Grafiktypen erstellen, sollte man einen Blick auf andere Pakete wie seaborn oder plotnine werfen. Mit Matplotlib wäre das zwar prinzipiell auch möglich, aber es wären sehr viele manuelle Schritte notwendig (z.B. müsste man selbst ein lineares Regressionsmodell rechnen, um dieses dann als Gerade in eine Grafik einzubinden).\n\n\nTitel und Achsenbeschriftungen\nMatplotlib fügt den Grafiken standardmäßig keine Titel oder Achsenbeschriftungen hinzu. Selbstverständlich kann man das aber anpassen, und zwar mit speziellen Methoden. Nehmen wir als Beispiel nochmals die allererste Grafik, die wir in diesen Unterlagen erzeugt haben:\n\nx = np.linspace(0, 10, 100)\ny = np.sin(x)\n\nfig, ax = plt.subplots()\nax.plot(x, y)\n\n\n\n\n\n\n\n\nWir können dieser Grafik einen Titel sowie Achsenbeschriftungen hinzufügen:\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set_title(\"Eine Sinuskurve\")\nax.set_xlabel(\"Zeit (s)\")\nax.set_ylabel(\"Amplitude (V)\")\n\n\n\n\n\n\n\n\n\nAlternativ könnte man statt den drei separaten Methoden auch folgende Variante verwenden:\nfig, ax = plt.subplots()\nax.plot(x, y)\nax.set(title=\"Eine Sinuskurve\", xlabel=\"Zeit (s)\", ylabel=\"Amplitude (V)\")"
  },
  {
    "objectID": "10/10.html#übungen",
    "href": "10/10.html#übungen",
    "title": "10 – Grafiken",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nLesen Sie die Daten in der Datei airquality.csv mit folgendem Code in ein NumPy-Array namens air ein (beachten Sie, dass sich die Datei im Arbeitsverzeichnis befinden muss):\nimport numpy as np\nair = np.genfromtxt(\"airquality.csv\", delimiter=\",\", skip_header=1)\nDieser Datensatz den Verlauf von vier verschiedenen Luftgütewerten über einen Zeitraum von fünf Monaten.\nMit welchem Befehl können Sie die Anzahl der Zeilen und Spalten von air herausfinden?\n\n\nÜbung 2\nDie Spalten in air beinhalten Messwerte für folgende Variablen:\n\nOzonkonzentration (in ppb, oder “parts per billion”)\nSonneneinstrahlung (in der Einheit Langleys)\nWindgeschwindigkeit (in Meilen pro Stunde)\nTemperatur (in Grad Fahrenheit)\nMonat (Zahlenwert zwischen 1 und 12)\nTag (Zahlenwert zwischen 1 und 31)\n\nErstellen Sie für jede Spalte einen eigenen Namen (verwenden Sie die Namen ozone, solar, wind, temp, month und day). Verwenden Sie diese Namen in allen folgenden Übungen.\n\n\nÜbung 3\nErzeugen Sie mit Matplotlib ein Histogramm der Wind-Werte.\n\n\nÜbung 4\nErstellen Sie mit Matplotlib einen Scatterplot mit der Temperatur auf der x-Achse und dem Wind auf der y-Achse.\n\n\nÜbung 5\nStellen Sie folgende vier Grafiken in einer Abbildung dar (verwenden Sie dazu eine Anordung aus zwei Zeilen und zwei Spalten):\n\nEin Scatterplot von ozone gegen solar.\nEine Liniengrafik mit dem Verlauf von temp.\nEin Violinenplot mit den Werten von temp für die fünf Monate. Die Werte für diese Monate entsprechen den folgenden Slices: temp[:31], temp[31:61], temp[61:92], temp[92:123], temp[123:].\nEin Scatterplot von wind gegen ozone.\n\nFügen Sie geeignete Achsenbeschriftungen hinzu und vergessen Sie nicht, zum Schluss fig.set_tight_layout(True) aufzurufen!"
  },
  {
    "objectID": "01/01-solutions.html",
    "href": "01/01-solutions.html",
    "title": "1 – Lösungen",
    "section": "",
    "text": "Die installierte Python-Version ist direkt nach dem Starten des interaktiven Python-Interpreters zu sehen. Die aktuellste Version kann von der offiziellen Website heruntergeladen werden."
  },
  {
    "objectID": "01/01-solutions.html#übung-1",
    "href": "01/01-solutions.html#übung-1",
    "title": "1 – Lösungen",
    "section": "",
    "text": "Die installierte Python-Version ist direkt nach dem Starten des interaktiven Python-Interpreters zu sehen. Die aktuellste Version kann von der offiziellen Website heruntergeladen werden."
  },
  {
    "objectID": "01/01-solutions.html#übung-2",
    "href": "01/01-solutions.html#übung-2",
    "title": "1 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\nimport antigravity öffnet den Webbrowser mit dem xkcd-Comic über Python.\nimport this gibt das Zen von Python am Bildschirm aus:\n\nThe Zen of Python, by Tim Peters\n\nBeautiful is better than ugly.\nExplicit is better than implicit.\nSimple is better than complex.\nComplex is better than complicated.\nFlat is better than nested.\nSparse is better than dense.\nReadability counts.\nSpecial cases aren’t special enough to break the rules.\nAlthough practicality beats purity.\nErrors should never pass silently.\nUnless explicitly silenced.\nIn the face of ambiguity, refuse the temptation to guess.\nThere should be one – and preferably only one – obvious way to do it.\nAlthough that way may not be obvious at first unless you’re Dutch.\nNow is better than never.\nAlthough never is often better than right now.\nIf the implementation is hard to explain, it’s a bad idea.\nIf the implementation is easy to explain, it may be a good idea.\nNamespaces are one honking great idea – let’s do more of those!\n\nDer Befehl import math bewirkt, dass man danach die im Modul math enthaltenen Befehle verwenden kann."
  },
  {
    "objectID": "01/01-solutions.html#übung-3",
    "href": "01/01-solutions.html#übung-3",
    "title": "1 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\n\nimport math\n\n4 * math.pi * 6371**2\n\n510064471.90978825\n\n\nDie Erdoberfläche beträgt also ungefähr 510 Millionen km²."
  },
  {
    "objectID": "01/01-solutions.html#übung-4",
    "href": "01/01-solutions.html#übung-4",
    "title": "1 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\n\n(11 + 27 + 15 + 10 + 33 + 18 + 25 + 22 + 39 + 11) / 10\n\n21.1\n\n\n\n(11 * 27 * 15 * 10 * 33 * 18 * 25 * 22 * 39 * 11)**(1/10)\n\n19.034672698028626"
  },
  {
    "objectID": "01/01-solutions.html#übung-5",
    "href": "01/01-solutions.html#übung-5",
    "title": "1 – Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\n\nimport math\n\n((5**5 - math.pi) * 19/3) / (math.sqrt(13) + 7**(2/3))\n\n2721.563542502226"
  },
  {
    "objectID": "01/01-solutions.html#übung-6",
    "href": "01/01-solutions.html#übung-6",
    "title": "1 – Lösungen",
    "section": "Übung 6",
    "text": "Übung 6\nDen Befehl math.Sqrt(4) gibt es nicht – da Python zwischen Groß- und Kleinschreibung unterscheidet, ist math.Sqrt nicht identisch mit math.sqrt. Letzteres ist die korrekte Schreibweise der Wurzelfunktion, welche im math-Modul enthalten ist.\nRichtig wäre also:\n\nmath.sqrt(4)\n\n2.0"
  },
  {
    "objectID": "a1/a1-solutions.html",
    "href": "a1/a1-solutions.html",
    "title": "Lösungen",
    "section": "",
    "text": "def serial(r1, r2):\n    return r1 + r2\n\n\ndef parallel(r1, r2):\n    return 1 / (1 / r1 + 1 / r2)\n\n\nr1 = 10\nr2 = 20\nr3 = 50\n\nprint(serial(r1, r2))\nprint(parallel(r1, r2))\nprint(parallel(serial(r1, r2), r3))\n\n30\n6.666666666666666\n18.75"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-1",
    "href": "a1/a1-solutions.html#übung-1",
    "title": "Lösungen",
    "section": "",
    "text": "def serial(r1, r2):\n    return r1 + r2\n\n\ndef parallel(r1, r2):\n    return 1 / (1 / r1 + 1 / r2)\n\n\nr1 = 10\nr2 = 20\nr3 = 50\n\nprint(serial(r1, r2))\nprint(parallel(r1, r2))\nprint(parallel(serial(r1, r2), r3))\n\n30\n6.666666666666666\n18.75"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-2",
    "href": "a1/a1-solutions.html#übung-2",
    "title": "Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\nEine einfache Implementierung der Funktion verwendet einen langen if/elif/else-Block:\ndef month_name(month):\n    if month == 1:\n        return \"Januar\"\n    elif month == 2:\n        return \"Februar\"\n    elif month == 3:\n        return \"März\"\n    elif month == 4:\n        return \"April\"\n    elif month == 5:\n        return \"Mai\"\n    elif month == 6:\n        return \"Juni\"\n    elif month == 7:\n        return \"Juli\"\n    elif month == 8:\n        return \"August\"\n    elif month == 9:\n        return \"September\"\n    elif month == 10:\n        return \"Oktober\"\n    elif month == 11:\n        return \"November\"\n    elif month == 12:\n        return \"Dezember\"\n\n\nwhile True:\n    month = int(input(\"Bitte geben Sie eine Zahl zwischen 1 und 12 ein: \"))\n    if 1 &lt;= month &lt;= 12:\n        break\n    print(\"Ungültige Eingabe, bitte versuchen Sie es erneut.\")\n\nprint(month_name(month))\nEtwas kürzer könnte man die Funktion mit Hilfe einer Liste schreiben (der restliche Code bleibt gleich):\ndef month_name(month):\n    months = [\n        \"Januar\",\n        \"Februar\",\n        \"März\",\n        \"April\",\n        \"Mai\",\n        \"Juni\",\n        \"Juli\",\n        \"August\",\n        \"September\",\n        \"Oktober\",\n        \"November\",\n        \"Dezember\",\n    ]\n    return months[month - 1]\nAuch mit einem Dictionary lässt sich die Funktion umsetzen:\ndef month_name(month):\n    months = {\n        1: \"Januar\",\n        2: \"Februar\",\n        3: \"März\",\n        4: \"April\",\n        5: \"Mai\",\n        6: \"Juni\",\n        7: \"Juli\",\n        8: \"August\",\n        9: \"September\",\n        10: \"Oktober\",\n        11: \"November\",\n        12: \"Dezember\",\n    }\n    return months[month]\n\n\n\n\n\n\nHinweis\n\n\n\nEine sehr kompakte Lösung ergibt sich, wenn man das Modul calendar aus der Standardbibliothek verwendet. Dies setzt aber natürlich voraus, dass man das Modul kennt (in diesem Kurs haben wir es nicht behandelt, daher ist diese Lösung nur der Vollständigkeit halber aufgeführt):\nimport calendar\n\ndef month_name(month):\n    return calendar.month_name[month]"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-3",
    "href": "a1/a1-solutions.html#übung-3",
    "title": "Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\n\ndef count_words(text, sep=\" \"):\n    return len(text.split(sep))\n\n\ntext = (\n    \"Python is an easy to learn, powerful programming language. It has efficient \"\n    \"high-level data structures and a simple but effective approach to object-oriented \"\n    \"programming. Python's elegant syntax and dynamic typing, together with its \"\n    \"interpreted nature, make it an ideal language for scripting and rapid application \"\n    \"development in many areas.\"\n)\ncount_words(text)\n\n49"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-4",
    "href": "a1/a1-solutions.html#übung-4",
    "title": "Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\n\ndef factorial(n):\n    if n == 0:\n        return 1\n    result = 1\n    for i in range(1, n + 1):\n        result *= i\n    return result\n\nfactorial(5)\n\n120"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-5",
    "href": "a1/a1-solutions.html#übung-5",
    "title": "Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\n\ndef is_divisible(n, m):\n    return n % m == 0\n\n\nprint(is_divisible(10, 2))\nprint(is_divisible(10, 3))\nprint(is_divisible(10, 5))\nprint(is_divisible(10, 7))\n\nTrue\nFalse\nTrue\nFalse"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-6",
    "href": "a1/a1-solutions.html#übung-6",
    "title": "Lösungen",
    "section": "Übung 6",
    "text": "Übung 6\nDas Problem ist, dass der elif-Zweig nach dem else-Block steht. In Python muss der (optionale) else-Block immer am Ende eines if/elif/else-Blocks stehen. Die korrigierte Version sieht also wie folgt aus:\nx = 10\n\nif x &gt; 0:\n    print(\"x is positive.\")\nelif x &lt; 0:\n    print(\"x is negative.\")\nelse:\n    print(\"x is zero.\")"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-7",
    "href": "a1/a1-solutions.html#übung-7",
    "title": "Lösungen",
    "section": "Übung 7",
    "text": "Übung 7\n\nimport math\n\nnumbers = [math.sqrt(i) for i in range(0, 1001, 10)]\nprint(len(numbers), sum(numbers))\n\n101 2123.3522772551064"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-8",
    "href": "a1/a1-solutions.html#übung-8",
    "title": "Lösungen",
    "section": "Übung 8",
    "text": "Übung 8\nDer Code funktioniert nicht, weil nach der for-Schleife ein Doppelpunkt (:) fehlt. Der korrekte Code lautet:\nfor x in range(10):\n    print(x)"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-9",
    "href": "a1/a1-solutions.html#übung-9",
    "title": "Lösungen",
    "section": "Übung 9",
    "text": "Übung 9\n\nimport math\n\nresult = (17 * (math.sqrt(5) + 2/3)) / (27.7 - 3**math.pi) + 42**(2/7)\nprint(f\"{result:.2f}\")\n\n-9.93"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-10",
    "href": "a1/a1-solutions.html#übung-10",
    "title": "Lösungen",
    "section": "Übung 10",
    "text": "Übung 10\nDer Code funktioniert nicht, weil lambda ein reserviertes Schlüsselwort in Python ist und daher nicht als Name verwendet werden kann. Der korrekte Code könnte wie folgt aussehen:\nalpha = 5\nlambda_ = 7\nprint(alpha + lambda_)"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-11",
    "href": "a1/a1-solutions.html#übung-11",
    "title": "Lösungen",
    "section": "Übung 11",
    "text": "Übung 11\n\nimport math\n\ndef std(x):\n    n = len(x)\n    mean = sum(x) / n\n    var = sum([(xi - mean)**2 for xi in x]) / (n - 1)\n    return math.sqrt(var)\n\nstd([10, 12, 23, 23, 16, 23, 21, 16])\n\n5.237229365663817"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-12",
    "href": "a1/a1-solutions.html#übung-12",
    "title": "Lösungen",
    "section": "Übung 12",
    "text": "Übung 12\n\ndef get_even(x):\n    return [xi for xi in x if xi % 2 == 0]\n\nget_even([1, 45, -4, -5, 17, 2])\n\n[-4, 2]"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-13",
    "href": "a1/a1-solutions.html#übung-13",
    "title": "Lösungen",
    "section": "Übung 13",
    "text": "Übung 13\nWichtig ist, dass die Teilbarkeit durch 3 und 5 (also 15) zuerst überprüft wird!\n\ndef fizzbuzz(n):\n    if n % 15 == 0:\n        return \"Fizzbuzz\"\n    elif n % 3 == 0:\n        return \"Fizz\"\n    elif n % 5 == 0:\n        return \"Buzz\"\n    else:\n        return str(n)\n\nfor i in range(1, 16):\n    print(fizzbuzz(i))\n\n1\n2\nFizz\n4\nBuzz\nFizz\n7\n8\nFizz\nBuzz\n11\nFizz\n13\n14\nFizzbuzz"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-14",
    "href": "a1/a1-solutions.html#übung-14",
    "title": "Lösungen",
    "section": "Übung 14",
    "text": "Übung 14\n\ndef add(x, y=1):\n    return x + y"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-15",
    "href": "a1/a1-solutions.html#übung-15",
    "title": "Lösungen",
    "section": "Übung 15",
    "text": "Übung 15\n\nEs fehlt das verpflichtende Argument für x.\nDas Argument für x wurde doppelt übergeben, einmal als positionales Argument (4) und einmal als Schlüsselwortargument (x=2).\nEs fehlt das verpflichtende Argument für x."
  },
  {
    "objectID": "a1/a1-solutions.html#übung-16",
    "href": "a1/a1-solutions.html#übung-16",
    "title": "Lösungen",
    "section": "Übung 16",
    "text": "Übung 16\n\ndef is_even(n):\n    return n % 2 == 0\n\nprint(is_even(10))\nprint(is_even(11))\n\nTrue\nFalse"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-17",
    "href": "a1/a1-solutions.html#übung-17",
    "title": "Lösungen",
    "section": "Übung 17",
    "text": "Übung 17\n\ndef sign(n):\n    if n &gt; 0:\n        return 1\n    elif n &lt; 0:\n        return -1\n    else:\n        return 0\n\nBeachten Sie, dass der else-Block nicht notwendig ist und weggelassen werden kann:\n\ndef sign(n):\n    if n &gt; 0:\n        return 1\n    elif n &lt; 0:\n        return -1\n    return 0\n\n\n\n\n\n\n\nTipp\n\n\n\nEine noch kompaktere Version verwendet die Tatsache, dass in Python Werte vom Typ bool als Ganzzahlen interpretiert werden können (True entspricht 1, False entspricht 0):\n\ndef sign(n):\n    return (n &gt; 0) - (n &lt; 0)\n\nIm Rahmen dieses Kurses ist diese Lösung aber zu fortgeschritten, da wir diese Eigenschaft von bool-Werten nicht behandelt haben."
  },
  {
    "objectID": "a1/a1-solutions.html#übung-18",
    "href": "a1/a1-solutions.html#übung-18",
    "title": "Lösungen",
    "section": "Übung 18",
    "text": "Übung 18\n\nx = \"Pythonista\"\n\nfor c in x:\n    print(c)\n\nP\ny\nt\nh\no\nn\ni\ns\nt\na"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-19",
    "href": "a1/a1-solutions.html#übung-19",
    "title": "Lösungen",
    "section": "Übung 19",
    "text": "Übung 19\n\ny = [\"This\", \"is\", \"a\", \"sample\", \"list\"]\nz = [word.upper() for word in y]\nz\n\n['THIS', 'IS', 'A', 'SAMPLE', 'LIST']"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-20",
    "href": "a1/a1-solutions.html#übung-20",
    "title": "Lösungen",
    "section": "Übung 20",
    "text": "Übung 20\n\ns = \"Donaudampfschifffahrtsgesellschaft\"\nprint(len(s))\nprint(s.index(\"f\"))\nprint(s.count(\"e\"))\n\n34\n9\n2"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-21",
    "href": "a1/a1-solutions.html#übung-21",
    "title": "Lösungen",
    "section": "Übung 21",
    "text": "Übung 21\n\nx = [-13, 22, -2, -14, 33, -16]\ny = [abs(num) for num in x]\ny\n\n[13, 22, 2, 14, 33, 16]"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-22",
    "href": "a1/a1-solutions.html#übung-22",
    "title": "Lösungen",
    "section": "Übung 22",
    "text": "Übung 22\n\nfrom numpy.random import default_rng\n\nrng = default_rng(1)\nx = rng.integers(0, 101, size=(15, 5))\nx.mean(axis=0)\n\narray([42.        , 61.33333333, 55.6       , 38.6       , 49.93333333])"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-23",
    "href": "a1/a1-solutions.html#übung-23",
    "title": "Lösungen",
    "section": "Übung 23",
    "text": "Übung 23\n\nimport numpy as np\n\nx = np.linspace(10, 13, 1000)"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-24",
    "href": "a1/a1-solutions.html#übung-24",
    "title": "Lösungen",
    "section": "Übung 24",
    "text": "Übung 24\n\nfrom numpy.random import default_rng\n\nrng = default_rng(2)\nx = 10 + 2 * rng.standard_normal(10000)\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.hist(x, bins=50)\nplt.show()"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-25",
    "href": "a1/a1-solutions.html#übung-25",
    "title": "Lösungen",
    "section": "Übung 25",
    "text": "Übung 25\n\nfrom numpy.random import default_rng\n\nrng = default_rng(2)\nx = 10 + 2 * rng.standard_normal(10000)\n\nimport matplotlib.pyplot as plt\n\nfig, ax = plt.subplots()\nax.bar(range(100), x[:100])\nplt.show()"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-26",
    "href": "a1/a1-solutions.html#übung-26",
    "title": "Lösungen",
    "section": "Übung 26",
    "text": "Übung 26\n\nwith open(\"shakespeare.txt\") as f:\n    lines = 0\n    for line in f:\n        lines += 1\n        if \"Go antickly, show outward hideousness,\" in line:\n            print(f'\"Go antickly, show outward hideousness,\" found in line {lines}.')\n\nprint(f\"Total number of lines: {lines}\")\n\n\"Go antickly, show outward hideousness,\" found in line 92053.\nTotal number of lines: 151570"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-27",
    "href": "a1/a1-solutions.html#übung-27",
    "title": "Lösungen",
    "section": "Übung 27",
    "text": "Übung 27\n\nnumbers = []\nfor n in range(1001):\n    if (n % 3 == 0 or n % 5 == 0) and n % 15 != 0:\n        numbers.append(n)\n\nsum(numbers)\n\n201003"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-28",
    "href": "a1/a1-solutions.html#übung-28",
    "title": "Lösungen",
    "section": "Übung 28",
    "text": "Übung 28\n\nx = \"Pythonista\"\nfor c in x:\n    print(c.upper(), end='-')\n\nP-Y-T-H-O-N-I-S-T-A-"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-29",
    "href": "a1/a1-solutions.html#übung-29",
    "title": "Lösungen",
    "section": "Übung 29",
    "text": "Übung 29\n\ndef kmh_to_mph(kmh):\n    return kmh / 1.609\n\ndef mph_to_kmh(mph):\n    return 1.609 * mph\n    \nkmh_to_mph(mph_to_kmh(65))\n\n65.0"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-30",
    "href": "a1/a1-solutions.html#übung-30",
    "title": "Lösungen",
    "section": "Übung 30",
    "text": "Übung 30\nJede Listen-Methode ändert die Liste in-place und gibt daher nichts (None) zurück – daher wird im Beispiel x auf None gesetzt. Die korrekte Variante ist:\nx = [1, 2, 3, 4]\nx.append(5)"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-31",
    "href": "a1/a1-solutions.html#übung-31",
    "title": "Lösungen",
    "section": "Übung 31",
    "text": "Übung 31\nDa der String selbst doppelte Anführungszeichen enthält, können wir diesen entweder mit einfachen Anführungszeichen umschließen:\ns = 'Er sagte: \"Sicher!\"'\nAlternativ können wir die doppelten Anführungszeichen mit einem Backslash maskieren (Escape-Zeichen):\ns = \"Er sagte: \\\"Sicher!\\\"\""
  },
  {
    "objectID": "a1/a1-solutions.html#übung-32",
    "href": "a1/a1-solutions.html#übung-32",
    "title": "Lösungen",
    "section": "Übung 32",
    "text": "Übung 32\n\nx = \"abcdefghijklmnopqrstuvwxyz\"\na = x[::2]\nb = x[1::2]\nprint(a)\nprint(b)\n\nacegikmoqsuwy\nbdfhjlnprtvxz"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-33",
    "href": "a1/a1-solutions.html#übung-33",
    "title": "Lösungen",
    "section": "Übung 33",
    "text": "Übung 33\n\ns = \"eins/zwei/drei/vier/fünf/sechs/sieben/acht\"\nwords = s.split(\"/\")\nwords\n\n['eins', 'zwei', 'drei', 'vier', 'fünf', 'sechs', 'sieben', 'acht']"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-34",
    "href": "a1/a1-solutions.html#übung-34",
    "title": "Lösungen",
    "section": "Übung 34",
    "text": "Übung 34\n\ndef replace_vowels(text, char):\n    vowels = \"aeiouAEIOU\"\n    for vowel in vowels:\n        text = text.replace(vowel, char)\n    return text\n\nprint(replace_vowels(\"Hello World!\", \"*\"))\nprint(replace_vowels(\"PYTHON IS FUN\", \"#\"))\n\nH*ll* W*rld!\nPYTH#N #S F#N"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-35",
    "href": "a1/a1-solutions.html#übung-35",
    "title": "Lösungen",
    "section": "Übung 35",
    "text": "Übung 35\nDer Code funktioniert nicht, weil die eingebaute Funktion sum nur ein einziges Argument (wie z.B. eine Liste oder ein Tupel) akzeptiert. Der Versuch, mehrere separate Argumente zu übergeben, führt zu einem Fehler.\nEin korrekter Funktionsaufruf wäre daher:\nsum([1, 2, 3, 4, 5])"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-36",
    "href": "a1/a1-solutions.html#übung-36",
    "title": "Lösungen",
    "section": "Übung 36",
    "text": "Übung 36\nLösung mit einer while-Schleife:\n\ndef countdown(start=5, step=1):\n    n = start\n    while n &gt;= 0:\n        print(n, end=\" - \")\n        n -= step\n    print(\"Liftoff!\")\n\ncountdown()\ncountdown(7, 2)\n\n5 - 4 - 3 - 2 - 1 - 0 - Liftoff!\n7 - 5 - 3 - 1 - Liftoff!\n\n\nLösung mit einer for-Schleife:\n\ndef countdown(start=5, step=1):\n    for n in range(start, -1, -step):\n        print(n, end=\" - \")\n    print(\"Liftoff!\")\n\ncountdown()\ncountdown(7, 2)\n\n5 - 4 - 3 - 2 - 1 - 0 - Liftoff!\n7 - 5 - 3 - 1 - Liftoff!"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-37",
    "href": "a1/a1-solutions.html#übung-37",
    "title": "Lösungen",
    "section": "Übung 37",
    "text": "Übung 37\n\nfrom numpy.random import default_rng\nrng = default_rng(2)\ny = 10 + 2 * rng.standard_normal(10000)\n\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 2)\naxes[0].scatter(range(1, 101), y[:100])\naxes[1].hist(y, bins=30)\n\nfig.set_tight_layout(True)\nplt.show()"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-38",
    "href": "a1/a1-solutions.html#übung-38",
    "title": "Lösungen",
    "section": "Übung 38",
    "text": "Übung 38\n\nx = [\"This\", \"is\", \"a\", \"sample\", \"list\"]\nlengths = [len(word) for word in x]\nlengths\n\n[4, 2, 1, 6, 4]"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-39",
    "href": "a1/a1-solutions.html#übung-39",
    "title": "Lösungen",
    "section": "Übung 39",
    "text": "Übung 39\n\ndef is_anagram(str1, str2):\n    return sorted(str1) == sorted(str2)\n\nprint(is_anagram(\"listen\", \"silent\"))\nprint(is_anagram(\"hello\", \"world\"))\n\nTrue\nFalse"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-40",
    "href": "a1/a1-solutions.html#übung-40",
    "title": "Lösungen",
    "section": "Übung 40",
    "text": "Übung 40\n\ndef filter_numbers(numbers, even=True):\n    if even:\n        return [n for n in numbers if n % 2 == 0]\n    else:\n        return [n for n in numbers if n % 2 != 0]"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-41",
    "href": "a1/a1-solutions.html#übung-41",
    "title": "Lösungen",
    "section": "Übung 41",
    "text": "Übung 41\n\nfor i in range(1, 11):\n    print(f\"Hello number {i}!\")\n\nHello number 1!\nHello number 2!\nHello number 3!\nHello number 4!\nHello number 5!\nHello number 6!\nHello number 7!\nHello number 8!\nHello number 9!\nHello number 10!"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-42",
    "href": "a1/a1-solutions.html#übung-42",
    "title": "Lösungen",
    "section": "Übung 42",
    "text": "Übung 42\n\ndef ps_to_kw(ps):\n    return ps / 1.36\n\ndef kw_to_ps(kw):\n    return kw * 1.36\n\nprint(ps_to_kw(100))\nprint(kw_to_ps(73.53))\n\n73.52941176470588\n100.00080000000001"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-43",
    "href": "a1/a1-solutions.html#übung-43",
    "title": "Lösungen",
    "section": "Übung 43",
    "text": "Übung 43\n\ns = \"supercalifragilisticexpialidocious\"\nprint(\"1.\", len(s))\nfirst_i = s.index(\"i\")\nprint(\"2.\", first_i)\nsecond_i = s.index(\"i\", first_i + 1)\nprint(\"3.\", second_i)\nprint(\"4.\", s.count(\"i\"))\nprint(\"5.\", s.upper())\nprint(\"6.\", s.replace(\"i\", \"!\"))\n\n1. 34\n2. 8\n3. 13\n4. 7\n5. SUPERCALIFRAGILISTICEXPIALIDOCIOUS\n6. supercal!frag!l!st!cexp!al!doc!ous"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-44",
    "href": "a1/a1-solutions.html#übung-44",
    "title": "Lösungen",
    "section": "Übung 44",
    "text": "Übung 44\n\ndef longest_word(sentence):\n    words = sentence.split()\n    longest = \"\"\n    for word in words:\n        if len(word) &gt; len(longest):\n            longest = word\n    return longest\n\nlongest_word(\"The quick brown fox jumps over the lazy dog\")\n\n'quick'"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-45",
    "href": "a1/a1-solutions.html#übung-45",
    "title": "Lösungen",
    "section": "Übung 45",
    "text": "Übung 45\n\nimport math\n\nx = [math.sqrt(i) for i in range(300, 701) if i % 2 == 0]\n\nprint(len(x))\nprint(sum(x))\n\n201\n4463.256267295718"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-46",
    "href": "a1/a1-solutions.html#übung-46",
    "title": "Lösungen",
    "section": "Übung 46",
    "text": "Übung 46\n\ndef count_lower(s):\n    count = 0\n    for char in s:\n        if char.islower():\n            count += 1\n    return count\n\nprint(count_lower(\"Hello World!\"))\nprint(count_lower(\"WHAT IS GOING ON???\"))\nprint(count_lower(\"nnYzKllLSIkcJD4eEx\"))\n\n8\n0\n9"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-47",
    "href": "a1/a1-solutions.html#übung-47",
    "title": "Lösungen",
    "section": "Übung 47",
    "text": "Übung 47\n\ndef check_parity(n):\n    if n % 2 == 0:\n        return 0\n    else:\n        return 1\n\nprint(check_parity(4))\nprint(check_parity(-7))\n\n0\n1"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-48",
    "href": "a1/a1-solutions.html#übung-48",
    "title": "Lösungen",
    "section": "Übung 48",
    "text": "Übung 48\nDer Code funktioniert nicht, weil lambda ein reserviertes Schlüsselwort in Python ist und daher nicht als Funktionsname verwendet werden kann. Um die Funktion korrekt zu implementieren, sollte ein anderer Name verwendet werden, zum Beispiel lambda_:\ndef lambda_(x):\n    return x + 1"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-49",
    "href": "a1/a1-solutions.html#übung-49",
    "title": "Lösungen",
    "section": "Übung 49",
    "text": "Übung 49\n\ndef cm_to_inches(cm):\n    return cm / 2.54\n\ndef inches_to_cm(inches):\n    return inches * 2.54\n\nprint(cm_to_inches(10))\nprint(inches_to_cm(5))\nprint(cm_to_inches(inches_to_cm(5)))\n\n3.937007874015748\n12.7\n5.0"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-50",
    "href": "a1/a1-solutions.html#übung-50",
    "title": "Lösungen",
    "section": "Übung 50",
    "text": "Übung 50\n\ndef sum_squares(numbers):\n    return sum([x**2 for x in numbers])\n\nprint(sum_squares([1, 2, 3, 4, 5]))\n\n55"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-51",
    "href": "a1/a1-solutions.html#übung-51",
    "title": "Lösungen",
    "section": "Übung 51",
    "text": "Übung 51\n\nfrom numpy.random import default_rng\n\nrng = default_rng(1)\nx = rng.normal(10, 2, 1000)\ny = rng.uniform(5, 15, 1000)\nz = rng.chisquare(6, 1000)\n\nimport matplotlib.pyplot as plt\n\nfig, axes = plt.subplots(1, 3)\naxes[0].scatter(x, y)\naxes[1].scatter(x, z)\naxes[2].scatter(y, z)\nfig.set_tight_layout(True)"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-52",
    "href": "a1/a1-solutions.html#übung-52",
    "title": "Lösungen",
    "section": "Übung 52",
    "text": "Übung 52\n\ndef is_prime(n):\n    if n &lt;= 1:\n        return False\n    for i in range(2, n):\n        if n % i == 0:\n            return False\n    return True\n\nprint(is_prime(7))\nprint(is_prime(10))\n\nTrue\nFalse\n\n\n\n\n\n\n\n\nTipp\n\n\n\nUm die Effizienz der Funktion zu verbessern, können Sie die Schleife so ändern, dass sie nur bis zur Quadratwurzel von \\(n\\) (inklusive) geht. Wenn \\(n\\) durch eine Zahl größer als seine Quadratwurzel teilbar ist, muss es auch durch eine kleinere Zahl teilbar sein."
  },
  {
    "objectID": "a1/a1-solutions.html#übung-53",
    "href": "a1/a1-solutions.html#übung-53",
    "title": "Lösungen",
    "section": "Übung 53",
    "text": "Übung 53\n\ndef f(x):\n    return x // 2 if x % 2 == 0 else 3 * x + 1\n\nn = 1000\ni = 0\nwhile n &gt; 1:\n    n = f(n)\n    i += 1\nprint(i)\n\n111"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-54",
    "href": "a1/a1-solutions.html#übung-54",
    "title": "Lösungen",
    "section": "Übung 54",
    "text": "Übung 54\nIm Funktionskopf fehlen die Klammern nach f für die (leere) Parameterliste. Der korrekte Code lautet:\ndef f():\n    return 42"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-55",
    "href": "a1/a1-solutions.html#übung-55",
    "title": "Lösungen",
    "section": "Übung 55",
    "text": "Übung 55\n\nprint(\"Countdown starting now!\")\nfor i in range(10, -1, -1):\n    print(f\"t minus {i}...\")\nprint(\"Lift-off!\")\n\nCountdown starting now!\nt minus 10...\nt minus 9...\nt minus 8...\nt minus 7...\nt minus 6...\nt minus 5...\nt minus 4...\nt minus 3...\nt minus 2...\nt minus 1...\nt minus 0...\nLift-off!"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-56",
    "href": "a1/a1-solutions.html#übung-56",
    "title": "Lösungen",
    "section": "Übung 56",
    "text": "Übung 56\n\ndef f_statistic(ssm, ssr, p, n):\n    return (ssm / (p - 1)) / (ssr / (n - p))\n\nf_statistic(2452, 1688, 4, 412)\n\n197.55450236966823"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-57",
    "href": "a1/a1-solutions.html#übung-57",
    "title": "Lösungen",
    "section": "Übung 57",
    "text": "Übung 57\n\ndef convert_celsius(c, to=\"K\"):\n    if to == \"K\":\n        return c + 273.15\n    elif to == \"F\":\n        return c * 9 / 5 + 32\n\nconvert_celsius(100)\nconvert_celsius(38, to=\"F\")\nconvert_celsius(0, to=\"K\")\n\n273.15"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-58",
    "href": "a1/a1-solutions.html#übung-58",
    "title": "Lösungen",
    "section": "Übung 58",
    "text": "Übung 58\nsum ist eine eingebaute Funktion und wird im Beispiel “überschrieben”, und zwar mit einem Integer, welcher eine Summe über eine Schleife beinhaltet. Danach kann die eingebaute Funktion sum nicht mehr aufgerufen werden. Es wäre hier also besser, anstelle von sum einen Namen zu verwenden, der keiner eingebauten Funktion entspricht, z.B. s:\n\ns = 0\nfor i in range(10):\n    s += i\nsum([1, 2, 3, 4, 5])\n\n15"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-59",
    "href": "a1/a1-solutions.html#übung-59",
    "title": "Lösungen",
    "section": "Übung 59",
    "text": "Übung 59\nEin Tuple mit einem einzigen Element erstellt man mit einem Komma am Ende:\n\nx = 2,\nprint(x[0])\n\n2"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-60",
    "href": "a1/a1-solutions.html#übung-60",
    "title": "Lösungen",
    "section": "Übung 60",
    "text": "Übung 60\n\ndef describe_number(n):\n    if n % 10 == 0:\n        return 10\n    elif n % 2 == 0:\n        return 1\n    else:\n        return 2\n\ns = 0\nfor n in range(-110, 231):\n    s += describe_number(n)\nprint(s)  # 826\n\n826"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-61",
    "href": "a1/a1-solutions.html#übung-61",
    "title": "Lösungen",
    "section": "Übung 61",
    "text": "Übung 61\n\na = 3\nif a &lt; 10:  # Doppelpunkt am Ende fehlte\n    print(\"a is less than 10.\")  # Klammern für Funktionsaufruf fehlten\n\na is less than 10."
  },
  {
    "objectID": "a1/a1-solutions.html#übung-62",
    "href": "a1/a1-solutions.html#übung-62",
    "title": "Lösungen",
    "section": "Übung 62",
    "text": "Übung 62\n\nimport math\n\ndef f(s1, s2):\n    return math.sqrt((s1**2 + s2**2) / 2)\n\nf(5, 27)  # 19.4164878389476\n\n19.4164878389476"
  },
  {
    "objectID": "a1/a1-solutions.html#übung-63",
    "href": "a1/a1-solutions.html#übung-63",
    "title": "Lösungen",
    "section": "Übung 63",
    "text": "Übung 63\n\nimport math\n\ndef decibel(x, to=\"power\"):\n    if to == \"power\":\n        return 10 * math.log10(x)\n    elif to == \"amplitude\":\n        return 20 * math.log10(x)"
  },
  {
    "objectID": "07/07.html",
    "href": "07/07.html",
    "title": "7 – Listen und Dictionaries",
    "section": "",
    "text": "Eine Liste (list) ist wie ein String (str) ein Sequenzdatentyp. Im Gegensatz zu einem String kann eine Liste aber Elemente mit unterschiedlichen und beliebigen Datentypen enthalten, z.B. Strings, Zahlen, weitere Listen, und so weiter. Eine Liste erstellt man mit eckigen Klammern, innerhalb derer die einzelnen Elemente durch Kommas getrennt angegeben werden:\n\nx = [23, \"Hallo\", \"test\", 1.44, True]\n\n\ny = [1, \"1\", [1, 2, 3], [\"test\", False, [True, True, 2, 4]]]"
  },
  {
    "objectID": "07/07.html#listen-erstellen",
    "href": "07/07.html#listen-erstellen",
    "title": "7 – Listen und Dictionaries",
    "section": "",
    "text": "Eine Liste (list) ist wie ein String (str) ein Sequenzdatentyp. Im Gegensatz zu einem String kann eine Liste aber Elemente mit unterschiedlichen und beliebigen Datentypen enthalten, z.B. Strings, Zahlen, weitere Listen, und so weiter. Eine Liste erstellt man mit eckigen Klammern, innerhalb derer die einzelnen Elemente durch Kommas getrennt angegeben werden:\n\nx = [23, \"Hallo\", \"test\", 1.44, True]\n\n\ny = [1, \"1\", [1, 2, 3], [\"test\", False, [True, True, 2, 4]]]"
  },
  {
    "objectID": "07/07.html#indizieren-und-slicen",
    "href": "07/07.html#indizieren-und-slicen",
    "title": "7 – Listen und Dictionaries",
    "section": "Indizieren und Slicen",
    "text": "Indizieren und Slicen\nDer Zugriff auf einzelne (bzw. mehrere) Elemente funktioniert genau wie bei Strings durch Indizierung (bzw. Slicen) mit eckigen Klammern.\n\nx[0]  # erstes Element\n\n23\n\n\n\nx[-2]  # vorletztes Element\n\n1.44\n\n\n\nx[1:4]  # drei Elemente\n\n['Hallo', 'test', 1.44]\n\n\n\nx[::-1]  # Liste in umgekehrter Reihenfolge\n\n[True, 1.44, 'test', 'Hallo', 23]"
  },
  {
    "objectID": "07/07.html#arbeiten-mit-listen",
    "href": "07/07.html#arbeiten-mit-listen",
    "title": "7 – Listen und Dictionaries",
    "section": "Arbeiten mit Listen",
    "text": "Arbeiten mit Listen\n\nLänge\nWie bei Strings gibt die Funktion len die Länge der Liste (also die Anzahl der Elemente in der Liste) zurück. Sehen wir uns noch einmal die beiden oben definierten Listen x und y an:\n\nx\n\n[23, 'Hallo', 'test', 1.44, True]\n\n\n\ny\n\n[1, '1', [1, 2, 3], ['test', False, [True, True, 2, 4]]]\n\n\nDiese enthalten 5 bzw. 4 Elemente:\n\nlen(x)\n\n5\n\n\n\nlen(y)\n\n4\n\n\nIn der Liste y sind das dritte und vierte Element selbst wieder Listen:\n\ny[2]\n\n[1, 2, 3]\n\n\n\ny[3]\n\n['test', False, [True, True, 2, 4]]\n\n\nLetztere enthält eine weitere Liste am Ende (mit Index 2):\n\ny[3][2]\n\n[True, True, 2, 4]\n\n\nEine leere Liste ist eine ganz normale Liste, nur eben mit keinen Elementen (also mit einer Länge 0):\n\nz = []\nlen(z)\n\n0\n\n\n\ntype(z)\n\nlist\n\n\n\n\nElemente verändern\nNachdem Listen mutable sind, kann man einzelne Elemente auch nach der Erstellung der Liste ändern.\n\nx\n\n[23, 'Hallo', 'test', 1.44, True]\n\n\n\nx[1] = 111111\nx\n\n[23, 111111, 'test', 1.44, True]\n\n\n\nx[0] = None\nx\n\n[None, 111111, 'test', 1.44, True]\n\n\n\n\nOperatoren + und *\nZwei oder mehr Listen kann man mit dem +-Operator zu einer neuen Liste zusammenfügen:\n\n[1, 2, \"drei\"] + [\"vier\", 5, 6.0]\n\n[1, 2, 'drei', 'vier', 5, 6.0]\n\n\nDer *-Operator vervielfältigt eine Liste:\n\n[1, 2.0, \"drei\"] * 3\n\n[1, 2.0, 'drei', 1, 2.0, 'drei', 1, 2.0, 'drei']\n\n\n\n\nElemente zu Listen hinzufügen\nMit der Methode append kann man neue Elemente am Ende der Liste hinzufügen.\n\nx\n\n[None, 111111, 'test', 1.44, True]\n\n\n\nx.append(13)\nx\n\n[None, 111111, 'test', 1.44, True, 13]\n\n\nIm Gegensatz zu Strings wird hier die Liste direkt verändert; eine erneute Zuweisung zu einem Namen ist nicht notwendig bzw. führt nicht zum gewünschten Ergebnis, was im folgenden Beispiel ersichtlich ist:\n\na = x.append(25)\n\n\nprint(a)  # Listen-Methoden geben None zurück, da Sie die Liste direkt ändern\n\nNone\n\n\n\nx  # geänderte Liste\n\n[None, 111111, 'test', 1.44, True, 13, 25]\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nListen-Methoden verändern die Liste direkt (in-place) und geben nichts (None) zurück. Im Gegensatz dazu können String-Methoden den String nicht verändern und geben daher immer einen neuen String zurück.\n\n\nMöchte man gleich mehrere Elemente hinzufügen, kann man die Methode extend benutzen:\n\nx.extend([99, \"HH\", \"zz\"])\nx\n\n[None, 111111, 'test', 1.44, True, 13, 25, 99, 'HH', 'zz']\n\n\n\n\n\n\n\n\nTipp\n\n\n\nVersuchen Sie anhand der folgenden zwei Befehle den Unterschied zwischen append und extend zu erklären:\nx.extend([99, \"HH\", \"zz\"])\nx.append([99, \"HH\", \"zz\"])\n\n\n\n\nElemente aus Listen entfernen\nUm bestimmte Elemente aus der Liste zu entfernen, verwendet man den del-Befehl.\n\nx = [\"A\", \"b\", 3, 4, \"fünf\"]\ndel x[1]  # löscht das Element mit dem Index 1\nx\n\n['A', 3, 4, 'fünf']\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nBeachten Sie, dass del ein Python-Keyword ist und keine Funktion. Daher handelt es sich bei del x[1] auch nicht um einen Funktionsaufruf, Klammern als Aufrufeoperator sind also nicht notwendig!\n\n\nAlternativ kann man auch die Methode pop zum Löschen eines Elementes an einem bestimmten Index verwenden. Diese gibt das entfernte Element auch zurück (was del nicht tut).\n\nx = [\"A\", \"b\", 3, 4, \"fünf\"]\nx.pop(1)\n\n'b'\n\n\n\nx\n\n['A', 3, 4, 'fünf']\n\n\nDie Methode remove entfernt das erste Element aus der Liste, welches dem gesuchten Wert entspricht. Hier gibt man also nicht den zu entfernenden Index an, sondern den zu löschenden Wert.\n\nx = [\"A\", \"b\", 31, 41, \"fünf\"]\nx.remove(31)\nx\n\n['A', 'b', 41, 'fünf']\n\n\n\n\nListen sortieren\nWenn eine Liste sortierbare Elemente enthält (z.B. lauter Zahlen), kann man sie mit der Methode sort sortieren.\n\nh = [6, 9, 23, 1, -78, 44]\nh.sort()\nh\n\n[-78, 1, 6, 9, 23, 44]\n\n\n\n\n\n\n\n\nTipp\n\n\n\nWas passiert, wenn man eine Liste mit nicht sortierbaren Elementen sortieren möchte (z.B. die Liste x aus dem vorigen Beispiel)?\n\n\n\n\nListen umkehren\nEine Liste kann man wie einen String mit folgendem Slice umkehren (die ursprüngliche Liste ändert sich dabei aber nicht):\n\nh[::-1]\n\n[44, 23, 9, 6, 1, -78]\n\n\n\nh\n\n[-78, 1, 6, 9, 23, 44]\n\n\nEs gibt aber noch eine zweite Möglichkeit, welche die Liste direkt (in-place) verändert:\n\nh.reverse()\nh\n\n[44, 23, 9, 6, 1, -78]\n\n\n\n\nListen iterieren\nMit dem in-Operator kann man überprüfen, ob ein bestimmtes Element in einer Liste enthalten ist.\n\n2 in h\n\nFalse\n\n\n\n-78 in h\n\nTrue\n\n\nEine Liste ist wie jeder Sequenzdatentyp iterierbar, d.h. man kann mit einer for-Schleife über die einzelnen Elemente iterieren:\n\nfor k in [2, \"fünf\", 3.14, \"sieben\"]:\n    print(k)\n\n2\nfünf\n3.14\nsieben\n\n\nDie Schleifenvariable k nimmt in jeder Interation die einzelnen Werte der Liste an."
  },
  {
    "objectID": "07/07.html#tupel",
    "href": "07/07.html#tupel",
    "title": "7 – Listen und Dictionaries",
    "section": "Tupel",
    "text": "Tupel\nTupel (englische Schreibweise Tuple) verhalten sich wie Listen, sind aber immutable. Das bedeutet, dass man die im Tupel enthaltenen Elemente nicht verändern kann. Tupel erstellt man wie Listen, nur lässt man die eckigen Klammern weg (man benötigt auch keine runden Klammern, obwohl diese manchmal in Kombination mit anderen Befehlen syntaktisch notwendig sind, z.B. wenn man ein Tupel als Argument übergeben möchte).\n\nt = \"A\", \"b\", 3, 4, \"fünf\"\nt\n\n('A', 'b', 3, 4, 'fünf')\n\n\n\nt[1]\n\n'b'\n\n\n\nt[1] = \"c\"  # Fehler!\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[40], line 1\n----&gt; 1 t[1] = \"c\"  # Fehler!\n\nTypeError: 'tuple' object does not support item assignment\n\n\n\n\n\n\n\n\n\nTipp\n\n\n\nEin Tupel mit einem Element erstellt man mit einem nachgestellten Komma:\n\nt = \"A\",\nt\n\n('A',)\n\n\nDie Klammern sind, wie bereits erwähnt, optional:\n\nt = (\"A\",)\nt\n\n('A',)"
  },
  {
    "objectID": "07/07.html#list-comprehensions",
    "href": "07/07.html#list-comprehensions",
    "title": "7 – Listen und Dictionaries",
    "section": "List Comprehensions",
    "text": "List Comprehensions\nList Comprehensions sind eine alternative Möglichkeit zur Erstellung von Listen. List Comprehensions sind im Prinzip Schleifen, die aber syntaktisch wesentlich kompakter (kürzer) sind.\nNehmen wir als Beispiel eine Liste der Quadratzahlen von 0 bis 9. Mit einer normalen Schleife würde man diese Liste so erstellen:\n\nsquares = []  # wir beginnen mit einer leeren Liste\nfor x in range(10):\n    squares.append(x**2)  # Liste wird befüllt\n\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nBei der Erstellung von vielen Listen startet man mit einer leeren Liste und fügt dann mit einer Schleife die einzelnen Elemente zur Liste hinzu.\n\n\nDasselbe Ergebnis kann mit einer List Comprehension viel kürzer geschrieben werden:\n\nsquares = [x**2 for x in range(10)]\nsquares\n\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n\n\nDie Zutaten einer List Comprehension sind:\n\nZwei umschließende eckige Klammern (die ja eine Liste definieren)\nEin Ausdruck (x**2 im Beispiel)\nEine for-Anweisung (for x in range(10) im Beispiel)\nOptional eine if-Bedingung\nOptional weitere for-Anweisungen\n\nEin relativ komplexes Beispiel könnte wie folgt aussehen:\n\nz = [(x - 1, y - 2) for x in [1, 2, 3] for y in [3, 1, 4] if x != y]\nz\n\n[(0, 1), (0, 2), (1, 1), (1, -1), (1, 2), (2, -1), (2, 2)]\n\n\nDiese List Comprehension entspricht exakt folgendem Konstrukt:\n\nz = []\nfor x in [1, 2, 3]:\n    for y in [3, 1, 4]:\n        if x != y:\n            z.append((x - 1, y - 2))\n\nz\n\n[(0, 1), (0, 2), (1, 1), (1, -1), (1, 2), (2, -1), (2, 2)]\n\n\nWeitere Beispiele veranschaulichen, dass List Comprehensions eine Operation auf alle Elemente einer Liste anwenden oder bestimmte Elemente herausfiltern können:\n\nvec = [-4, -2, 0, 2, 4]\n\n\n[x * 2 for x in vec]  # neue Liste mit verdoppelten Einträgen\n\n[-8, -4, 0, 4, 8]\n\n\n\n[x for x in vec if x &gt;= 0]  # negative Einträge herausfiltern\n\n[0, 2, 4]\n\n\n\n[abs(x) for x in vec]  # eine Funktion auf alle Elemente separat anwenden\n\n[4, 2, 0, 2, 4]\n\n\n\n\n\n\n\n\nHinweis\n\n\n\nIn Python ist es mit Listen also nicht einfach möglich, elementweise Berechnungen durchzuführen.\n\nx = [4, -3, 7, 81, 11]\nx * 2\n\n[4, -3, 7, 81, 11, 4, -3, 7, 81, 11]\n\n\nSo werden die einzelnen Elemente nicht mit 2 multipliziert, sondern die Liste wird “verzweifacht”. Immer dann, wenn man eine Operation elementweise anwenden möchte, muss man daher eine List Comprehension (oder die entsprechende Schleife) verwenden.\nFür numerische Anwendungen ist das aber denkbar unpraktisch. Wir werden in einer der folgenden Einheiten lernen, wie man Python dennoch für numerische Berechnungen verwenden kann (nämlich dank eines neuen Datentyps namens NumPy Array, welches vom Zusatzpaket NumPy zur Verfügung gestellt wird).\n\n\nIn der Praxis verwendet man List Comprehensions, so lange diese noch relativ einfach und übersichtlich sind. Hat man aber mehrere geschachtelte Schleifen und Bedingungen, verwendet man besser explizite Schleifen, da diese dann besser lesbar sind."
  },
  {
    "objectID": "07/07.html#dictionaries",
    "href": "07/07.html#dictionaries",
    "title": "7 – Listen und Dictionaries",
    "section": "Dictionaries",
    "text": "Dictionaries\nDer Datentyp Dictionary ist ein sogenannter Mapping-Datentyp. Man kann sich ein Dictionary wie ein Sprachwörterbuch vorstellen (daher auch der Name). Wenn man die Übersetzung zu einem bestimmten Wort wissen möchte, schlägt man unter dem gesuchten Wort (hier Key genannt) nach und findet dort die Übersetzung (hier als Value bezeichnet). In Python definiert man ein dict mit geschwungenen Klammern und trennt die Einträge wie bei Listen mit Kommas. Jeder Eintrag besteht aus einem Key und einem Value, welche durch einen Doppelpunkt voneinander getrennt sind.\nFolgendes Beispiel zeigt ein dict mit drei Einträgen:\n\nd = {\"Haus\": \"house\", \"Schlange\": \"snake\", \"Katze\": \"cat\"}\n\nAlternativ kann man auch die dict-Funktion benutzen. Mit Keyword-Argumenten kann man so das Dictionary initialisieren:\n\nd = dict(Haus=\"house\", Schlange=\"snake\", Katze=\"cat\")\n\n\n\n\n\n\n\nHinweis\n\n\n\nMan beachte, dass die Keys den Keyword-Argumenten entsprechen und dementsprechend ohne Anführungszeichen geschrieben werden müssen. Diese werden dann aber in Strings umgewandelt und so als Keys im Dictionary verwendet.\n\n\nEinzelne Elemente kann man wieder mit Indizierung herausgreifen – anstelle eines numerischen Index (wie bei Listen) gibt man aber nun den jeweiligen Key als Index an:\n\nd[\"Haus\"]\n\n'house'\n\n\n\nd[\"Schlange\"]\n\n'snake'\n\n\n\n\n\n\n\n\nWichtig\n\n\n\nEin Dictionary ist also gewissermaßen eine verallgemeinerte Liste. Ein wichtiger Unterschied zu Listen ist, dass die Reihenfolge der Einträge in Dictionaries keine Rolle spielt. D.h. man kann bei einem Dictionary nicht vom ersten, zweiten, dritten Element usw. sprechen – bei Listen hingegen schon.\n\n\nGenau wie in Listen kann man in Dictionaries Elemente mit unterschiedlichen Datentypen speichern. Eine Einschränkung gibt es aber für die Keys: diese müssen immutable sein (daher kann man z.B. keine Listen als Keys verwenden). Neue Elemente fügt man einfach durch Angabe von Key und Value zu einem bestehenden Dictionary hinzu.\n\nd\n\n{'Haus': 'house', 'Schlange': 'snake', 'Katze': 'cat'}\n\n\n\nd[23] = \"tt\"  # Key 23, Value \"tt\"\nd[1] = 3.14  # Key 1, Value 3.14\nd[\"L\"] = [1, 2, 3]  # Key \"L\", Value [1, 2, 3]\nd\n\n{'Haus': 'house',\n 'Schlange': 'snake',\n 'Katze': 'cat',\n 23: 'tt',\n 1: 3.14,\n 'L': [1, 2, 3]}\n\n\nMöchte man auf einen Eintrag mit einem Key zugreifen, der im Wörterbuch nicht existiert, erhält man eine Fehlermeldung.\n\nd[0]  # Fehler!\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[58], line 1\n----&gt; 1 d[0]  # Fehler!\n\nKeyError: 0\n\n\n\n\nArbeiten mit Dictionaries\nDie Länge eines Dictionaries, also die Anzahl der Einträge, bestimmt man mit der Funktion len:\n\nlen(d)\n\n6\n\n\nDie Keys bekommt man mit der Methode keys, die Values mit der Methode values (beides sind im Prinzip Listen):\n\nd.keys()\n\ndict_keys(['Haus', 'Schlange', 'Katze', 23, 1, 'L'])\n\n\n\nd.values()\n\ndict_values(['house', 'snake', 'cat', 'tt', 3.14, [1, 2, 3]])\n\n\nOb ein Wert als Key vorkommt, kann man mit in überprüfen:\n\n\"Katze\" in d\n\nTrue\n\n\n\n\"cat\" in d\n\nFalse\n\n\nWenn man wissen möchte, ob ein Wert als Value vorkommt, verwendet man die values-Methode:\n\n\"cat\" in d.values()\n\nTrue\n\n\nSelbstverständlich kann man über ein Dictionary auch iterieren – in diesem Fall wird über die Keys iteriert:\n\nfor k in d:\n    print(k)\n\nHaus\nSchlange\nKatze\n23\n1\nL\n\n\nAuf die entsprechenden Values greift man dann durch Indizieren zu:\n\nfor k in d:\n    print(k, \":\", d[k])\n\nHaus : house\nSchlange : snake\nKatze : cat\n23 : tt\n1 : 3.14\nL : [1, 2, 3]\n\n\nEleganter funktioniert das mit der Methode items. Diese erzeugt eine Liste von Tupeln, welche die Key/Value-Paare enthalten:\nd.items()\nDamit kann man in einer Schleife sowohl auf die Keys als auch auf die Values zugreifen.\n\nfor k, v in d.items():\n    print(k, \":\", v)\n\nHaus : house\nSchlange : snake\nKatze : cat\n23 : tt\n1 : 3.14\nL : [1, 2, 3]\n\n\nDie gleichzeitige Zuweisung von Werten an die Namen k und v bezeichnet man in Python als Unpacking – nachdem d.items() jeweils ein Tupel bestehend aus zwei Elementen erzeugt, kann man diesen zwei Elementen direkt zwei Namen zuweisen.\n\n\n\n\n\n\nTipp\n\n\n\nEin weiteres Beispiel für Unpacking ist das Vertauschen von zwei Werten. Zunächst kann man damit zwei (oder mehr) Namen gleichzeitig zuweisen:\n\na, b = 15, 23\n\n\na\n\n15\n\n\n\nb\n\n23\n\n\nDa Python immer zuerst die rechte Seite einer Zuweisung auswertet, kann man mit diesem Muster auch zwei Werte vertauschen:\n\na, b = b, a\n\n\na\n\n23\n\n\n\nb\n\n15\n\n\n\n\nMöchte man den Fehler beim Zugriff auf einen nicht existierenden Key vermeiden, kann man stattdessen die Methode get verwenden. Diese Methode hat zwei Parameter, nämlich einen Key und einen Standardwert, der zurückgegeben wird, falls der angegebene Key im Dictionary nicht existiert:\n\nd\n\n{'Haus': 'house',\n 'Schlange': 'snake',\n 'Katze': 'cat',\n 23: 'tt',\n 1: 3.14,\n 'L': [1, 2, 3]}\n\n\n\nd[\"psy\"]  # Fehler, Key \"psy\" existiert nicht\n\n\n---------------------------------------------------------------------------\nKeyError                                  Traceback (most recent call last)\nCell In[75], line 1\n----&gt; 1 d[\"psy\"]  # Fehler, Key \"psy\" existiert nicht\n\nKeyError: 'psy'\n\n\n\n\nd.get(\"psy\", 0)  # Key \"psy\" exisitiert nicht, also wird 0 zurückgegeben\n\n0\n\n\n\nd.get(\"Schlange\", \"Tier\")  # Key \"Schlange\" existiert\n\n'snake'\n\n\n\nd.get(\"snake\", \"Schlange\")  # Key \"snake\" existiert nicht\n\n'Schlange'\n\n\n\n\n\n\n\n\nTipp\n\n\n\nGibt man für get keinen Standardwert an, wird None zurückgegeben, falls der Key nicht existiert:\n\nd.get(\"psy\")\n\n\n\nZu beachten ist, dass in den Fällen, wo Standardwerte zurückgegeben werden, diese Einträge nicht automatisch zum Dictionary hinzugefügt werden:\n\nd\n\n{'Haus': 'house',\n 'Schlange': 'snake',\n 'Katze': 'cat',\n 23: 'tt',\n 1: 3.14,\n 'L': [1, 2, 3]}\n\n\nMöchte man diese neuen Einträge gleich dem Dictionary hinzufügen, verwendet man die Methode setdefault:\n\nd.setdefault(\"X\", 42)  # Key \"X\" existiert nicht\n\n42\n\n\n\nd  # jetzt gibt es den Key \"X\"\n\n{'Haus': 'house',\n 'Schlange': 'snake',\n 'Katze': 'cat',\n 23: 'tt',\n 1: 3.14,\n 'L': [1, 2, 3],\n 'X': 42}\n\n\n\nd.setdefault(\"X\", 100)  # Key \"X\" existiert bereits\n\n42\n\n\n\nd\n\n{'Haus': 'house',\n 'Schlange': 'snake',\n 'Katze': 'cat',\n 23: 'tt',\n 1: 3.14,\n 'L': [1, 2, 3],\n 'X': 42}"
  },
  {
    "objectID": "07/07.html#übungen",
    "href": "07/07.html#übungen",
    "title": "7 – Listen und Dictionaries",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nSchreiben Sie eine Funktion histogram, welche eine Liste mit Zahlen entgegennehmen und diese als vereinfachtes Histogramm am Bildschirm darstellen soll. Dieses Histogramm soll für jeden Wert eine Zeile ausgeben mit der entsprechenden Anzahl an Zeichen. Das Standardzeichen soll ein Stern (*) sein, aber dieses Zeichen soll mit einem Parameter namens char anpassbar sein. Beispiele für mögliche Funktionsaufrufe und deren Ergebnisse lauten:\n&gt;&gt;&gt; histogram([1, 8, 5, 17, 14, 9, 2])\n*\n********\n*****\n*****************\n**************\n*********\n**\n&gt;&gt;&gt; histogram([1, 8, 5, 17, 2], char=\"-\")\n-\n--------\n-----\n-----------------\n--\n\n\n\n\n\n\nHinweis\n\n\n\nDiese Funktion liefert keinen Wert zurück, sondern gibt das Histogramm (mit Hilfe der print-Funktion) am Bildschirm aus.\n\n\n\n\nÜbung 2\nSchreiben Sie eine Funktion sum_of_squares, welche eine Liste mit Zahlen als Parameter entgegennimmt und die Quadratsumme dieser Zahlen (also eine einzige Zahl) zurückgibt.\n\n\n\n\n\n\nHinweis\n\n\n\nSie könnten in der Funktion z.B. zuerst eine Liste mit den quadrierten Zahlen erstellen, deren Elemente mit der Funktion sum addieren und das Ergebnis zurückgeben.\n\n\n\n\nÜbung 3\nErstellen Sie eine Liste mit den ganzen Zahlen von 1 bis 25 und weisen Sie dieser Liste den Namen numbers zu. Erstellen Sie dann fünf neue Listen, welche folgende Zahlen beinhalten (basierend auf numbers, die neuen Listen sollen wie angegeben benannt werden):\n\nDie Quadratzahlen squares.\nDie geraden Zahlen evens.\nDie ungeraden Zahlen odds.\nDie Wurzeln roots.\nDie natürlichen Logarithmen logs.\n\nVerwenden Sie zur Erstellung der neuen Listen jeweils eine geeignete List Comprehension.\n\n\n\n\n\n\nHinweis\n\n\n\nFür die letzten beiden Listen verwenden Sie am besten Funktionen aus dem Modul math.\n\n\n\n\nÜbung 4\nSchreiben Sie folgende List Comprehension um, indem Sie zwei geschachtelte for-Schleifen verwenden:\nz = [x**2 - y for x in range(7) for y in [3, 1, 5] if x != y]\n\n\nÜbung 5\nErstellen Sie ein Dictionary a, welches drei Einträge hat und Übersetzungen der Wörter “eins”, “zwei” und “drei” auf Englisch beinhalten soll. Wie können Sie die Übersetzung von “zwei” dann aus a anzeigen lassen?\n\n\nÜbung 6\nFügen Sie dem Dictionary a aus der vorigen Übung einen neuen Eintrag (“vier” – “four”) hinzu und geben Sie das gesamte Dictionary am Bildschirm aus.\n\n\nÜbung 7\nWas passiert, wenn Sie im Dictionary a auf den nicht existierenden Key \"zehn\" zugreifen wollen? Welche zwei Alternativen gibt es, um für nicht existierende Keys einen Standardwert (z.B. \"undefiniert\") zurückzugeben (und daher die Fehlermeldung zu vermeiden)? Was ist der Unterschied zwischen diesen beiden Möglichkeiten? Geben Sie in Ihrer Antwort auch den konkreten Code für die drei Zugriffsmöglichkeiten auf das Element \"zehn\" von a an!\n\n\nÜbung 8\nIn der letzten Einheit haben wir eine Funktion namens find definiert, welche sich wie die String-Methode str.find verhält. Allerdings findet diese Funktion (und auch die Methode) nur das erste Vorkommen des gesuchten Zeichens, z.B. \"Werkstatttreppe\".find(\"t\") gibt 5 zurück (die Position des ersten t). Es wäre praktisch, wenn die Indizes aller gesuchten Zeichen in einer Liste zurückgegeben würden, also in diesem Beispiel [5, 7, 8, 9]. Falls das Zeichen gar nicht vorkommen sollte, soll eine leere Liste zurückgegeben werden. Schreiben Sie eine Funktion find, die sich entsprechend verhält!"
  },
  {
    "objectID": "05/05-solutions.html",
    "href": "05/05-solutions.html",
    "title": "5 – Solutions",
    "section": "",
    "text": "x = int(input(\"x: \"))\ny = int(input(\"y: \"))\n\nif x + y &gt; 50:\n    print(\"x + y &gt; 50\")\nelif x + y &lt; 50:\n    print(\"x + y &lt; 50\")\nelse:\n    print(\"x + y == 50\")"
  },
  {
    "objectID": "05/05-solutions.html#übung-1",
    "href": "05/05-solutions.html#übung-1",
    "title": "5 – Solutions",
    "section": "",
    "text": "x = int(input(\"x: \"))\ny = int(input(\"y: \"))\n\nif x + y &gt; 50:\n    print(\"x + y &gt; 50\")\nelif x + y &lt; 50:\n    print(\"x + y &lt; 50\")\nelse:\n    print(\"x + y == 50\")"
  },
  {
    "objectID": "05/05-solutions.html#übung-2",
    "href": "05/05-solutions.html#übung-2",
    "title": "5 – Solutions",
    "section": "Übung 2",
    "text": "Übung 2\ndef is_odd(x):\n    if x % 2 == 1:\n        return True\n    else:\n        return False\nOder kürzer:\ndef is_odd(x):\n    return x % 2 == 1"
  },
  {
    "objectID": "05/05-solutions.html#übung-3",
    "href": "05/05-solutions.html#übung-3",
    "title": "5 – Solutions",
    "section": "Übung 3",
    "text": "Übung 3\n\nlst = [\"I\", \"love\", \"Python\"]\nfor element in lst:\n    print(element)\n\nI\nlove\nPython"
  },
  {
    "objectID": "05/05-solutions.html#übung-4",
    "href": "05/05-solutions.html#übung-4",
    "title": "5 – Solutions",
    "section": "Übung 4",
    "text": "Übung 4\n\nfor element in lst:\n    for ch in element:\n        print(ch, end=\"-\")\n\nI-l-o-v-e-P-y-t-h-o-n-"
  },
  {
    "objectID": "05/05-solutions.html#übung-5",
    "href": "05/05-solutions.html#übung-5",
    "title": "5 – Solutions",
    "section": "Übung 5",
    "text": "Übung 5\n\nx = 5  # x = -11, x = 0\nif x &gt; 0:\n    print(\"x is positive\")\nelif x &lt; 0:\n    print(\"x is negative\")\nelse:\n    print(\"x is equal to 0\")\n\nx is positive"
  },
  {
    "objectID": "05/05-solutions.html#übung-6",
    "href": "05/05-solutions.html#übung-6",
    "title": "5 – Solutions",
    "section": "Übung 6",
    "text": "Übung 6\nwhile True:\n    x = int(input(\"Enter an integer between 1 and 10: \"))\n    if 0 &lt; x &lt;= 10:\n        break\n    else:\n        print(\"Invalid input. Please try again.\")\n\nprint(\"You entered:\", x)"
  },
  {
    "objectID": "06/06-solutions.html",
    "href": "06/06-solutions.html",
    "title": "6 – Lösungen",
    "section": "",
    "text": "def reverse(s):\n    return s[::-1]"
  },
  {
    "objectID": "06/06-solutions.html#übung-1",
    "href": "06/06-solutions.html#übung-1",
    "title": "6 – Lösungen",
    "section": "",
    "text": "def reverse(s):\n    return s[::-1]"
  },
  {
    "objectID": "06/06-solutions.html#übung-2",
    "href": "06/06-solutions.html#übung-2",
    "title": "6 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\n\ns = \"educational neuroscience\"\ns.title()\n\n'Educational Neuroscience'"
  },
  {
    "objectID": "06/06-solutions.html#übung-3",
    "href": "06/06-solutions.html#übung-3",
    "title": "6 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\n\ns = \"Edukational Neuroscience\"\ns[:3] + \"c\" + s[4:]\n\n'Educational Neuroscience'"
  },
  {
    "objectID": "06/06-solutions.html#übung-4",
    "href": "06/06-solutions.html#übung-4",
    "title": "6 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\n\ndef is_palindrome(s):\n    s = s.lower()\n    s = s.replace(\"?\", \"\").replace(\"!\", \"\").replace(\".\", \"\").replace(\",\", \"\")\n    s = s.replace(\" \", \"\")\n    return s == s[::-1]"
  },
  {
    "objectID": "06/06-solutions.html#übung-5",
    "href": "06/06-solutions.html#übung-5",
    "title": "6 – Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\nDa wir die Position des gesuchten Zeichens benötigen, ist eine while-Schleife eine geeignete Lösung (wir wissen nicht im Vorhinein, wie viele Iterationen stattfinden werden). Hier zählen wir mit dem Namen i die aktuelle Position im String s mit.\n\ndef find(s, sub):\n    i = 0\n    while i &lt; len(s):\n        if s[i] == sub:\n            return i\n        i += 1  # erhöhe i um 1 (äquivalent zu i = i + 1)\n    return -1  # wird nur zurückgegeben, falls vorher kein return erfolgte\n\nEine Alternative mit for-Schleife ist aber auch möglich (die Funktion enumerate gibt sowohl die Position als auch das aktuelle Zeichen innerhalb des Strings s zurück):\n\ndef find(s, sub):\n    for i, char in enumerate(s):\n        if char == sub:\n            return i\n    return -1  # wird nur zurückgegeben falls das Zeichen nicht gefunden wurde"
  },
  {
    "objectID": "06/06-solutions.html#übung-6",
    "href": "06/06-solutions.html#übung-6",
    "title": "6 – Lösungen",
    "section": "Übung 6",
    "text": "Übung 6\n\ndef count(word, letter):\n    i = 0  # wir haben das Zeichen noch nicht gefunden\n    for c in word:\n        if c == letter:  # falls es das gesuchte Zeichen ist\n            i += 1  # erhöhen wir i um 1 (i = i + 1 oder kurz i += 1)\n    return i"
  },
  {
    "objectID": "06/06-solutions.html#übung-7",
    "href": "06/06-solutions.html#übung-7",
    "title": "6 – Lösungen",
    "section": "Übung 7",
    "text": "Übung 7\n\npath = \"C:\\\\Program Files\\\\Python\\\\Python3.12\\\\python.exe\"\nprint(path)\n\nC:\\Program Files\\Python\\Python3.12\\python.exe"
  },
  {
    "objectID": "04/04-solutions.html",
    "href": "04/04-solutions.html",
    "title": "4 – Lösungen",
    "section": "",
    "text": "Die Funktion print gibt Werte am Bildschirm aus:\nhelp(print)\n\nprint(\"Hello World!\")  # kein Rückgabewert (None)\n\nHello World!\n\n\nDie Funktion str erstellt ein String-Objekt:\nhelp(str)\n\nstr(59)  # Rückgabewert '59' (str)\n\n'59'\n\n\nDie Funktion int erstellt ein Integer-Objekt:\nhelp(int)\n\nint(\"59\")  # Rückgabewert 59 (int)\n\n59\n\n\nDie Funktion max gibt das Maximum der Argumente zurück:\nhelp(max)\n\nmax(54, -12, 33, -100, -2)  # Rückgabewert -100 (int)\n\n54\n\n\nDie Funktion sum gibt die Summe einer Sequenz (z.B. Liste an Zahlen) zurück:\nhelp(sum)\n\nsum([1, 2, 3, 4])  # Rückgabewert 10 (int)\n\n10"
  },
  {
    "objectID": "04/04-solutions.html#übung-1",
    "href": "04/04-solutions.html#übung-1",
    "title": "4 – Lösungen",
    "section": "",
    "text": "Die Funktion print gibt Werte am Bildschirm aus:\nhelp(print)\n\nprint(\"Hello World!\")  # kein Rückgabewert (None)\n\nHello World!\n\n\nDie Funktion str erstellt ein String-Objekt:\nhelp(str)\n\nstr(59)  # Rückgabewert '59' (str)\n\n'59'\n\n\nDie Funktion int erstellt ein Integer-Objekt:\nhelp(int)\n\nint(\"59\")  # Rückgabewert 59 (int)\n\n59\n\n\nDie Funktion max gibt das Maximum der Argumente zurück:\nhelp(max)\n\nmax(54, -12, 33, -100, -2)  # Rückgabewert -100 (int)\n\n54\n\n\nDie Funktion sum gibt die Summe einer Sequenz (z.B. Liste an Zahlen) zurück:\nhelp(sum)\n\nsum([1, 2, 3, 4])  # Rückgabewert 10 (int)\n\n10"
  },
  {
    "objectID": "04/04-solutions.html#übung-2",
    "href": "04/04-solutions.html#übung-2",
    "title": "4 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\n\ndef mult(a, b):\n    \"\"\"Multiply a and b.\"\"\"\n    return a * b\n\n\nmult(1, 1)  # 1\n\n1\n\n\n\nmult(2, 6)  # 12\n\n12\n\n\n\nmult(-12, 36)  # -432\n\n-432"
  },
  {
    "objectID": "04/04-solutions.html#übung-3",
    "href": "04/04-solutions.html#übung-3",
    "title": "4 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\n\ndef to_fahrenheit(celsius):\n    \"\"\"Convert Celsius to Fahrenheit.\"\"\"\n    return celsius * 9/5 + 32\n\n\ndef to_celsius(fahrenheit):\n    \"\"\"Convert Fahrenheit to Celsius.\"\"\"\n    return (fahrenheit - 32) * 5/9\n\n\nto_fahrenheit(0)\n\n32.0\n\n\n\nto_fahrenheit(20)\n\n68.0\n\n\n\nto_fahrenheit(38)\n\n100.4\n\n\n\nto_fahrenheit(100)\n\n212.0\n\n\n\nto_celsius(32)\n\n0.0\n\n\n\nto_celsius(68)\n\n20.0\n\n\n\nto_celsius(100.4)\n\n38.0\n\n\n\nto_celsius(212)\n\n100.0\n\n\n\nto_celsius(to_fahrenheit(0))\n\n0.0\n\n\n\nto_celsius(to_fahrenheit(20))\n\n20.0\n\n\n\nto_celsius(to_fahrenheit(38))\n\n38.0\n\n\n\nto_celsius(to_fahrenheit(100))\n\n100.0"
  },
  {
    "objectID": "04/04-solutions.html#übung-4",
    "href": "04/04-solutions.html#übung-4",
    "title": "4 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\nFunktionen\n\nstrukturieren Programme,\nmachen Code wiederverwendbar,\nverallgemeinern Code (durch Parameter) und\nverkürzen Programme (repetitiver Code wird nur einmal geschrieben und kann dann beliebig oft aufgerufen werden).\n\nEine Funktion muss definiert sein, bevor man sie benutzen (aufrufen) kann. Durch die Definition weiß Python, welcher Code dann beim Aufruf ausgeführt werden muss.\nErst beim Aufrufen der Funktion wird der Code im Funktionskörper tatsächlich ausgeführt. Für alle Parameter werden dann die tatsächlich übergebenen Werte (die Argumente) verwendet.\nEine Funktion kann bei der Definition Parameter haben. Beim Aufruf einer Funktion übergibt man dann für die Parameter tatsächliche Werte, welche man Argumente nennt."
  },
  {
    "objectID": "04/04-solutions.html#übung-5",
    "href": "04/04-solutions.html#übung-5",
    "title": "4 – Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\n\ndef nonsense(a, b=10, c=13):\n    return a**2 - b * 2 + c**2\n\n\nnonsense()  # TypeError, da a=undefiniert, b=10, c=13\n\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[25], line 1\n----&gt; 1 nonsense()  # TypeError, da a=undefiniert, b=10, c=13\n\nTypeError: nonsense() missing 1 required positional argument: 'a'\n\n\n\n\nnonsense(22, 15, 78)  # 6538; a=22, b=15, c=78\n\n6538\n\n\n\nnonsense(11, 3)  # 284; a=11, b=3, c=13\n\n284\n\n\n\nnonsense(a=42)  # 1913; a=42, b=10, c=13\n\n1913\n\n\n\nnonsense(a=17, c=88)  # 8013; a=17, b=10, c=88\n\n8013\n\n\n\nnonsense(3, 4, c=5)  # 26; a=3, b=4, c=5\n\n26\n\n\n\nnonsense(3, c=2)  # -7; a=3, b=10, c=2\n\n-7"
  },
  {
    "objectID": "12/12-solutions.html",
    "href": "12/12-solutions.html",
    "title": "12 – Lösungen",
    "section": "",
    "text": "from psychopy import core, visual, event\n\nwin = visual.Window(size=[800, 800])\n\nradius = 0.1\nradius_change = 0.01\ncircle = visual.Circle(win, radius=radius, fillColor=\"white\", pos=[-0.5, 0.5])\n\nrot = 0\nrot_change = 0.5\npoly = visual.Polygon(win, edges=12, radius=0.3, fillColor=\"green\")\n\nxpos = -1.2\nxpos_change = 0.01\ntext = visual.TextStim(win, \"PsychoPy\", pos=[xpos, 0], color=\"blue\")\n\nwhile True:\n    keys = event.getKeys(keyList=[\"escape\"])\n    if keys:\n        break\n\n    # circle\n    radius += radius_change\n    if radius &gt;= 0.3 or radius &lt;= 0.01:\n        radius_change = -radius_change\n    circle.setRadius(radius)\n    circle.draw()\n\n    # polygon\n    rot += rot_change\n    poly.setOri(rot)\n    poly.draw()\n\n    # text\n    xpos += xpos_change\n    if xpos &gt; 1.2:\n        xpos = -1.2\n    text.setPos([xpos, 0])\n    text.draw()\n\n    win.flip()\n\nwin.close()\ncore.quit()"
  },
  {
    "objectID": "12/12-solutions.html#übung-1",
    "href": "12/12-solutions.html#übung-1",
    "title": "12 – Lösungen",
    "section": "",
    "text": "from psychopy import core, visual, event\n\nwin = visual.Window(size=[800, 800])\n\nradius = 0.1\nradius_change = 0.01\ncircle = visual.Circle(win, radius=radius, fillColor=\"white\", pos=[-0.5, 0.5])\n\nrot = 0\nrot_change = 0.5\npoly = visual.Polygon(win, edges=12, radius=0.3, fillColor=\"green\")\n\nxpos = -1.2\nxpos_change = 0.01\ntext = visual.TextStim(win, \"PsychoPy\", pos=[xpos, 0], color=\"blue\")\n\nwhile True:\n    keys = event.getKeys(keyList=[\"escape\"])\n    if keys:\n        break\n\n    # circle\n    radius += radius_change\n    if radius &gt;= 0.3 or radius &lt;= 0.01:\n        radius_change = -radius_change\n    circle.setRadius(radius)\n    circle.draw()\n\n    # polygon\n    rot += rot_change\n    poly.setOri(rot)\n    poly.draw()\n\n    # text\n    xpos += xpos_change\n    if xpos &gt; 1.2:\n        xpos = -1.2\n    text.setPos([xpos, 0])\n    text.draw()\n\n    win.flip()\n\nwin.close()\ncore.quit()"
  },
  {
    "objectID": "02/02.html",
    "href": "02/02.html",
    "title": "2 – Die Python-Umgebung",
    "section": "",
    "text": "Eine Python-Installation besteht aus der Programmiersprache Python, einem Interpreter (ein Programm, welches Python-Code ausführen kann), und der umfangreichen Standardbibliothek. Python selbst stellt nur grundlegende Programmierkonstrukte zur Verfügung, wie z.B. Schleifen, Bedingungen und einige fest eingebaute Funktionen. Die mitgelieferte Standardbibliothek erweitert die Kernfunktionalität um zusätzliche Datentypen, Ein-/Ausgabe, reguläre Ausdrücke, mathematische Funktionen, Datenkompression, Netzwerkfunktionen, grafische Benutzeroberflächen und vieles mehr.\n\n\n\n\n\n\nTipp\n\n\n\nIm vorigen Kapitel haben wir bereits import math verwendet, um auf mathematische Funktionen und Konstanten zuzugreifen. Diese Vorgehensweise ist notwendig, um Objekte aus einem Modul verwenden zu können. Man muss also das math-Modul aus der Standardbibliothek importieren, um danach auf mathematische Funktionen wie math.sqrt (Quadratwurzel) oder Konstanten wie math.pi (Kreiszahl) zugreifen zu können.\n\n\nZusätzlich gibt es noch tausende sogenannte Python-Pakete, die sehr einfach zu einer existierenden Python-Installation hinzugefügt werden können. Diese Python-Pakete sind komplett unabhängig von Python, werden also auch nicht von denselben Personen entwickelt und veröffentlicht. Der Python Package Index (PyPI) sammelt alle verfügbaren Pakete an einer zentralen Stelle. Das offizielle Werkzeug, um Pakete aus dem PyPI zu installieren, nennt sich pip und wird automatisch mit der offiziellen Python-Installation mitgeliefert (mehr dazu weiter unten).\nUm komfortabel Python-Code schreiben zu können, sollte man auch einen guten Code-Editor installieren. Wir werden in diesem Kurs das Programm IDLE verwenden, das in der offiziellen Python-Installation enthalten ist. IDLE ist eine sehr einfache Lernumgebung, die ideal für Anfänger geeignet ist, weil sie wirklich nur die allernötigsten Funktionen bietet. Sobald man aber etwas geübter im Umgang mit Python ist, sollte man auf einen mächtigeren Code-Editor wie Visual Studio Code oder PyCharm umsteigen."
  },
  {
    "objectID": "02/02.html#aufbau-von-python",
    "href": "02/02.html#aufbau-von-python",
    "title": "2 – Die Python-Umgebung",
    "section": "",
    "text": "Eine Python-Installation besteht aus der Programmiersprache Python, einem Interpreter (ein Programm, welches Python-Code ausführen kann), und der umfangreichen Standardbibliothek. Python selbst stellt nur grundlegende Programmierkonstrukte zur Verfügung, wie z.B. Schleifen, Bedingungen und einige fest eingebaute Funktionen. Die mitgelieferte Standardbibliothek erweitert die Kernfunktionalität um zusätzliche Datentypen, Ein-/Ausgabe, reguläre Ausdrücke, mathematische Funktionen, Datenkompression, Netzwerkfunktionen, grafische Benutzeroberflächen und vieles mehr.\n\n\n\n\n\n\nTipp\n\n\n\nIm vorigen Kapitel haben wir bereits import math verwendet, um auf mathematische Funktionen und Konstanten zuzugreifen. Diese Vorgehensweise ist notwendig, um Objekte aus einem Modul verwenden zu können. Man muss also das math-Modul aus der Standardbibliothek importieren, um danach auf mathematische Funktionen wie math.sqrt (Quadratwurzel) oder Konstanten wie math.pi (Kreiszahl) zugreifen zu können.\n\n\nZusätzlich gibt es noch tausende sogenannte Python-Pakete, die sehr einfach zu einer existierenden Python-Installation hinzugefügt werden können. Diese Python-Pakete sind komplett unabhängig von Python, werden also auch nicht von denselben Personen entwickelt und veröffentlicht. Der Python Package Index (PyPI) sammelt alle verfügbaren Pakete an einer zentralen Stelle. Das offizielle Werkzeug, um Pakete aus dem PyPI zu installieren, nennt sich pip und wird automatisch mit der offiziellen Python-Installation mitgeliefert (mehr dazu weiter unten).\nUm komfortabel Python-Code schreiben zu können, sollte man auch einen guten Code-Editor installieren. Wir werden in diesem Kurs das Programm IDLE verwenden, das in der offiziellen Python-Installation enthalten ist. IDLE ist eine sehr einfache Lernumgebung, die ideal für Anfänger geeignet ist, weil sie wirklich nur die allernötigsten Funktionen bietet. Sobald man aber etwas geübter im Umgang mit Python ist, sollte man auf einen mächtigeren Code-Editor wie Visual Studio Code oder PyCharm umsteigen."
  },
  {
    "objectID": "02/02.html#idle",
    "href": "02/02.html#idle",
    "title": "2 – Die Python-Umgebung",
    "section": "IDLE",
    "text": "IDLE\nWie bereits im vorigen Kapitel erwähnt, öffnet sich nach dem Start von IDLE ein Fenster namens IDLE Shell, in welchem der interaktive Python-Interpreter läuft:\n\nDer interaktive Interpreter wird benutzt, um einzelne Zeilen Python-Code interaktiv auszuführen. Dies bedeutet, dass Python das Ergebnis einer Berechnung direkt nach dem Ausführen eines Befehls anzeigt. Allerdings speichert der interaktive Interpreter den eingegebenen Code nicht, d.h. wenn man IDLE neu startet, sind alle vorherigen Eingaben nicht mehr verfügbar.\n\n\n\n\n\n\nTipp\n\n\n\nJedes Python-Programm beginnt also immer “bei Null”. Das ist grundsätzlich sinnvoll, da es dazu beiträgt, reproduzierbaren Code zu schreiben.\n\n\nUm Code zu speichern, muss man ihn in eine Textdatei mit der Dateiendung .py speichern (solche Dateien werden auch Python-Skripte oder Python-Programme genannt). IDLE bietet einen einfachen Texteditor zum Erstellen und Bearbeiten von Python-Skripten, die dann vom Python-Interpreter ausgeführt werden können:\n\nUm ein neues Skript zu erstellen, wählt man im Menü “File” &gt; “New File”. Es öffnet sich ein neues Texteditor-Fenster, in dem man Python-Code schreiben und in eine Datei mit der Endung .py speichern kann. Um das gesamte Skript auszuführen, wählt man im Menü “Run” &gt; “Run Module” (oder drückt F5). Das Skript wird dann ausgeführt und eventuelle Ergebnisse sind im interaktiven Interpreter verfügbar."
  },
  {
    "objectID": "02/02.html#zusatzpakete-verwalten",
    "href": "02/02.html#zusatzpakete-verwalten",
    "title": "2 – Die Python-Umgebung",
    "section": "Zusatzpakete verwalten",
    "text": "Zusatzpakete verwalten\nDas Werkzeug pip wird zur Verwaltung von Zusatzpaketen verwendet. Es kann neue Pakete installieren, bereits installierte Pakete aktualisieren oder auch komplett wieder entfernen. Eine Python-Installation sollte damit regelmäßig gewartet werden, d.h. veraltete Pakete sollten nach Möglichkeit aktualisiert werden. Die Standardbibliothek wird dadurch allerdings nicht beeinflusst – diese ändert sich nur, wenn man eine neuere Python-Version installiert.\nDabei ist pip ein sogenanntes Kommandozeilenprogramm, d.h. es verfügt über keine grafische Oberfläche, sondern wird im Terminal (oft auch Eingabeaufforderung genannt) ausgeführt. Um die folgenden Beispiele nachzuvollziehen, muss man also zuerst ein Terminal öffnen (das Programm heißt in den diversen Betriebssystemen praktischerweise auch einfach “Terminal”).\nNach dem Starten des Terminals kann man nun Textbefehle eintippen. Wichtig ist, dass hier kein Python-Interpreter läuft, sondern eine sogenannte Shell – man kann also keine Python-Befehle eintippen, sondern ausschließlich Shell-Befehle! Um zu testen, ob pip funktioniert und welche Version installiert ist, gibt man folgendes ein:\npip --version\nWenn man hier eine Versionsnummer angezeigt bekommt (z.B. 25.2), funktioniert pip korrekt. Falls hier eine Fehlermeldung ausgegeben wird, wurde vermutlich die Python-Installation nicht korrekt durchgeführt. In diesem Fall installiert man am besten anhand der in der ersten Einheit beschriebenen Schritte Python erneut.\n\n\n\n\n\n\nWichtig\n\n\n\nUnter macOS muss man pip3 statt pip schreiben, so wie man auch python3 statt python zum Starten des Interpreters verwenden muss.\n\n\nWenn man wissen möchte, welche Pakete installiert sind, verwendet man den folgenden Befehl:\npip list\nDie Ausgabe beinhaltet alle installierten Pakete, einschließlich ihrer Namen und Versionen. Wenn man Python gerade erst frisch installiert hat, enthält diese Liste nur wenige Einträge.\nBevor man ein neues Paket installieren kann, muss man dessen Namen kennen. Die PyPI-Website kann verwendet werden, um nach einem bestimmten Paket zu suchen. Ein Paket kann dann wie folgt installiert werden (&lt;package_name&gt; muss durch den tatsächlichen Namen ersetzt werden):\npip install &lt;package_name&gt;\nDas Entfernen eines Pakets ist ähnlich einfach:\npip uninstall &lt;package_name&gt;\nEine Liste aller Pakete, die aktualisiert werden können, erhält man mit:\npip list --outdated\nFalls dieser Befehl veraltete Pakete anzeigt, kann man jedes einzelne Paket mit folgendem Befehl aktualisieren:\npip install --upgrade &lt;package_name&gt;\n\n\n\n\n\n\nHinweis\n\n\n\nSobald man mit Python etwas vertrauter ist, sollte man eine sogenannte virtuelle Umgebung für jedes Projekt verwenden, anstatt alle Zusatzpakete global zu installieren. Dies ermöglicht es, die für ein Projekt benötigten Pakete in separaten isolierten Umgebungen zu installieren und so Konflikte zwischen verschiedenen Projekten zu vermeiden. In diesem Kurs werden wir virtuelle Umgebungen aber nicht verwenden."
  },
  {
    "objectID": "02/02.html#der-python-interpreter",
    "href": "02/02.html#der-python-interpreter",
    "title": "2 – Die Python-Umgebung",
    "section": "Der Python-Interpreter",
    "text": "Der Python-Interpreter\nDer Python-Interpreter führt Python-Code aus. Er kann auf zwei unterschiedliche Arten verwendet werden:\n\nInteraktiver Modus\nSkript-Modus\n\n\nInteraktiver Modus\nIm interaktiven Modus hat man die Möglichkeit, einzelne Python-Befehle einzugeben. Diese werden sofort ausgeführt und eventuelle Ergebnisse werden am Bildschirm ausgegeben. Ein sogenannter Prompt (&gt;&gt;&gt;) signalisiert, dass Python bereit ist und Befehle eingegeben werden können, zum Beispiel:\n\n1 + 4\n\n5\n\n\nDas Ergebnis 5 wird unmittelbar nach dem Befehl ausgegeben.\n\n\n\n\n\n\nTipp\n\n\n\nWir werden den interaktiven Interpreter hauptsächlich innerhalb von IDLE verwenden (“IDLE Shell”), aber es ist auch möglich, den interaktiven Interpreter direkt im Terminal mit dem Befehl python (bzw. python3 auf macOS) zu starten.\n\n\n\n\nSkript-Modus\nIm Gegensatz zum interaktiven Modus kann Python im Skript-Modus viele Zeilen Code, also insbesondere ein komplettes Skript, auf einmal ausführen. Wie wir bereits wissen, ist ein Python-Skript eine Textdatei (mit der Endung .py), die Python-Code enthält. Im Allgemeinen enthält eine Zeile des Skripts genau einen Python-Befehl. Im Vergleich zum interaktiven Modus zeigt Python die Ergebnisse allerdings nicht automatisch an. Angenommen, ein Python-Skript mit dem Namen test.py enthält die folgende Zeile:\n1 + 4\nDas Ausführen dieses Skripts (z.B. in IDLE mittels F5 oder im Terminal mit python test.py) führt zwar jeden Befehl im Skript aus, aber es wird kein Ergebnis angezeigt. Dies ist durchaus beabsichtigt und sinnvoll, weil ein Skript oft viele Befehle enthält und es nicht immer erwünscht ist, dass jedes Ergebnis ausgegeben wird. Im Gegensatz dazu ist der interaktive Modus genau dafür gedacht, einzelne Befehle auszuprobieren und sofort die Ergebnisse zu sehen. Wenn man ein Ergebnis im Skript-Modus sehen möchte, muss man dieses explizit mit der print-Funktion ausgeben lassen. Der Code in test.py müsste also stattdessen so aussehen:\nprint(1 + 4)"
  },
  {
    "objectID": "02/02.html#syntax",
    "href": "02/02.html#syntax",
    "title": "2 – Die Python-Umgebung",
    "section": "Syntax",
    "text": "Syntax\nUnter Syntax versteht man die Regeln einer Sprache, die festlegen, wie man aus grundlegenden Zeichen gültige Sprachkonstrukte erzeugt.\nEin spezielles Merkmal der Syntax von Python ist, dass Einrückungen Bedeutung haben – sie gruppieren zusammengehörigen Code. Die meisten anderen Programmiersprachen verwenden dafür spezielle Zeichen oder Schlüsselwörter wie z.B. begin, end, { oder }. Durch Einrückungen benötigt Python diese Zeichen nicht, und der Code wird dadurch automatisch strukturierter und kürzer. Dies ist im folgenden Beispiel veranschaulicht (bitte achten Sie nur auf die Struktur, der Inhalt/die Bedeutung des Beispiels ist hier nicht relevant; die Zeilennummern sind außerdem nicht Teil der Syntax und werden nur zur besseren Orientierung angezeigt):\n# this is a comment\ndef do_something(n_times=10):\n    counter = 0\n    for i in range(n_times):\n        print(i)\n        if i % 2:  # odd number\n            counter += 1\n            print(\"Odd\")\n    return counter\n\ncounter = do_something()\nprint(counter)\nVersuchen wir, die wichtigsten syntaktischen Elemente in diesem Beispiel zu identifizieren. Zunächst fällt auf, dass in Zeilen 1 und 6 sogenannte Kommentare verwendet werden. Diese werden durch ein #-Zeichen eingeleitet. Alles, was danach folgt (also bis zum Zeilenende), wird von Python ignoriert. So kann man Kommentare in natürlicher Sprache zur Erklärung des Codes hinzufügen.\nWenden wir uns nun den einzelnen durch Einrückungen definierten Blöcken in diesem Beispiel zu. Standardmäßig wird ein Block mit vier Leerzeichen eingerückt, d.h. der erste Block beginnt in Zeile 2. Zu diesem Block gehören alle folgenden eingerückten Codezeilen, also Zeilen 3–9. Da die Zeilen 11–12 nicht mehr eingerückt sind, gehören diese auch nicht zu diesem Block.\n\n\n\n\n\n\nHinweis\n\n\n\nEin neuer Block wird immer durch eine Code-Zeile eingeleitet, welche mit einem : endet.\n\n\nInnerhalb dieses Blocks gibt es aber noch weitere untergeordnete Blöcke. Ein neuer Block wird in Zeile 4 definiert, er beinhaltet die Zeilen 5–8. Darin gibt es einen weiteren Block, eingeleitet in Zeile 6 und bestehend aus Code in den Zeilen 7–8. Zeile 9 gehört wieder zum ersten Block (in Zeile 2 definiert).\nDes Weiteren sieht man noch die Verwendung von Funktionen – diese werden mit ihrem Namen und den Argumenten in Klammern aufgerufen, z.B. do_something(6) in Zeile 11 oder print(counter) in Zeile 12. Wenn man eine Funktion aufruft, wird diese ausgeführt – sie erledigt also sozusagen die in ihr definierten Aufgaben. Es gibt auch Funktionen ohne Argumente, diese müssen aber trotzdem mit den Klammern aufgerufen werden, z.B. print(). Mehr zu Funktionen werden wir in einer der nächsten Einheiten lernen. Wichtig ist zu diesem Zeitpunkt nur, dass Sie erkennen können, wie ein Funktionsaufruf aussieht. Ein solcher ist nämlich immer über das Klammernpaar (innerhalb derer eventuelle Argumente vorkommen können) erkennbar, welches direkt auf den Namen der Funktion folgt.\n\n\n\n\n\n\nWichtig\n\n\n\nDas Klammernpaar () wird benötigt, um eine Funktion aufzurufen. Man nennt es daher auch Aufrufoperator.\n\n\nVeranschaulichen wir dieses Thema noch mit einem Beispiel. In der ersten Einheit haben wir die Quadratwurzel einer Zahl berechnet. Dazu haben wir die Funktion math.sqrt aufgerufen, und zwar mit der gewünschten Zahl als Argument, welches wir innerhalb der Klammern angegeben haben. Durch Aufrufen der Funktion wird also deren Code ausgeführt (also die Quadratwurzel des Arguments berechnet):\n\nimport math\n\nmath.sqrt(4)\n\n2.0\n\n\n\n\n\n\n\n\nTipp\n\n\n\nPython ist sehr genau, was die Syntax betrifft. Zum Beispiel ist es wichtig, die korrekte Groß-/Kleinschreibung zu beachten, d.h. print ist nicht dasselbe wie Print. Ein fehlender : an Stellen, an denen dieser notwendig ist, führt zu einem Syntaxfehler. Falsche Einrückungen können entweder zu einem Syntaxfehler oder zu unerwünschtem Verhalten führen (was bedeutet, dass das Python-Programm ohne Fehler ausgeführt wird, aber nicht das tut, was man eigentlich beabsichtigt hat).\nEs ist auf jeden Fall sehr lehrreich, fehlerhaften Code im interaktiven Interpreter auszuprobieren, zum Beispiel:\n\nPrint(\"Hello\")\n\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[3], line 1\n----&gt; 1 Print(\"Hello\")\n\nNameError: name 'Print' is not defined\n\n\n\nEs ist wichtig, mit den Fehlermeldungen von Python vertraut zu sein, um sie korrekt und effizient zu interpretieren (schließlich sollte das Ziel sein, sie zu beheben). Machen Sie also Fehler und lernen Sie daraus!"
  },
  {
    "objectID": "02/02.html#stilistische-konventionen",
    "href": "02/02.html#stilistische-konventionen",
    "title": "2 – Die Python-Umgebung",
    "section": "Stilistische Konventionen",
    "text": "Stilistische Konventionen\nIm Gegensatz zur Syntax, die man strikt einhalten muss, gibt es auch stilistische Konventionen, die den Code lesbarer und verständlicher machen. Diese Konventionen sind zwar nicht zwingend notwendig, aber es ist sehr empfehlenswert, sich trotzdem daran zu halten. Beispielsweise sind die folgenden drei Anweisungen syntaktisch korrekt und führen alle zum selben Ergebnis:\n\nx = 1 + 2 + 3 * (16 - 7)\nx=1+    2+  3*  (   16-7    )\nx=1+2+3*(16-7)\n\nDer erste Befehl ist vermutlich am besten lesbar, weil alle Operatoren von jeweils einem Leerzeichen umgeben sind, und deswegen sollte man darauf achten, den Code entsprechend zu formatieren. Viele solche stilistischen Empfehlungen sind im Python Enhancement Proposal 8 (PEP8) zusammengefasst. Mit Ruff kann man Python-Code automatisch formatieren lassen. Dazu installiert man es zunächst mittels pip:\npip install ruff\nDanach kann man die folgenden Befehle im Terminal verwenden, um eine Datei namens test.py zu formatieren:\nruff check --fix test.py\nruff format test.py\n\n\n\n\n\n\nHinweis\n\n\n\nDie beiden obigen Befehle sind Shell-Befehle und müssen, genau wie pip, im Terminal ausgeführt werden (nicht im Python-Interpreter). Damit sie funktionieren, muss sich die Datei test.py im aktuellen Verzeichnis befinden. Man kann den Befehl ls (bzw. dir) verwenden, um den Inhalt des aktuellen Verzeichnisses anzuzeigen. Falls die Datei nicht aufscheint, kann man mit dem Befehl cd &lt;Verzeichnis&gt; in das entsprechende Verzeichnis wechseln (hier ersetzt man &lt;Verzeichnis&gt; durch den tatsächlichen Pfad, also z.B. cd C:\\Users\\IhrName\\Documents unter Windows oder cd /Users/IhrName/Documents unter macOS).\nJe nach Installation kann es außerdem sein, dass man ruff nicht direkt verwenden kann. In diesem Fall sollte es mit python -m ruff (bzw. python3 -m ruff unter macOS) anstelle von ruff funktionieren.\nManche Dinge können übrigens nicht automatisch korrigiert werden, z.B. wenn import nicht, wie von PEP8 empfohlen, am Beginn eines Skripts steht. In solchen Fällen muss man den Code manuell anpassen."
  },
  {
    "objectID": "02/02.html#hilfe",
    "href": "02/02.html#hilfe",
    "title": "2 – Die Python-Umgebung",
    "section": "Hilfe",
    "text": "Hilfe\n\nIntegrierte Hilfe\nHilfe zu Python-Befehlen kann man auch direkt im Python-Interpreter erhalten. Möchte man z.B. Informationen zur Funktion print bekommen, tippt man einfach folgenden Befehl ein:\n\nhelp(print)\n\nHelp on built-in function print in module builtins:\n\nprint(*args, sep=' ', end='\\n', file=None, flush=False)\n    Prints the values to a stream, or to sys.stdout by default.\n\n    sep\n      string inserted between values, default a space.\n    end\n      string appended after the last value, default a newline.\n    file\n      a file-like object (stream); defaults to the current sys.stdout.\n    flush\n      whether to forcibly flush the stream.\n\n\n\n\n\nOnline-Hilfe\nEinen guten Überblick bietet die offizielle Python-Dokumentation. Hier werden viele Themengebiete rund um Python sehr umfangreich beschrieben. Auch das Tutorial ist sehr zu empfehlen.\nDurch die große und sehr aktive Community findet man mit einer Internet-Suchmaschine besonders viele Fragen und Antworten rund um Python. Sehr hochwertige Antworten findet man meist auf StackOverflow.\nAuch KI-Tools wie ChatGPT können hilfreich sein, um schnell Antworten auf konkrete Fragen zu bekommen oder um sich Code erklären zu lassen.\n\n\nOnline-Kurse\nEinführungskurse bzw. leicht fortgeschrittene Kurse über Python gibt es viele. Hier ist eine kleine Auswahl an frei verfügbaren Kursen, die Sie nach dieser Lehrveranstaltung (oder sogar parallel dazu) absolvieren könnten:\n\nLearn to Program: The Fundamentals\nLearn to Program: Crafting Quality Code\nProgramming for Everybody (Getting Started with Python)\nPython Data Structures\nAn Introduction to Interactive Programming in Python (Part 1)\nAn Introduction to Interactive Programming in Python (Part 2)\nLearn Python\n\n\n\nBücher\nKlassische Bücher oder Websites eignen sich ebenfalls sehr gut zum Selbststudium. Im Folgenden finden Sie eine kleine Auswahl an kostenlos verfügbaren Ressourcen:\n\nThink Python\nA Byte of Python\nPython for You and Me\nReal Python"
  },
  {
    "objectID": "02/02.html#übungen",
    "href": "02/02.html#übungen",
    "title": "2 – Die Python-Umgebung",
    "section": "Übungen",
    "text": "Übungen\n\nÜbung 1\nGeben Sie eine Liste aller installierten Pakete in Ihrer Python-Installation aus – welchen Befehl verwenden Sie dazu und wie sieht die Liste aus? Wie viele Pakete sind installiert?\n\n\nÜbung 2\nAktualisieren Sie zunächst alle installierten Pakete (falls notwendig). Suchen Sie dann nach dem Paket ipython – ist dieses Paket bereits installiert? Falls nicht, installieren Sie es! Führen Sie diese beiden Schritte auch für das Paket numpy durch. Abschließend deinstallieren Sie die beiden Pakete wieder.\nGeben Sie dann die Liste aller installierten Pakete erneut aus – sind ipython und numpy noch vorhanden? Was ist mit den Abhängigkeiten dieser Pakete passiert – wurden diese ebenfalls deinstalliert?\n\n\nÜbung 3\nErstellen Sie ein einfaches Python-Skript namens test.py mit Hilfe von IDLE. Das Skript soll lediglich Hello World! am Bildschirm ausgeben (verwenden Sie dazu die print-Funktion). Halten Sie sich dabei an folgende Struktur:\n\nDie erste Zeile soll eine Kommentarzeile mit Ihrem Namen sein\nDie zweite Zeile soll leer sein\nDie dritte Zeile soll den print-Funktionsaufruf beinhalten\nDie letzte Zeile soll wieder leer sein\n\nAchten Sie darauf, dass Ihr Skript PEP8-konform ist (verwenden Sie zur Überprüfung Ruff). Führen Sie Ihr Skript auch aus – so können Sie sicherstellen, dass der Code korrekt ist und keine Fehler produziert.\n\n\nÜbung 4\nSehen Sie sich die Hilfe zu den Funktionen print und sum direkt im Python-Interpreter an!"
  },
  {
    "objectID": "09/09-solutions.html",
    "href": "09/09-solutions.html",
    "title": "9 – Lösungen",
    "section": "",
    "text": "import numpy as np\n\nt = np.arange(0, 10, 0.1)\nt.size  # 100 Elemente\n\n100\n\n\n\nt.shape  # (100,)\n\n(100,)"
  },
  {
    "objectID": "09/09-solutions.html#übung-1",
    "href": "09/09-solutions.html#übung-1",
    "title": "9 – Lösungen",
    "section": "",
    "text": "import numpy as np\n\nt = np.arange(0, 10, 0.1)\nt.size  # 100 Elemente\n\n100\n\n\n\nt.shape  # (100,)\n\n(100,)"
  },
  {
    "objectID": "09/09-solutions.html#übung-2",
    "href": "09/09-solutions.html#übung-2",
    "title": "9 – Lösungen",
    "section": "Übung 2",
    "text": "Übung 2\n\ns = t.reshape((20, -1))  # 20 Zeilen, 5 Spalten"
  },
  {
    "objectID": "09/09-solutions.html#übung-3",
    "href": "09/09-solutions.html#übung-3",
    "title": "9 – Lösungen",
    "section": "Übung 3",
    "text": "Übung 3\n\nfrom numpy.random import default_rng\n\nrng = default_rng(seed=18)\nu = rng.integers(low=-1000, high=1000, size=(100, 8))\nu.sum()  # Summe aller Elemente\n\nnp.int64(20663)\n\n\n\nu.mean()  # Mittelwert aller Elemente\n\nnp.float64(25.82875)\n\n\n\nu.mean(1)  # Zeilenmittelwerte\n\narray([ -45.   ,  428.875,   66.25 ,  345.125,  106.5  ,  123.   ,\n        -12.375,  164.5  ,  183.125,  -79.375,  -83.75 , -220.875,\n       -288.5  , -264.25 ,  328.125,  -25.625,  168.625,  204.625,\n         81.75 ,   35.5  ,    8.5  , -370.75 ,  208.25 ,  589.5  ,\n        -71.875,   -4.625,   62.5  ,  129.   ,   13.375,   11.625,\n        -51.125, -139.875, -137.375, -124.75 , -354.25 ,  274.125,\n        145.125,   53.625,   64.375,  -54.875,  316.375,  -23.375,\n        216.375,  -38.25 ,  -52.5  , -199.625,   46.25 ,   24.25 ,\n        249.   ,  424.   ,  347.125,  -55.625,   12.   ,   30.5  ,\n        349.25 , -132.   , -174.875,  115.375,  238.625, -322.25 ,\n        -80.25 ,  -44.25 ,   48.75 ,  270.875, -157.375, -282.25 ,\n         69.125,  185.25 ,  -95.75 ,  146.125,   95.375,  145.875,\n         59.75 ,   31.625,   51.125,  -30.375, -285.   , -225.625,\n        195.875, -244.   , -117.75 ,  218.25 ,   82.625, -263.875,\n        114.25 ,  378.25 , -178.25 ,   97.   , -345.625,   51.625,\n        110.625, -245.   ,  131.125,    6.75 ,   34.125, -210.625,\n         60.625,   19.75 , -266.125,  212.875])\n\n\n\nu.mean(0)  # Spaltenmittelwerte\n\narray([162.55,  23.24, -21.51, -19.6 ,  -3.16, -26.86,  72.6 ,  19.37])\n\n\n\nu.max(0)  # Spaltenmaxima\n\narray([994, 986, 969, 983, 957, 998, 995, 996])\n\n\n\nu.min(0)  # Spaltenminima\n\narray([ -985,  -994,  -875,  -990, -1000,  -988,  -963,  -997])\n\n\n\nu.max(1)  # Zeilenmaxima\n\narray([787, 939, 612, 896, 527, 710, 842, 760, 859, 699, 758, 405, 750,\n       726, 882, 921, 505, 507, 858, 846, 733, 737, 927, 963, 996, 973,\n       994, 995, 895, 962, 701, 625, 978, 970, 734, 970, 830, 990, 951,\n       892, 991, 930, 951, 901, 858, 605, 986, 940, 966, 928, 821, 672,\n       727, 925, 945, 708, 890, 928, 963, 874, 759, 690, 998, 886, 771,\n       284, 566, 984, 882, 753, 692, 943, 578, 701, 957, 957,  50, 707,\n       949, 494, 761, 983, 850, 572, 704, 969, 852, 832, 532, 784, 934,\n       709, 628, 913, 868, 772, 770, 769, 335, 962])\n\n\n\nu.min(1)  # Zeilennminima\n\narray([ -835,   127,  -756,  -950,  -703,  -986,  -864,  -883,  -341,\n        -761,  -966,  -638,  -955,  -937,  -875,  -913,  -618,  -265,\n        -690,  -857,  -961,  -922,  -990,   154,  -937, -1000,  -797,\n        -666,  -822,  -920,  -863,  -889,  -944,  -722,  -915,  -649,\n        -911,  -976,  -423,  -939,  -509,  -637,  -693,  -790,  -877,\n        -835,  -716,  -685,  -919,  -461,  -918,  -583,  -901,  -552,\n        -140,  -870,  -767,  -670,  -479,  -969,  -963,  -695,  -901,\n        -855,  -746,  -970,  -703,  -680,  -988,  -681,  -820,  -773,\n        -590,  -691,  -851,  -861,  -641,  -912,  -716,  -929,  -971,\n        -997,  -354,  -994,  -772,  -761,  -782,  -422,  -908,  -761,\n        -920,  -810,  -688,  -632,  -738,  -866,  -847,  -692,  -985,\n        -808])\n\n\n\nu.mean(1).max()  # Maximum der Zeilenmittelwerte\n\nnp.float64(589.5)"
  },
  {
    "objectID": "09/09-solutions.html#übung-4",
    "href": "09/09-solutions.html#übung-4",
    "title": "9 – Lösungen",
    "section": "Übung 4",
    "text": "Übung 4\n\nx = np.arange(1, 151).reshape(3, 10, 5)\nx.mean(axis=(1, 2))\n\narray([ 25.5,  75.5, 125.5])"
  },
  {
    "objectID": "09/09-solutions.html#übung-5",
    "href": "09/09-solutions.html#übung-5",
    "title": "9 – Lösungen",
    "section": "Übung 5",
    "text": "Übung 5\nEs gibt viele Möglichkeiten, diese Aufgabe zu lösen. Hier sind drei Varianten:\n\nMöglichkeit 1\n\nchess = np.zeros((8, 8), dtype=int)\nfor row in range(0, 8):\n    if row % 2 == 1:\n        chess[row, ::2] = 1\n    else:\n        chess[row, 1::2] = 1\nchess\n\narray([[0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0]])\n\n\n\n\nMöglichkeit 2\n\nchess = np.tile(np.array([[0, 1], [1, 0]]), (4, 4))\nchess\n\narray([[0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0]])\n\n\n\n\nMöglichkeit 3\n\nchess = np.zeros((8, 8), dtype=int)\nchess[::2, 1::2] = 1\nchess[1::2, ::2] = 1\nchess\n\narray([[0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0],\n       [0, 1, 0, 1, 0, 1, 0, 1],\n       [1, 0, 1, 0, 1, 0, 1, 0]])\n\n\nAls zusätzliche Übung könnten Sie versuchen, eine Lösung in eine Funktion zu verpacken, welche ein Schachbrettmuster mit bestimmter Größe size erzeugt, also z.B.\ndef generate_chess(size=8):\n    ..."
  }
]