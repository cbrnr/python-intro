---
title: "8 – Input and Output"
subtitle: "Introduction to Python and PsychoPy"
author: "Clemens Brunner"
date: 2024-11-28
format:
  html:
    page-layout: full
engine: jupyter
highlight-style: github
title-block-banner: true
theme:
  light: flatly
  dark: darkly
---

## Introduction

Input refers to the input of information from the keyboard or from a file in order to process it in a program. Output refers to the output of information on the screen or to a file (e.g. results of a calculation). In this chapter, we will learn how to format strings for output and how to read from and write to text files.


## Displaying strings

### Concatenating strings

We have already learned about the `print` function, which can display strings (and other objects) on the screen. In the simplest case, a *string* can be displayed like this:

```{python}
print("Hallo")
```

We can also pass *numbers* as arguments to `print`:

```{python}
print(55)
```

The `str` function can convert any object (such an integer, a float, etc.) to a string:

```{python}
str(55)
```

The `print` function can take *any number* of arguments. It will then display all arguments separated by spaces:

```{python}
a = 5
b = 10
print(a, "+", b, "=", a + b)  # five arguments
```

:::{.callout-note}
The `print` function has two optional parameters `sep` and `end`, which influence the separator between the arguments and the character at the end of the output:

- `sep=" "`: Separator between the arguments (default: space)
- `end="\n"`: Character at the end of the output (default: newline)

What is the output of the previous example if you set `sep=""`? What does `end="!!!"` do?
:::

As we already know, we can concatenate multiple strings with `+`. Therefore, the previous output could also be generated by concatenating individual strings:

```{python}
print(str(a) + " + " + str(b) + " = " + str(a + b))  # one argument
```


### F-strings

Formatted strings, or short f-strings, are a more modern way to format strings. They are prefixed with an `f` and can contain expressions within curly braces `{}`. The following example shows a simple f-string without any expressions (so a normal string would suffice):

```{python}
f"Hello"  # same as "Hello"
```

F-strings are only useful if you actually include expressions within curly braces `{}`. All expressions are evaluated and interpolated into the string:

```{python}
name = "World"
f"Hello {name}!"
```

As usual, we can print the resulting string with `print`. The example from the previous section can be rewritten as follows:

```{python}
print(f"{a} + {b} = {a + b}")
```

Expressions such as numbers can also be *formatted* optionally. Let's first look at how the number $\pi$ is displayed by default:

```{python}
import math

print(f"π ≈ {math.pi}")
```

With an optional colon and a so-called *format specifier* within the curly braces, an expression can be formatted specifically. The following example formats the number $\pi$ so that it is displayed with three decimal places:

```{python}
print(f"π ≈ {math.pi:.3f}")
```

Or with 16 decimal places:

```{python}
print(f"π ≈ {math.pi:.16f}")
```

You can specify the minimum width by adding a number directly after the colon. In the following example, the number (formatted to show three decimal places) should occupy at least 15 characters:

```{python}
print(f"π ≈ {math.pi:15.3f}")
```

All possibilities that format specifiers offer can be found in the [official documentation](https://docs.python.org/3/library/string.html#format-string-syntax) (including many examples).


## Reading and writing files

Python provides built-in functions to read from and write to files. The `open` function returns a file object that can be used to read from or write to files (the file `test.txt` used in the example is available [here](test.txt)):

```python
f = open("test.txt", "w")
```

The first argument is the filename, and the second argument describes the mode (`"r"` read, `"w"` write, `"a"` append). The default mode is `"r"` if the argument is not explicitly passed.

Using the file object `f`, you can then read from or write to the file (depending on the mode).

:::{.callout-important}
After all read and write operations have been completed, you must *close* the file object:

```python
f.close()
```

It is advisable to perform all file operations within a `with` block. This way, the file is *automatically* closed when the block is exited, i.e. you do not need to call `f.close()` manually:

```python
with open("test.txt") as f:
    data = f.read()
```
:::

The filename is a string containing either the absolute path of the file (e.g., `"C:/Program Files/Test Program/test.txt"`) or a relative path (relative to the working directory, e.g., `data/test.txt`).

:::{.callout-note}
Paths should always be separated by a regular `/` and not by a backslash `\` (common on Windows), as the latter introduces an *escape sequence*. If you still want to use `\`, you must write it as `\\`.
:::

The `read` method of a file object reads the *entire file* and returns the content as a string:

```{python}
f = open("test.txt")
text = f.read()
print(text)
```

Note that this loads the *entire* content of the file into memory. For very large files, this can potentially cause problems, which is why you should read (larger) text files *line by line* (more on this later).

:::{.callout-tip}
We can read the content of a file only once. If the entire content has already been read, the so-called file pointer is at the end of the file. If you try to read again, you just get an empty string:

```{python}
f.read()  # reached end of file
```

If you want to read the file again, you must close it and then open it again:

```{python}
f.close()  # closes the file
```
:::

The `readline` method reads *a single line* from the file from the current position:

```{python}
with open("test.txt") as f:
    print("Row 1: ", f.readline(), end="")
    print("Row 2: ", f.readline(), end="")
    print("Row 3: ", f.readline(), end="")
```

You can also iterate over the file object in a loop to read the file line by line:

```{python}
with open("test.txt") as f:
    for line in f:
        print(line, end="")
```

This way, you can easily manipulate individual lines, e.g., to output line numbers (which are not contained in the file itself):

```{python}
with open("test.txt") as f:
    for no, line in enumerate(f):
        print(no, line, end="")
```

:::{.callout-tip}
In the previous example, the `for` loop does not directly iterate over `f`, but over `enumerate(f)`. This function counts (enumerates) the loop iterations and returns a tuple consisting of the current loop counter and the current line.
:::

Writing text to files works very similarly: you open the file in `"w"` mode and pass the desired content as a string to the `write` method:

```python
with open("test2.txt", "w") as f:
    f.write("This is a test.\nThis is how you write\ntext\nto a file.")
```

In this example, the escape sequence `\n` corresponds to a line break (new line).


## Example: Reading a CSV file

With the tools presented so far, we can already read CSV[^1] files and calculate rudimentary statistics. CSV files are often used to store tabular data. These files are plain text files in which the variables (columns) are separated by commas, and the individual records are stored line by line.

The following sections present three ways to read a CSV file (the example file `correlation.csv` is available [here](correlation.csv)). The first method uses Python without any additional modules, and the second method is a generalization of the first. The third and simplest method uses the [pandas](https://pandas.pydata.org/) package, which we will not get to know in detail in this course (it is mentioned here for completeness).

[^1]: Comma-Separated Values


### Option 1

We start with an empty list `data`. We then add the content of each line step by step (using `append`) to this list. A line is represented as a list with two strings. First, we remove any leading and trailing spaces from a line using `.strip()`, and then we split the line at the comma into a list with two elements using `.split(",")`:

```{python}
data = []  # emtpy list
with open("correlation.csv") as f:
    for row in f:
        data.append(row.strip().split(","))
```

```{python}
data
```

Now we can convert the data into a structure that is better suited for subsequent calculations (in particular, we want to convert the strings to numbers). We can do this by iterating over the list and converting the strings to floats:

```{python}
cols = [[], []]  # two empty lists for the two columns
for row in data[1:]:  # skip row 0
    cols[0].append(float(row[0]))  # column 1
    cols[1].append(float(row[1]))  # column 2
```

Both columns are now available in the list `cols`. This list has two elements:

```{python}
len(cols)
```

Each of these two entries in `cols` is also a list:

```{python}
type(cols[0]), type(cols[1])
```

The length of both lists corresponds to the number of rows in the CSV file (excluding the header):

```{python}
len(cols[0]), len(cols[1])
```

The elements in these two lists are numbers:

```{python}
cols[0]
```

```{python}
cols[1]
```

With these two lists, you can now perform calculations. For example, you can calculate the column means as follows:

```{python}
sum(cols[0]) / len(cols[0])
```

```{python}
sum(cols[1]) / len(cols[1])
```

This solutions works, but it is far from ideal. First, there are existing packages that should be preferred over developing everything from scratch (Python has its own `csv` module, and the `pandas` package is ideal for such tasks). Second, this solution is very specific to the concrete file, e.g., the approach only works for a file with exactly two columns.


### Option 2

A generalized solution for an *arbitrary* number of columns looks like this:

```{python}
with open("correlation.csv") as f:
    header = f.readline().strip().split(",")  # first row

    data = {}  # dict with one entry per column
    for name in header:
        data[name] = []  # key = column name, value = empty list

    for row in f:  # remaining rows
        values = row.strip().split(",")
        for h, v in zip(header, values):
            data[h].append(float(v))  # append to correct list
```

Here, we first read the variable names from the first line (the header). Next, we create a dictionary with one entry per column, where the key is the column name and the value is an empty list. We then iterate over the remaining lines and add the values of the columns to the correct dictionary entries.

```{python}
data
```

This solution works with any number of columns, but it assumes that there is a header row. The column means can then be calculated as follows:

```{python}
sum(data["essay"]) / len(data["essay"])
```

```{python}
sum(data["hours"]) / len(data["hours"])
```


### Option 3

The `pandas` package is perfect for processing tabular data. It also includes functions for reading files. Our code would look like this:

```{python}
import pandas as pd

data = pd.read_csv("correlation.csv")
```

```{python}
data
```

We can calculate the column means as follows:

```{python}
#| scrolled: true
data.mean()
```


## Exercises

### Exercise 1

Create a list `lst` that contains the *even* numbers between 0 and 100 (inclusive) and save these numbers to a file `ex1.txt`. Each number should be on a separate line.

:::{.callout-note}
You should convert the numbers to strings before writing them to the file (using the `str` function). The character (escape sequence) for a line break is `\n`. You can iterate over the list of numbers with a `for` loop and write the individual elements to the file one after the other. Alternatively, you can convert the list into a single properly formatted string (the `join` string method is helpful here) and then write this string to the file.
:::


### Exercise 2

Use the list `lst` from Exercise 1, but write the numbers to a file `ex2.txt` so that they are separated by commas in a single line.


### Exercise 3

Scrabble is an excellent opportunity to discuss the existence of words. At least for the English edition, there is an [official word list](http://www.freescrabbledictionary.com/sowpods/) that you can consult if you are unsure whether a word is valid or not. All words in this database can be downloaded as a [text file](https://www.wordgamedictionary.com/sowpods/download/sowpods.txt).

For this exercise, download this file and save it in your working directory. Read the file into Python and find out how many valid words (lines) exist.

:::{.callout-note}
Iterate over the file line by line and count the number of iterations. At the end of the loop, your counter corresponds to the number of lines in the file (i.e., the number of words). Note that the first few lines in the file do not contain words!

If you want to be very exact, you should also check whether the current line actually contains a word (i.e., is not an empty line).
:::


### Exercise 4

Use the word list from Exercise 3 and find out how many words contain more than 14 letters in the list (i.e., words with 15 letters or more).

:::{.callout-note}
Iterate over the file line by line and remove invisible characters (such as line breaks) with the `strip` method before determining the length of the current word. Otherwise, the length is always one larger than the length of the word because the content of a line is e.g., `abandon\n`, and `\n` is counted as a character. Only increase your counter if the length of the current word (without line break) is greater than 14!
:::
