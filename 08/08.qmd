---
title: "8 – Input and Output"
subtitle: "Introduction to Python and PsychoPy"
author: "Clemens Brunner"
date: 2025-05-05
format:
  html:
    page-layout: full
engine: jupyter
highlight-style: github
title-block-banner: true
theme:
  light: flatly
  dark: darkly
---

## Introduction

Programs often need to interact with the outside world, for example by receiving information from the user or saving results for later. This interaction happens through input and output. Input usually comes from the keyboard or a file, while output is typically shown on the screen or written to a file. In this chapter, you'll learn how to format strings for display, and how to read from and write to text files.


## Displaying strings

### Concatenating strings

We have already learned about the `print` function, which can display strings (and other objects) on the screen. In the simplest case, a *string* can be displayed like this:

```{python}
print("Hallo")
```

We can also pass *numbers* as arguments to `print`:

```{python}
print(55)
```

The `str` function can convert any object (such an integer, a float, etc.) to a string:

```{python}
str(55)
```

Note that the `print` function can take *any number* of arguments. It will then display all arguments separated by spaces:

```{python}
a = 5
b = 10
print(a, "+", b, "=", a + b)  # five arguments
```

:::{.callout-note}
The `print` function has two optional parameters `sep` and `end`, which influence the separator between the arguments and the character at the end of the output:

- `sep=" "`: Separator between the arguments (defaults to a space)
- `end="\n"`: Character at the end of the output (defaults to a newline)

What is the output of the previous example if you set `sep=""`? What does `end="!!!"` do?
:::

As we already know, we can concatenate multiple strings with `+`. Therefore, the previous output could also be generated by concatenating individual strings:

```{python}
print(str(a) + " + " + str(b) + " = " + str(a + b))  # one argument
```


### F-strings

Formatted strings – often called f-strings – offer a modern and convenient way to create strings in Python. They start with the letter `f` and allow us to include expressions inside curly braces `{}`. Here's a simple example of an f-string without any expressions, which behaves just like a regular string:

```{python}
f"Hello"  # same as "Hello", we don't need an f-string here
```

F-strings are really useful if we actually include expressions within curly braces `{}`. All expressions are automatically evaluated and interpolated into the string:

```{python}
name = "World"
f"Hello {name}!"
```

As usual, we can print the resulting string with `print`. The example from the previous section can be rewritten as follows:

```{python}
print(f"{a} + {b} = {a + b}")
```

Expressions such as numbers can also be *formatted* optionally. Let's first look at how the number $\pi$ is displayed by default:

```{python}
import math

print(f"π ≈ {math.pi}")
```

We can provide a *format specifier* right after the expression, starting with a `:`. The following example formats the number $\pi$ so that it is displayed with three decimal places (`.3f` means format the expression as a float with three decimal places):

```{python}
print(f"π ≈ {math.pi:.3f}")
```

Or with 16 decimal places:

```{python}
print(f"π ≈ {math.pi:.16f}")
```

We can specify the minimum width by adding a number directly after the colon. In the following example, the number (formatted to show three decimal places) should occupy at least 15 characters:

```{python}
print(f"π ≈ {math.pi:15.3f}")
```

All possibilities that format specifiers offer can be found in the [official documentation](https://docs.python.org/3/library/string.html#format-string-syntax) (including many examples).


## Reading and writing files

Python provides built-in functions to read from and write to files. The `open` function returns a file object that can be used to read from or write to files (the file `test.txt` used in the example is available [here](test.txt)):

```python
f = open("test.txt", "w")
```

The first argument is the filename, and the second argument describes the mode (`"r"` read, `"w"` write, `"a"` append). The default mode is `"r"` if the argument is not explicitly passed.

Using the file object `f`, we can then read from or write to the file (depending on the mode).

:::{.callout-important}
After all read and write operations have been completed, we must *close* the file object:

```python
f.close()
```

It is advisable to perform all file operations within a `with` block. This way, the file is *automatically* closed when the block is exited, i.e. we do not need to call `f.close()` explicitly:

```python
with open("test.txt") as f:
    data = f.read()
```
:::

The filename is a string containing either the absolute path of the file (e.g., `"C:/Program Files/Test Program/test.txt"`) or a relative path (relative to the working directory, e.g., `data/test.txt`).

:::{.callout-note}
Paths should always be separated by a regular `/` and not by a backslash `\` (common on Windows), as the latter introduces an *escape sequence*. To use a `\`, we must write it as `\\`.
:::

The `read` method of a file object reads the *entire file* and returns the content as a string:

```{python}
f = open("test.txt")
text = f.read()
print(text)
```

Note that this loads the *entire* content of the file into memory. For very large files, this can potentially cause problems, which is why we should read (larger) text files *line by line* (more on this later).

:::{.callout-tip}
We can read the content of a file only once. If the entire content has already been read, the so-called file pointer is at the end of the file. If we try to read again, we just get an empty string:

```{python}
f.read()  # reached end of file
```

If we want to read the file again, we must close it and then open it again:

```{python}
f.close()  # closes the file
```
:::

The `readline` method reads *a single line* from the file from the current position:

```{python}
with open("test.txt") as f:
    print("Row 1: ", f.readline(), end="")
    print("Row 2: ", f.readline(), end="")
    print("Row 3: ", f.readline(), end="")
```

We can also iterate over the file object in a loop to read the file line by line:

```{python}
with open("test.txt") as f:
    for line in f:
        print(line, end="")
```

This way, we can easily manipulate individual lines, e.g., to include line numbers in the output (which are not contained in the file itself):

```{python}
with open("test.txt") as f:
    for no, line in enumerate(f):
        print(no, line, end="")
```

:::{.callout-tip}
In the previous example, the `for` loop does not directly iterate over `f`, but over `enumerate(f)`. This function counts (enumerates) the loop iterations and returns a tuple consisting of the current loop counter and the current line.
:::

To write text to a file, we open the file in `"w"` mode and pass the desired content as a string to the `write` method:

```python
with open("test2.txt", "w") as f:
    f.write("This is a test.\nThis is how you write\ntext\nto a file.")
```

In this example, the escape sequence `\n` corresponds to a line break (new line).


## Example: Reading a CSV file

With the tools presented so far, we can already read CSV[^1] files and calculate simple statistics. CSV files are often used to store tabular data. These files are plain text files in which the variables (columns) are separated by commas, and the individual records are stored line by line.

The following sections present three ways to read a CSV file (the example file `correlation.csv` is available [here](correlation.csv)). The first method uses Python without any additional modules, and the second method is a generalization of the first. The third and simplest method uses the [pandas](https://pandas.pydata.org/) package, which we will not get to know in detail in this course (it is mentioned here for completeness and to show how easy it is to read a CSV file in practice).

[^1]: Comma-Separated Values


### Option 1

We start with an empty list called `data`. We then add the content of each line step by step (using `append`) to this list. First, we remove any leading and trailing spaces from a line using `.strip()`, and then we split the line at the comma into a list with two elements using `.split(",")`:

```{python}
data = []  # emtpy list
with open("correlation.csv") as f:
    for row in f:
        data.append(row.strip().split(","))
```

```{python}
data
```

Now we can convert the data into a structure that is better suited for subsequent calculations (in particular, we want to convert the strings to numbers). We can do this by iterating over the list and converting the strings to floats:

```{python}
cols = [[], []]  # two empty lists for the two columns
for row in data[1:]:  # skip row 0
    cols[0].append(float(row[0]))  # column 1
    cols[1].append(float(row[1]))  # column 2
```

Both columns are now available in the list `cols`. This list has two elements:

```{python}
len(cols)
```

Each of these two entries in `cols` is also a list:

```{python}
type(cols[0]), type(cols[1])
```

The length of both lists corresponds to the number of rows in the CSV file (excluding the header):

```{python}
len(cols[0]), len(cols[1])
```

The elements in these two lists are numbers:

```{python}
cols[0]
```

```{python}
cols[1]
```

With these two lists, we can now perform calculations. For example, we can calculate the column means as follows:

```{python}
sum(cols[0]) / len(cols[0])
```

```{python}
sum(cols[1]) / len(cols[1])
```

This solutions works, but it is far from ideal. First, there are existing packages that we could use instead of developing everything from scratch (Python has its own `csv` module, and the `pandas` package is ideal for such tasks). Second, this solution is very specific to the specific file, e.g., the approach only works for a file with exactly two columns.


### Option 2

A generalized solution for an *arbitrary* number of columns looks like this:

```{python}
with open("correlation.csv") as f:
    header = f.readline().strip().split(",")  # first row

    data = {}  # dict with one entry per column
    for name in header:
        data[name] = []  # key = column name, value = empty list

    for row in f:  # remaining rows
        values = row.strip().split(",")
        for h, v in zip(header, values):
            data[h].append(float(v))  # append to correct list
```

Here, we first read the variable names from the first line (the header). Next, we create a dictionary with one entry per column, where the key is the column name and the value is an empty list. We then iterate over the remaining lines and add the values of the columns to the correct dictionary entries.

```{python}
data
```

This solution works with any number of columns, but it assumes that there is a header row. The column means can then be calculated as follows:

```{python}
sum(data["essay"]) / len(data["essay"])
```

```{python}
sum(data["hours"]) / len(data["hours"])
```


### Option 3

The `pandas` package is perfect for processing tabular data. It also includes functions for reading files. Our code would look like this:

```{python}
import pandas as pd

data = pd.read_csv("correlation.csv")
```

```{python}
data
```

We can calculate the column means as follows:

```{python}
#| scrolled: true
data.mean()
```

Clearly, this solution is much shorter, easier to read, and more powerful than any of the previous custom methods.


## Exercises

### Exercise 1

Create a list `lst` that contains the *even* numbers between 0 and 100 (inclusive) and save these numbers to a file `ex1.txt`. Each number should be on a separate line.

:::{.callout-note}
You should convert the numbers to strings before writing them to the file (using the `str` function). The character (escape sequence) for a line break is `\n`. You can iterate over the list of numbers with a `for` loop and write the individual elements to the file one after the other. Alternatively, you can convert the list into a single properly formatted string (the `join` string method is helpful here) and then write this string to the file.
:::


### Exercise 2

Use the list `lst` from Exercise 1, but write the numbers to a file `ex2.txt` so that they are separated by commas in a single line.


### Exercise 3

Scrabble is an excellent opportunity to discuss the existence of words. At least for the English edition, there is an [official word list](http://www.freescrabbledictionary.com/sowpods/) that you can consult if you are unsure whether a word is valid or not. All words in this database can be downloaded as a [text file](https://www.wordgamedictionary.com/sowpods/download/sowpods.txt).

For this exercise, download this file and save it in your working directory. Read the file into Python and find out how many valid words (lines) exist.

:::{.callout-note}
Iterate over the file line by line and count the number of iterations. At the end of the loop, your counter corresponds to the number of lines in the file (i.e., the number of words). Note that the first few lines in the file do not contain words!

If you want to be very exact, you should also check whether the current line actually contains a word (i.e., is not an empty line).
:::


### Exercise 4

Use the word list from Exercise 3 and find out how many words contain more than 14 letters in the list (i.e., words with 15 letters or more).

:::{.callout-note}
Iterate over the file line by line and remove invisible characters (such as line breaks) with the `strip` method before determining the length of the current word. Otherwise, the length is always one larger than the length of the word because the content of a line is e.g., `abandon\n`, and `\n` is counted as a character. Only increase your counter if the length of the current word (without line break) is greater than 14!
:::
